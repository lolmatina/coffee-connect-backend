
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model LocationStaff
 * 
 */
export type LocationStaff = $Result.DefaultSelection<Prisma.$LocationStaffPayload>
/**
 * Model MenuTemplate
 * 
 */
export type MenuTemplate = $Result.DefaultSelection<Prisma.$MenuTemplatePayload>
/**
 * Model TemplateItem
 * 
 */
export type TemplateItem = $Result.DefaultSelection<Prisma.$TemplateItemPayload>
/**
 * Model TemplateItemVariant
 * 
 */
export type TemplateItemVariant = $Result.DefaultSelection<Prisma.$TemplateItemVariantPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model MenuItemOverride
 * 
 */
export type MenuItemOverride = $Result.DefaultSelection<Prisma.$MenuItemOverridePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TemplateItemTag
 * 
 */
export type TemplateItemTag = $Result.DefaultSelection<Prisma.$TemplateItemTagPayload>
/**
 * Model Addon
 * 
 */
export type Addon = $Result.DefaultSelection<Prisma.$AddonPayload>
/**
 * Model TemplateItemAddon
 * 
 */
export type TemplateItemAddon = $Result.DefaultSelection<Prisma.$TemplateItemAddonPayload>
/**
 * Model AddonCategory
 * 
 */
export type AddonCategory = $Result.DefaultSelection<Prisma.$AddonCategoryPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  COFFEE_SHOP_OWNER: 'COFFEE_SHOP_OWNER',
  COFFEE_SHOP_MANAGER: 'COFFEE_SHOP_MANAGER',
  COFFEE_SHOP_STAFF: 'COFFEE_SHOP_STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationStaff`: Exposes CRUD operations for the **LocationStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationStaffs
    * const locationStaffs = await prisma.locationStaff.findMany()
    * ```
    */
  get locationStaff(): Prisma.LocationStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuTemplate`: Exposes CRUD operations for the **MenuTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuTemplates
    * const menuTemplates = await prisma.menuTemplate.findMany()
    * ```
    */
  get menuTemplate(): Prisma.MenuTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateItem`: Exposes CRUD operations for the **TemplateItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateItems
    * const templateItems = await prisma.templateItem.findMany()
    * ```
    */
  get templateItem(): Prisma.TemplateItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateItemVariant`: Exposes CRUD operations for the **TemplateItemVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateItemVariants
    * const templateItemVariants = await prisma.templateItemVariant.findMany()
    * ```
    */
  get templateItemVariant(): Prisma.TemplateItemVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuItemOverride`: Exposes CRUD operations for the **MenuItemOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItemOverrides
    * const menuItemOverrides = await prisma.menuItemOverride.findMany()
    * ```
    */
  get menuItemOverride(): Prisma.MenuItemOverrideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateItemTag`: Exposes CRUD operations for the **TemplateItemTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateItemTags
    * const templateItemTags = await prisma.templateItemTag.findMany()
    * ```
    */
  get templateItemTag(): Prisma.TemplateItemTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addon`: Exposes CRUD operations for the **Addon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addons
    * const addons = await prisma.addon.findMany()
    * ```
    */
  get addon(): Prisma.AddonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateItemAddon`: Exposes CRUD operations for the **TemplateItemAddon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateItemAddons
    * const templateItemAddons = await prisma.templateItemAddon.findMany()
    * ```
    */
  get templateItemAddon(): Prisma.TemplateItemAddonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addonCategory`: Exposes CRUD operations for the **AddonCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddonCategories
    * const addonCategories = await prisma.addonCategory.findMany()
    * ```
    */
  get addonCategory(): Prisma.AddonCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfile: 'UserProfile',
    Brand: 'Brand',
    Location: 'Location',
    LocationStaff: 'LocationStaff',
    MenuTemplate: 'MenuTemplate',
    TemplateItem: 'TemplateItem',
    TemplateItemVariant: 'TemplateItemVariant',
    Menu: 'Menu',
    MenuItemOverride: 'MenuItemOverride',
    Tag: 'Tag',
    TemplateItemTag: 'TemplateItemTag',
    Addon: 'Addon',
    TemplateItemAddon: 'TemplateItemAddon',
    AddonCategory: 'AddonCategory',
    Order: 'Order',
    Customer: 'Customer',
    OrderItem: 'OrderItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userProfile" | "brand" | "location" | "locationStaff" | "menuTemplate" | "templateItem" | "templateItemVariant" | "menu" | "menuItemOverride" | "tag" | "templateItemTag" | "addon" | "templateItemAddon" | "addonCategory" | "order" | "customer" | "orderItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      LocationStaff: {
        payload: Prisma.$LocationStaffPayload<ExtArgs>
        fields: Prisma.LocationStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>
          }
          findFirst: {
            args: Prisma.LocationStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>
          }
          findMany: {
            args: Prisma.LocationStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>[]
          }
          create: {
            args: Prisma.LocationStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>
          }
          createMany: {
            args: Prisma.LocationStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>[]
          }
          delete: {
            args: Prisma.LocationStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>
          }
          update: {
            args: Prisma.LocationStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>
          }
          deleteMany: {
            args: Prisma.LocationStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>[]
          }
          upsert: {
            args: Prisma.LocationStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationStaffPayload>
          }
          aggregate: {
            args: Prisma.LocationStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationStaff>
          }
          groupBy: {
            args: Prisma.LocationStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationStaffCountArgs<ExtArgs>
            result: $Utils.Optional<LocationStaffCountAggregateOutputType> | number
          }
        }
      }
      MenuTemplate: {
        payload: Prisma.$MenuTemplatePayload<ExtArgs>
        fields: Prisma.MenuTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>
          }
          findFirst: {
            args: Prisma.MenuTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>
          }
          findMany: {
            args: Prisma.MenuTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>[]
          }
          create: {
            args: Prisma.MenuTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>
          }
          createMany: {
            args: Prisma.MenuTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>[]
          }
          delete: {
            args: Prisma.MenuTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>
          }
          update: {
            args: Prisma.MenuTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MenuTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>[]
          }
          upsert: {
            args: Prisma.MenuTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuTemplatePayload>
          }
          aggregate: {
            args: Prisma.MenuTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuTemplate>
          }
          groupBy: {
            args: Prisma.MenuTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MenuTemplateCountAggregateOutputType> | number
          }
        }
      }
      TemplateItem: {
        payload: Prisma.$TemplateItemPayload<ExtArgs>
        fields: Prisma.TemplateItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>
          }
          findFirst: {
            args: Prisma.TemplateItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>
          }
          findMany: {
            args: Prisma.TemplateItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>[]
          }
          create: {
            args: Prisma.TemplateItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>
          }
          createMany: {
            args: Prisma.TemplateItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>[]
          }
          delete: {
            args: Prisma.TemplateItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>
          }
          update: {
            args: Prisma.TemplateItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>
          }
          deleteMany: {
            args: Prisma.TemplateItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>[]
          }
          upsert: {
            args: Prisma.TemplateItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemPayload>
          }
          aggregate: {
            args: Prisma.TemplateItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateItem>
          }
          groupBy: {
            args: Prisma.TemplateItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateItemCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemCountAggregateOutputType> | number
          }
        }
      }
      TemplateItemVariant: {
        payload: Prisma.$TemplateItemVariantPayload<ExtArgs>
        fields: Prisma.TemplateItemVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateItemVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateItemVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>
          }
          findFirst: {
            args: Prisma.TemplateItemVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateItemVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>
          }
          findMany: {
            args: Prisma.TemplateItemVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>[]
          }
          create: {
            args: Prisma.TemplateItemVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>
          }
          createMany: {
            args: Prisma.TemplateItemVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateItemVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>[]
          }
          delete: {
            args: Prisma.TemplateItemVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>
          }
          update: {
            args: Prisma.TemplateItemVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>
          }
          deleteMany: {
            args: Prisma.TemplateItemVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateItemVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateItemVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>[]
          }
          upsert: {
            args: Prisma.TemplateItemVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemVariantPayload>
          }
          aggregate: {
            args: Prisma.TemplateItemVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateItemVariant>
          }
          groupBy: {
            args: Prisma.TemplateItemVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateItemVariantCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemVariantCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      MenuItemOverride: {
        payload: Prisma.$MenuItemOverridePayload<ExtArgs>
        fields: Prisma.MenuItemOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>
          }
          findFirst: {
            args: Prisma.MenuItemOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>
          }
          findMany: {
            args: Prisma.MenuItemOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>[]
          }
          create: {
            args: Prisma.MenuItemOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>
          }
          createMany: {
            args: Prisma.MenuItemOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>[]
          }
          delete: {
            args: Prisma.MenuItemOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>
          }
          update: {
            args: Prisma.MenuItemOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>
          }
          deleteMany: {
            args: Prisma.MenuItemOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuItemOverrideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>[]
          }
          upsert: {
            args: Prisma.MenuItemOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemOverridePayload>
          }
          aggregate: {
            args: Prisma.MenuItemOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItemOverride>
          }
          groupBy: {
            args: Prisma.MenuItemOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemOverrideCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TemplateItemTag: {
        payload: Prisma.$TemplateItemTagPayload<ExtArgs>
        fields: Prisma.TemplateItemTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateItemTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateItemTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>
          }
          findFirst: {
            args: Prisma.TemplateItemTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateItemTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>
          }
          findMany: {
            args: Prisma.TemplateItemTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>[]
          }
          create: {
            args: Prisma.TemplateItemTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>
          }
          createMany: {
            args: Prisma.TemplateItemTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateItemTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>[]
          }
          delete: {
            args: Prisma.TemplateItemTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>
          }
          update: {
            args: Prisma.TemplateItemTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>
          }
          deleteMany: {
            args: Prisma.TemplateItemTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateItemTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateItemTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>[]
          }
          upsert: {
            args: Prisma.TemplateItemTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemTagPayload>
          }
          aggregate: {
            args: Prisma.TemplateItemTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateItemTag>
          }
          groupBy: {
            args: Prisma.TemplateItemTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateItemTagCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemTagCountAggregateOutputType> | number
          }
        }
      }
      Addon: {
        payload: Prisma.$AddonPayload<ExtArgs>
        fields: Prisma.AddonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          findFirst: {
            args: Prisma.AddonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          findMany: {
            args: Prisma.AddonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>[]
          }
          create: {
            args: Prisma.AddonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          createMany: {
            args: Prisma.AddonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>[]
          }
          delete: {
            args: Prisma.AddonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          update: {
            args: Prisma.AddonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          deleteMany: {
            args: Prisma.AddonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>[]
          }
          upsert: {
            args: Prisma.AddonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          aggregate: {
            args: Prisma.AddonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddon>
          }
          groupBy: {
            args: Prisma.AddonGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddonGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddonCountArgs<ExtArgs>
            result: $Utils.Optional<AddonCountAggregateOutputType> | number
          }
        }
      }
      TemplateItemAddon: {
        payload: Prisma.$TemplateItemAddonPayload<ExtArgs>
        fields: Prisma.TemplateItemAddonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateItemAddonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateItemAddonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>
          }
          findFirst: {
            args: Prisma.TemplateItemAddonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateItemAddonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>
          }
          findMany: {
            args: Prisma.TemplateItemAddonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>[]
          }
          create: {
            args: Prisma.TemplateItemAddonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>
          }
          createMany: {
            args: Prisma.TemplateItemAddonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateItemAddonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>[]
          }
          delete: {
            args: Prisma.TemplateItemAddonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>
          }
          update: {
            args: Prisma.TemplateItemAddonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>
          }
          deleteMany: {
            args: Prisma.TemplateItemAddonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateItemAddonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateItemAddonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>[]
          }
          upsert: {
            args: Prisma.TemplateItemAddonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateItemAddonPayload>
          }
          aggregate: {
            args: Prisma.TemplateItemAddonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateItemAddon>
          }
          groupBy: {
            args: Prisma.TemplateItemAddonGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemAddonGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateItemAddonCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateItemAddonCountAggregateOutputType> | number
          }
        }
      }
      AddonCategory: {
        payload: Prisma.$AddonCategoryPayload<ExtArgs>
        fields: Prisma.AddonCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddonCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddonCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>
          }
          findFirst: {
            args: Prisma.AddonCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddonCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>
          }
          findMany: {
            args: Prisma.AddonCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>[]
          }
          create: {
            args: Prisma.AddonCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>
          }
          createMany: {
            args: Prisma.AddonCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddonCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>[]
          }
          delete: {
            args: Prisma.AddonCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>
          }
          update: {
            args: Prisma.AddonCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>
          }
          deleteMany: {
            args: Prisma.AddonCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddonCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddonCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>[]
          }
          upsert: {
            args: Prisma.AddonCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonCategoryPayload>
          }
          aggregate: {
            args: Prisma.AddonCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddonCategory>
          }
          groupBy: {
            args: Prisma.AddonCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddonCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddonCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<AddonCategoryCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userProfile?: UserProfileOmit
    brand?: BrandOmit
    location?: LocationOmit
    locationStaff?: LocationStaffOmit
    menuTemplate?: MenuTemplateOmit
    templateItem?: TemplateItemOmit
    templateItemVariant?: TemplateItemVariantOmit
    menu?: MenuOmit
    menuItemOverride?: MenuItemOverrideOmit
    tag?: TagOmit
    templateItemTag?: TemplateItemTagOmit
    addon?: AddonOmit
    templateItemAddon?: TemplateItemAddonOmit
    addonCategory?: AddonCategoryOmit
    order?: OrderOmit
    customer?: CustomerOmit
    orderItem?: OrderItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Brand: number
    Location: number
    LocationStaff: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Brand?: boolean | UserCountOutputTypeCountBrandArgs
    Location?: boolean | UserCountOutputTypeCountLocationArgs
    LocationStaff?: boolean | UserCountOutputTypeCountLocationStaffArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLocationStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationStaffWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    Location: number
    MenuTemplate: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Location?: boolean | BrandCountOutputTypeCountLocationArgs
    MenuTemplate?: boolean | BrandCountOutputTypeCountMenuTemplateArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountMenuTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuTemplateWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    LocationStaff: number
    Menu: number
    Order: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LocationStaff?: boolean | LocationCountOutputTypeCountLocationStaffArgs
    Menu?: boolean | LocationCountOutputTypeCountMenuArgs
    Order?: boolean | LocationCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountLocationStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationStaffWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type MenuTemplateCountOutputType
   */

  export type MenuTemplateCountOutputType = {
    items: number
    Menu: number
    Addon: number
    AddonCategory: number
  }

  export type MenuTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | MenuTemplateCountOutputTypeCountItemsArgs
    Menu?: boolean | MenuTemplateCountOutputTypeCountMenuArgs
    Addon?: boolean | MenuTemplateCountOutputTypeCountAddonArgs
    AddonCategory?: boolean | MenuTemplateCountOutputTypeCountAddonCategoryArgs
  }

  // Custom InputTypes
  /**
   * MenuTemplateCountOutputType without action
   */
  export type MenuTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplateCountOutputType
     */
    select?: MenuTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuTemplateCountOutputType without action
   */
  export type MenuTemplateCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemWhereInput
  }

  /**
   * MenuTemplateCountOutputType without action
   */
  export type MenuTemplateCountOutputTypeCountMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }

  /**
   * MenuTemplateCountOutputType without action
   */
  export type MenuTemplateCountOutputTypeCountAddonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonWhereInput
  }

  /**
   * MenuTemplateCountOutputType without action
   */
  export type MenuTemplateCountOutputTypeCountAddonCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonCategoryWhereInput
  }


  /**
   * Count Type TemplateItemCountOutputType
   */

  export type TemplateItemCountOutputType = {
    variants: number
    MenuItemOverride: number
    Tag: number
    OrderItem: number
    TemplateItemTag: number
    TemplateItemAddon: number
  }

  export type TemplateItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | TemplateItemCountOutputTypeCountVariantsArgs
    MenuItemOverride?: boolean | TemplateItemCountOutputTypeCountMenuItemOverrideArgs
    Tag?: boolean | TemplateItemCountOutputTypeCountTagArgs
    OrderItem?: boolean | TemplateItemCountOutputTypeCountOrderItemArgs
    TemplateItemTag?: boolean | TemplateItemCountOutputTypeCountTemplateItemTagArgs
    TemplateItemAddon?: boolean | TemplateItemCountOutputTypeCountTemplateItemAddonArgs
  }

  // Custom InputTypes
  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemCountOutputType
     */
    select?: TemplateItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemVariantWhereInput
  }

  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeCountMenuItemOverrideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemOverrideWhereInput
  }

  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeCountTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeCountTemplateItemTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemTagWhereInput
  }

  /**
   * TemplateItemCountOutputType without action
   */
  export type TemplateItemCountOutputTypeCountTemplateItemAddonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemAddonWhereInput
  }


  /**
   * Count Type TemplateItemVariantCountOutputType
   */

  export type TemplateItemVariantCountOutputType = {
    OrderItem: number
  }

  export type TemplateItemVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | TemplateItemVariantCountOutputTypeCountOrderItemArgs
  }

  // Custom InputTypes
  /**
   * TemplateItemVariantCountOutputType without action
   */
  export type TemplateItemVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariantCountOutputType
     */
    select?: TemplateItemVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateItemVariantCountOutputType without action
   */
  export type TemplateItemVariantCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    overrides: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    overrides?: boolean | MenuCountOutputTypeCountOverridesArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemOverrideWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    items: number
    TemplateItem: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TagCountOutputTypeCountItemsArgs
    TemplateItem?: boolean | TagCountOutputTypeCountTemplateItemArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTemplateItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemWhereInput
  }


  /**
   * Count Type AddonCountOutputType
   */

  export type AddonCountOutputType = {
    items: number
  }

  export type AddonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AddonCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * AddonCountOutputType without action
   */
  export type AddonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCountOutputType
     */
    select?: AddonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddonCountOutputType without action
   */
  export type AddonCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemAddonWhereInput
  }


  /**
   * Count Type AddonCategoryCountOutputType
   */

  export type AddonCategoryCountOutputType = {
    addons: number
  }

  export type AddonCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addons?: boolean | AddonCategoryCountOutputTypeCountAddonsArgs
  }

  // Custom InputTypes
  /**
   * AddonCategoryCountOutputType without action
   */
  export type AddonCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategoryCountOutputType
     */
    select?: AddonCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddonCategoryCountOutputType without action
   */
  export type AddonCategoryCountOutputTypeCountAddonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    refreshToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Brand?: boolean | User$BrandArgs<ExtArgs>
    Location?: boolean | User$LocationArgs<ExtArgs>
    LocationStaff?: boolean | User$LocationStaffArgs<ExtArgs>
    UserProfile?: boolean | User$UserProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "refreshToken" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Brand?: boolean | User$BrandArgs<ExtArgs>
    Location?: boolean | User$LocationArgs<ExtArgs>
    LocationStaff?: boolean | User$LocationStaffArgs<ExtArgs>
    UserProfile?: boolean | User$UserProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Brand: Prisma.$BrandPayload<ExtArgs>[]
      Location: Prisma.$LocationPayload<ExtArgs>[]
      LocationStaff: Prisma.$LocationStaffPayload<ExtArgs>[]
      UserProfile: Prisma.$UserProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: $Enums.UserRole
      refreshToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Brand<T extends User$BrandArgs<ExtArgs> = {}>(args?: Subset<T, User$BrandArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Location<T extends User$LocationArgs<ExtArgs> = {}>(args?: Subset<T, User$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LocationStaff<T extends User$LocationStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$LocationStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserProfile<T extends User$UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$UserProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Brand
   */
  export type User$BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    cursor?: BrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * User.Location
   */
  export type User$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * User.LocationStaff
   */
  export type User$LocationStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    where?: LocationStaffWhereInput
    orderBy?: LocationStaffOrderByWithRelationInput | LocationStaffOrderByWithRelationInput[]
    cursor?: LocationStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationStaffScalarFieldEnum | LocationStaffScalarFieldEnum[]
  }

  /**
   * User.UserProfile
   */
  export type User$UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    userId: number | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    userId: number | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phoneNumber: number
    userId: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    userId?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    userId?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    userId?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    phoneNumber: string | null
    userId: number
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    userId?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "phoneNumber" | "userId", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      phoneNumber: string | null
      userId: number
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'Int'>
    readonly firstName: FieldRef<"UserProfile", 'String'>
    readonly lastName: FieldRef<"UserProfile", 'String'>
    readonly phoneNumber: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    ownerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ownerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    ownerId: number
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    Location?: boolean | Brand$LocationArgs<ExtArgs>
    MenuTemplate?: boolean | Brand$MenuTemplateArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    Location?: boolean | Brand$LocationArgs<ExtArgs>
    MenuTemplate?: boolean | Brand$MenuTemplateArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      Location: Prisma.$LocationPayload<ExtArgs>[]
      MenuTemplate: Prisma.$MenuTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      ownerId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Location<T extends Brand$LocationArgs<ExtArgs> = {}>(args?: Subset<T, Brand$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MenuTemplate<T extends Brand$MenuTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Brand$MenuTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'Int'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly ownerId: FieldRef<"Brand", 'Int'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.Location
   */
  export type Brand$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Brand.MenuTemplate
   */
  export type Brand$MenuTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    where?: MenuTemplateWhereInput
    orderBy?: MenuTemplateOrderByWithRelationInput | MenuTemplateOrderByWithRelationInput[]
    cursor?: MenuTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuTemplateScalarFieldEnum | MenuTemplateScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    managerId: number | null
    BrandId: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    managerId: number | null
    BrandId: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    placeId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    geohash: string | null
    timezone: string | null
    accuracy: number | null
    managerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    BrandId: number | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    placeId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    geohash: string | null
    timezone: string | null
    accuracy: number | null
    managerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    BrandId: number | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
    placeId: number
    name: number
    address: number
    city: number
    state: number
    country: number
    postalCode: number
    geohash: number
    timezone: number
    accuracy: number
    managerId: number
    createdAt: number
    updatedAt: number
    BrandId: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    managerId?: true
    BrandId?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    managerId?: true
    BrandId?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    placeId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    geohash?: true
    timezone?: true
    accuracy?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    BrandId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    placeId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    geohash?: true
    timezone?: true
    accuracy?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    BrandId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    placeId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    geohash?: true
    timezone?: true
    accuracy?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    BrandId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    latitude: number
    longitude: number
    placeId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    geohash: string | null
    timezone: string | null
    accuracy: number | null
    managerId: number | null
    createdAt: Date
    updatedAt: Date
    BrandId: number
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    placeId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    geohash?: boolean
    timezone?: boolean
    accuracy?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BrandId?: boolean
    manager?: boolean | Location$managerArgs<ExtArgs>
    Brand?: boolean | BrandDefaultArgs<ExtArgs>
    LocationStaff?: boolean | Location$LocationStaffArgs<ExtArgs>
    Menu?: boolean | Location$MenuArgs<ExtArgs>
    Order?: boolean | Location$OrderArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    placeId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    geohash?: boolean
    timezone?: boolean
    accuracy?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BrandId?: boolean
    manager?: boolean | Location$managerArgs<ExtArgs>
    Brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    placeId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    geohash?: boolean
    timezone?: boolean
    accuracy?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BrandId?: boolean
    manager?: boolean | Location$managerArgs<ExtArgs>
    Brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    placeId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    geohash?: boolean
    timezone?: boolean
    accuracy?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BrandId?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "latitude" | "longitude" | "placeId" | "name" | "address" | "city" | "state" | "country" | "postalCode" | "geohash" | "timezone" | "accuracy" | "managerId" | "createdAt" | "updatedAt" | "BrandId", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | Location$managerArgs<ExtArgs>
    Brand?: boolean | BrandDefaultArgs<ExtArgs>
    LocationStaff?: boolean | Location$LocationStaffArgs<ExtArgs>
    Menu?: boolean | Location$MenuArgs<ExtArgs>
    Order?: boolean | Location$OrderArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | Location$managerArgs<ExtArgs>
    Brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | Location$managerArgs<ExtArgs>
    Brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      manager: Prisma.$UserPayload<ExtArgs> | null
      Brand: Prisma.$BrandPayload<ExtArgs>
      LocationStaff: Prisma.$LocationStaffPayload<ExtArgs>[]
      Menu: Prisma.$MenuPayload<ExtArgs>[]
      Order: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      latitude: number
      longitude: number
      placeId: string | null
      name: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      postalCode: string | null
      geohash: string | null
      timezone: string | null
      accuracy: number | null
      managerId: number | null
      createdAt: Date
      updatedAt: Date
      BrandId: number
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends Location$managerArgs<ExtArgs> = {}>(args?: Subset<T, Location$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LocationStaff<T extends Location$LocationStaffArgs<ExtArgs> = {}>(args?: Subset<T, Location$LocationStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Menu<T extends Location$MenuArgs<ExtArgs> = {}>(args?: Subset<T, Location$MenuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Order<T extends Location$OrderArgs<ExtArgs> = {}>(args?: Subset<T, Location$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly placeId: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly postalCode: FieldRef<"Location", 'String'>
    readonly geohash: FieldRef<"Location", 'String'>
    readonly timezone: FieldRef<"Location", 'String'>
    readonly accuracy: FieldRef<"Location", 'Float'>
    readonly managerId: FieldRef<"Location", 'Int'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
    readonly BrandId: FieldRef<"Location", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.manager
   */
  export type Location$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Location.LocationStaff
   */
  export type Location$LocationStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    where?: LocationStaffWhereInput
    orderBy?: LocationStaffOrderByWithRelationInput | LocationStaffOrderByWithRelationInput[]
    cursor?: LocationStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationStaffScalarFieldEnum | LocationStaffScalarFieldEnum[]
  }

  /**
   * Location.Menu
   */
  export type Location$MenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Location.Order
   */
  export type Location$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model LocationStaff
   */

  export type AggregateLocationStaff = {
    _count: LocationStaffCountAggregateOutputType | null
    _avg: LocationStaffAvgAggregateOutputType | null
    _sum: LocationStaffSumAggregateOutputType | null
    _min: LocationStaffMinAggregateOutputType | null
    _max: LocationStaffMaxAggregateOutputType | null
  }

  export type LocationStaffAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
    staffId: number | null
  }

  export type LocationStaffSumAggregateOutputType = {
    id: number | null
    locationId: number | null
    staffId: number | null
  }

  export type LocationStaffMinAggregateOutputType = {
    id: number | null
    locationId: number | null
    staffId: number | null
  }

  export type LocationStaffMaxAggregateOutputType = {
    id: number | null
    locationId: number | null
    staffId: number | null
  }

  export type LocationStaffCountAggregateOutputType = {
    id: number
    locationId: number
    staffId: number
    _all: number
  }


  export type LocationStaffAvgAggregateInputType = {
    id?: true
    locationId?: true
    staffId?: true
  }

  export type LocationStaffSumAggregateInputType = {
    id?: true
    locationId?: true
    staffId?: true
  }

  export type LocationStaffMinAggregateInputType = {
    id?: true
    locationId?: true
    staffId?: true
  }

  export type LocationStaffMaxAggregateInputType = {
    id?: true
    locationId?: true
    staffId?: true
  }

  export type LocationStaffCountAggregateInputType = {
    id?: true
    locationId?: true
    staffId?: true
    _all?: true
  }

  export type LocationStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationStaff to aggregate.
     */
    where?: LocationStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationStaffs to fetch.
     */
    orderBy?: LocationStaffOrderByWithRelationInput | LocationStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationStaffs
    **/
    _count?: true | LocationStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationStaffMaxAggregateInputType
  }

  export type GetLocationStaffAggregateType<T extends LocationStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationStaff[P]>
      : GetScalarType<T[P], AggregateLocationStaff[P]>
  }




  export type LocationStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationStaffWhereInput
    orderBy?: LocationStaffOrderByWithAggregationInput | LocationStaffOrderByWithAggregationInput[]
    by: LocationStaffScalarFieldEnum[] | LocationStaffScalarFieldEnum
    having?: LocationStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationStaffCountAggregateInputType | true
    _avg?: LocationStaffAvgAggregateInputType
    _sum?: LocationStaffSumAggregateInputType
    _min?: LocationStaffMinAggregateInputType
    _max?: LocationStaffMaxAggregateInputType
  }

  export type LocationStaffGroupByOutputType = {
    id: number
    locationId: number
    staffId: number
    _count: LocationStaffCountAggregateOutputType | null
    _avg: LocationStaffAvgAggregateOutputType | null
    _sum: LocationStaffSumAggregateOutputType | null
    _min: LocationStaffMinAggregateOutputType | null
    _max: LocationStaffMaxAggregateOutputType | null
  }

  type GetLocationStaffGroupByPayload<T extends LocationStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationStaffGroupByOutputType[P]>
            : GetScalarType<T[P], LocationStaffGroupByOutputType[P]>
        }
      >
    >


  export type LocationStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    staffId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationStaff"]>

  export type LocationStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    staffId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationStaff"]>

  export type LocationStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    staffId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationStaff"]>

  export type LocationStaffSelectScalar = {
    id?: boolean
    locationId?: boolean
    staffId?: boolean
  }

  export type LocationStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "staffId", ExtArgs["result"]["locationStaff"]>
  export type LocationStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LocationStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LocationStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LocationStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationStaff"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      locationId: number
      staffId: number
    }, ExtArgs["result"]["locationStaff"]>
    composites: {}
  }

  type LocationStaffGetPayload<S extends boolean | null | undefined | LocationStaffDefaultArgs> = $Result.GetResult<Prisma.$LocationStaffPayload, S>

  type LocationStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationStaffCountAggregateInputType | true
    }

  export interface LocationStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationStaff'], meta: { name: 'LocationStaff' } }
    /**
     * Find zero or one LocationStaff that matches the filter.
     * @param {LocationStaffFindUniqueArgs} args - Arguments to find a LocationStaff
     * @example
     * // Get one LocationStaff
     * const locationStaff = await prisma.locationStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationStaffFindUniqueArgs>(args: SelectSubset<T, LocationStaffFindUniqueArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationStaffFindUniqueOrThrowArgs} args - Arguments to find a LocationStaff
     * @example
     * // Get one LocationStaff
     * const locationStaff = await prisma.locationStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffFindFirstArgs} args - Arguments to find a LocationStaff
     * @example
     * // Get one LocationStaff
     * const locationStaff = await prisma.locationStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationStaffFindFirstArgs>(args?: SelectSubset<T, LocationStaffFindFirstArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffFindFirstOrThrowArgs} args - Arguments to find a LocationStaff
     * @example
     * // Get one LocationStaff
     * const locationStaff = await prisma.locationStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationStaffs
     * const locationStaffs = await prisma.locationStaff.findMany()
     * 
     * // Get first 10 LocationStaffs
     * const locationStaffs = await prisma.locationStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationStaffWithIdOnly = await prisma.locationStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationStaffFindManyArgs>(args?: SelectSubset<T, LocationStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationStaff.
     * @param {LocationStaffCreateArgs} args - Arguments to create a LocationStaff.
     * @example
     * // Create one LocationStaff
     * const LocationStaff = await prisma.locationStaff.create({
     *   data: {
     *     // ... data to create a LocationStaff
     *   }
     * })
     * 
     */
    create<T extends LocationStaffCreateArgs>(args: SelectSubset<T, LocationStaffCreateArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationStaffs.
     * @param {LocationStaffCreateManyArgs} args - Arguments to create many LocationStaffs.
     * @example
     * // Create many LocationStaffs
     * const locationStaff = await prisma.locationStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationStaffCreateManyArgs>(args?: SelectSubset<T, LocationStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationStaffs and returns the data saved in the database.
     * @param {LocationStaffCreateManyAndReturnArgs} args - Arguments to create many LocationStaffs.
     * @example
     * // Create many LocationStaffs
     * const locationStaff = await prisma.locationStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationStaffs and only return the `id`
     * const locationStaffWithIdOnly = await prisma.locationStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocationStaff.
     * @param {LocationStaffDeleteArgs} args - Arguments to delete one LocationStaff.
     * @example
     * // Delete one LocationStaff
     * const LocationStaff = await prisma.locationStaff.delete({
     *   where: {
     *     // ... filter to delete one LocationStaff
     *   }
     * })
     * 
     */
    delete<T extends LocationStaffDeleteArgs>(args: SelectSubset<T, LocationStaffDeleteArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationStaff.
     * @param {LocationStaffUpdateArgs} args - Arguments to update one LocationStaff.
     * @example
     * // Update one LocationStaff
     * const locationStaff = await prisma.locationStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationStaffUpdateArgs>(args: SelectSubset<T, LocationStaffUpdateArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationStaffs.
     * @param {LocationStaffDeleteManyArgs} args - Arguments to filter LocationStaffs to delete.
     * @example
     * // Delete a few LocationStaffs
     * const { count } = await prisma.locationStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationStaffDeleteManyArgs>(args?: SelectSubset<T, LocationStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationStaffs
     * const locationStaff = await prisma.locationStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationStaffUpdateManyArgs>(args: SelectSubset<T, LocationStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationStaffs and returns the data updated in the database.
     * @param {LocationStaffUpdateManyAndReturnArgs} args - Arguments to update many LocationStaffs.
     * @example
     * // Update many LocationStaffs
     * const locationStaff = await prisma.locationStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocationStaffs and only return the `id`
     * const locationStaffWithIdOnly = await prisma.locationStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocationStaff.
     * @param {LocationStaffUpsertArgs} args - Arguments to update or create a LocationStaff.
     * @example
     * // Update or create a LocationStaff
     * const locationStaff = await prisma.locationStaff.upsert({
     *   create: {
     *     // ... data to create a LocationStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationStaff we want to update
     *   }
     * })
     */
    upsert<T extends LocationStaffUpsertArgs>(args: SelectSubset<T, LocationStaffUpsertArgs<ExtArgs>>): Prisma__LocationStaffClient<$Result.GetResult<Prisma.$LocationStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocationStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffCountArgs} args - Arguments to filter LocationStaffs to count.
     * @example
     * // Count the number of LocationStaffs
     * const count = await prisma.locationStaff.count({
     *   where: {
     *     // ... the filter for the LocationStaffs we want to count
     *   }
     * })
    **/
    count<T extends LocationStaffCountArgs>(
      args?: Subset<T, LocationStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationStaffAggregateArgs>(args: Subset<T, LocationStaffAggregateArgs>): Prisma.PrismaPromise<GetLocationStaffAggregateType<T>>

    /**
     * Group by LocationStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationStaffGroupByArgs['orderBy'] }
        : { orderBy?: LocationStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationStaff model
   */
  readonly fields: LocationStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationStaff model
   */
  interface LocationStaffFieldRefs {
    readonly id: FieldRef<"LocationStaff", 'Int'>
    readonly locationId: FieldRef<"LocationStaff", 'Int'>
    readonly staffId: FieldRef<"LocationStaff", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LocationStaff findUnique
   */
  export type LocationStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * Filter, which LocationStaff to fetch.
     */
    where: LocationStaffWhereUniqueInput
  }

  /**
   * LocationStaff findUniqueOrThrow
   */
  export type LocationStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * Filter, which LocationStaff to fetch.
     */
    where: LocationStaffWhereUniqueInput
  }

  /**
   * LocationStaff findFirst
   */
  export type LocationStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * Filter, which LocationStaff to fetch.
     */
    where?: LocationStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationStaffs to fetch.
     */
    orderBy?: LocationStaffOrderByWithRelationInput | LocationStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationStaffs.
     */
    cursor?: LocationStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationStaffs.
     */
    distinct?: LocationStaffScalarFieldEnum | LocationStaffScalarFieldEnum[]
  }

  /**
   * LocationStaff findFirstOrThrow
   */
  export type LocationStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * Filter, which LocationStaff to fetch.
     */
    where?: LocationStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationStaffs to fetch.
     */
    orderBy?: LocationStaffOrderByWithRelationInput | LocationStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationStaffs.
     */
    cursor?: LocationStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationStaffs.
     */
    distinct?: LocationStaffScalarFieldEnum | LocationStaffScalarFieldEnum[]
  }

  /**
   * LocationStaff findMany
   */
  export type LocationStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * Filter, which LocationStaffs to fetch.
     */
    where?: LocationStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationStaffs to fetch.
     */
    orderBy?: LocationStaffOrderByWithRelationInput | LocationStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationStaffs.
     */
    cursor?: LocationStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationStaffs.
     */
    skip?: number
    distinct?: LocationStaffScalarFieldEnum | LocationStaffScalarFieldEnum[]
  }

  /**
   * LocationStaff create
   */
  export type LocationStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationStaff.
     */
    data: XOR<LocationStaffCreateInput, LocationStaffUncheckedCreateInput>
  }

  /**
   * LocationStaff createMany
   */
  export type LocationStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationStaffs.
     */
    data: LocationStaffCreateManyInput | LocationStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationStaff createManyAndReturn
   */
  export type LocationStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * The data used to create many LocationStaffs.
     */
    data: LocationStaffCreateManyInput | LocationStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationStaff update
   */
  export type LocationStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationStaff.
     */
    data: XOR<LocationStaffUpdateInput, LocationStaffUncheckedUpdateInput>
    /**
     * Choose, which LocationStaff to update.
     */
    where: LocationStaffWhereUniqueInput
  }

  /**
   * LocationStaff updateMany
   */
  export type LocationStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationStaffs.
     */
    data: XOR<LocationStaffUpdateManyMutationInput, LocationStaffUncheckedUpdateManyInput>
    /**
     * Filter which LocationStaffs to update
     */
    where?: LocationStaffWhereInput
    /**
     * Limit how many LocationStaffs to update.
     */
    limit?: number
  }

  /**
   * LocationStaff updateManyAndReturn
   */
  export type LocationStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * The data used to update LocationStaffs.
     */
    data: XOR<LocationStaffUpdateManyMutationInput, LocationStaffUncheckedUpdateManyInput>
    /**
     * Filter which LocationStaffs to update
     */
    where?: LocationStaffWhereInput
    /**
     * Limit how many LocationStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationStaff upsert
   */
  export type LocationStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationStaff to update in case it exists.
     */
    where: LocationStaffWhereUniqueInput
    /**
     * In case the LocationStaff found by the `where` argument doesn't exist, create a new LocationStaff with this data.
     */
    create: XOR<LocationStaffCreateInput, LocationStaffUncheckedCreateInput>
    /**
     * In case the LocationStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationStaffUpdateInput, LocationStaffUncheckedUpdateInput>
  }

  /**
   * LocationStaff delete
   */
  export type LocationStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
    /**
     * Filter which LocationStaff to delete.
     */
    where: LocationStaffWhereUniqueInput
  }

  /**
   * LocationStaff deleteMany
   */
  export type LocationStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationStaffs to delete
     */
    where?: LocationStaffWhereInput
    /**
     * Limit how many LocationStaffs to delete.
     */
    limit?: number
  }

  /**
   * LocationStaff without action
   */
  export type LocationStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationStaff
     */
    select?: LocationStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationStaff
     */
    omit?: LocationStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationStaffInclude<ExtArgs> | null
  }


  /**
   * Model MenuTemplate
   */

  export type AggregateMenuTemplate = {
    _count: MenuTemplateCountAggregateOutputType | null
    _avg: MenuTemplateAvgAggregateOutputType | null
    _sum: MenuTemplateSumAggregateOutputType | null
    _min: MenuTemplateMinAggregateOutputType | null
    _max: MenuTemplateMaxAggregateOutputType | null
  }

  export type MenuTemplateAvgAggregateOutputType = {
    id: number | null
    brandId: number | null
  }

  export type MenuTemplateSumAggregateOutputType = {
    id: number | null
    brandId: number | null
  }

  export type MenuTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    brandId: number | null
    createdAt: Date | null
  }

  export type MenuTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    brandId: number | null
    createdAt: Date | null
  }

  export type MenuTemplateCountAggregateOutputType = {
    id: number
    name: number
    brandId: number
    createdAt: number
    _all: number
  }


  export type MenuTemplateAvgAggregateInputType = {
    id?: true
    brandId?: true
  }

  export type MenuTemplateSumAggregateInputType = {
    id?: true
    brandId?: true
  }

  export type MenuTemplateMinAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    createdAt?: true
  }

  export type MenuTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    createdAt?: true
  }

  export type MenuTemplateCountAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    createdAt?: true
    _all?: true
  }

  export type MenuTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuTemplate to aggregate.
     */
    where?: MenuTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuTemplates to fetch.
     */
    orderBy?: MenuTemplateOrderByWithRelationInput | MenuTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuTemplates
    **/
    _count?: true | MenuTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuTemplateMaxAggregateInputType
  }

  export type GetMenuTemplateAggregateType<T extends MenuTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuTemplate[P]>
      : GetScalarType<T[P], AggregateMenuTemplate[P]>
  }




  export type MenuTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuTemplateWhereInput
    orderBy?: MenuTemplateOrderByWithAggregationInput | MenuTemplateOrderByWithAggregationInput[]
    by: MenuTemplateScalarFieldEnum[] | MenuTemplateScalarFieldEnum
    having?: MenuTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuTemplateCountAggregateInputType | true
    _avg?: MenuTemplateAvgAggregateInputType
    _sum?: MenuTemplateSumAggregateInputType
    _min?: MenuTemplateMinAggregateInputType
    _max?: MenuTemplateMaxAggregateInputType
  }

  export type MenuTemplateGroupByOutputType = {
    id: number
    name: string
    brandId: number
    createdAt: Date
    _count: MenuTemplateCountAggregateOutputType | null
    _avg: MenuTemplateAvgAggregateOutputType | null
    _sum: MenuTemplateSumAggregateOutputType | null
    _min: MenuTemplateMinAggregateOutputType | null
    _max: MenuTemplateMaxAggregateOutputType | null
  }

  type GetMenuTemplateGroupByPayload<T extends MenuTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MenuTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MenuTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brandId?: boolean
    createdAt?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    items?: boolean | MenuTemplate$itemsArgs<ExtArgs>
    Menu?: boolean | MenuTemplate$MenuArgs<ExtArgs>
    Addon?: boolean | MenuTemplate$AddonArgs<ExtArgs>
    AddonCategory?: boolean | MenuTemplate$AddonCategoryArgs<ExtArgs>
    _count?: boolean | MenuTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuTemplate"]>

  export type MenuTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brandId?: boolean
    createdAt?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuTemplate"]>

  export type MenuTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brandId?: boolean
    createdAt?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuTemplate"]>

  export type MenuTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    brandId?: boolean
    createdAt?: boolean
  }

  export type MenuTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "brandId" | "createdAt", ExtArgs["result"]["menuTemplate"]>
  export type MenuTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    items?: boolean | MenuTemplate$itemsArgs<ExtArgs>
    Menu?: boolean | MenuTemplate$MenuArgs<ExtArgs>
    Addon?: boolean | MenuTemplate$AddonArgs<ExtArgs>
    AddonCategory?: boolean | MenuTemplate$AddonCategoryArgs<ExtArgs>
    _count?: boolean | MenuTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type MenuTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $MenuTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuTemplate"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs>
      items: Prisma.$TemplateItemPayload<ExtArgs>[]
      Menu: Prisma.$MenuPayload<ExtArgs>[]
      Addon: Prisma.$AddonPayload<ExtArgs>[]
      AddonCategory: Prisma.$AddonCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      brandId: number
      createdAt: Date
    }, ExtArgs["result"]["menuTemplate"]>
    composites: {}
  }

  type MenuTemplateGetPayload<S extends boolean | null | undefined | MenuTemplateDefaultArgs> = $Result.GetResult<Prisma.$MenuTemplatePayload, S>

  type MenuTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuTemplateCountAggregateInputType | true
    }

  export interface MenuTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuTemplate'], meta: { name: 'MenuTemplate' } }
    /**
     * Find zero or one MenuTemplate that matches the filter.
     * @param {MenuTemplateFindUniqueArgs} args - Arguments to find a MenuTemplate
     * @example
     * // Get one MenuTemplate
     * const menuTemplate = await prisma.menuTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuTemplateFindUniqueArgs>(args: SelectSubset<T, MenuTemplateFindUniqueArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuTemplateFindUniqueOrThrowArgs} args - Arguments to find a MenuTemplate
     * @example
     * // Get one MenuTemplate
     * const menuTemplate = await prisma.menuTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateFindFirstArgs} args - Arguments to find a MenuTemplate
     * @example
     * // Get one MenuTemplate
     * const menuTemplate = await prisma.menuTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuTemplateFindFirstArgs>(args?: SelectSubset<T, MenuTemplateFindFirstArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateFindFirstOrThrowArgs} args - Arguments to find a MenuTemplate
     * @example
     * // Get one MenuTemplate
     * const menuTemplate = await prisma.menuTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuTemplates
     * const menuTemplates = await prisma.menuTemplate.findMany()
     * 
     * // Get first 10 MenuTemplates
     * const menuTemplates = await prisma.menuTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuTemplateWithIdOnly = await prisma.menuTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuTemplateFindManyArgs>(args?: SelectSubset<T, MenuTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuTemplate.
     * @param {MenuTemplateCreateArgs} args - Arguments to create a MenuTemplate.
     * @example
     * // Create one MenuTemplate
     * const MenuTemplate = await prisma.menuTemplate.create({
     *   data: {
     *     // ... data to create a MenuTemplate
     *   }
     * })
     * 
     */
    create<T extends MenuTemplateCreateArgs>(args: SelectSubset<T, MenuTemplateCreateArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuTemplates.
     * @param {MenuTemplateCreateManyArgs} args - Arguments to create many MenuTemplates.
     * @example
     * // Create many MenuTemplates
     * const menuTemplate = await prisma.menuTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuTemplateCreateManyArgs>(args?: SelectSubset<T, MenuTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuTemplates and returns the data saved in the database.
     * @param {MenuTemplateCreateManyAndReturnArgs} args - Arguments to create many MenuTemplates.
     * @example
     * // Create many MenuTemplates
     * const menuTemplate = await prisma.menuTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuTemplates and only return the `id`
     * const menuTemplateWithIdOnly = await prisma.menuTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuTemplate.
     * @param {MenuTemplateDeleteArgs} args - Arguments to delete one MenuTemplate.
     * @example
     * // Delete one MenuTemplate
     * const MenuTemplate = await prisma.menuTemplate.delete({
     *   where: {
     *     // ... filter to delete one MenuTemplate
     *   }
     * })
     * 
     */
    delete<T extends MenuTemplateDeleteArgs>(args: SelectSubset<T, MenuTemplateDeleteArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuTemplate.
     * @param {MenuTemplateUpdateArgs} args - Arguments to update one MenuTemplate.
     * @example
     * // Update one MenuTemplate
     * const menuTemplate = await prisma.menuTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuTemplateUpdateArgs>(args: SelectSubset<T, MenuTemplateUpdateArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuTemplates.
     * @param {MenuTemplateDeleteManyArgs} args - Arguments to filter MenuTemplates to delete.
     * @example
     * // Delete a few MenuTemplates
     * const { count } = await prisma.menuTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuTemplateDeleteManyArgs>(args?: SelectSubset<T, MenuTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuTemplates
     * const menuTemplate = await prisma.menuTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuTemplateUpdateManyArgs>(args: SelectSubset<T, MenuTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuTemplates and returns the data updated in the database.
     * @param {MenuTemplateUpdateManyAndReturnArgs} args - Arguments to update many MenuTemplates.
     * @example
     * // Update many MenuTemplates
     * const menuTemplate = await prisma.menuTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuTemplates and only return the `id`
     * const menuTemplateWithIdOnly = await prisma.menuTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuTemplate.
     * @param {MenuTemplateUpsertArgs} args - Arguments to update or create a MenuTemplate.
     * @example
     * // Update or create a MenuTemplate
     * const menuTemplate = await prisma.menuTemplate.upsert({
     *   create: {
     *     // ... data to create a MenuTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MenuTemplateUpsertArgs>(args: SelectSubset<T, MenuTemplateUpsertArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateCountArgs} args - Arguments to filter MenuTemplates to count.
     * @example
     * // Count the number of MenuTemplates
     * const count = await prisma.menuTemplate.count({
     *   where: {
     *     // ... the filter for the MenuTemplates we want to count
     *   }
     * })
    **/
    count<T extends MenuTemplateCountArgs>(
      args?: Subset<T, MenuTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuTemplateAggregateArgs>(args: Subset<T, MenuTemplateAggregateArgs>): Prisma.PrismaPromise<GetMenuTemplateAggregateType<T>>

    /**
     * Group by MenuTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MenuTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuTemplate model
   */
  readonly fields: MenuTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends MenuTemplate$itemsArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplate$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Menu<T extends MenuTemplate$MenuArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplate$MenuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Addon<T extends MenuTemplate$AddonArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplate$AddonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AddonCategory<T extends MenuTemplate$AddonCategoryArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplate$AddonCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuTemplate model
   */
  interface MenuTemplateFieldRefs {
    readonly id: FieldRef<"MenuTemplate", 'Int'>
    readonly name: FieldRef<"MenuTemplate", 'String'>
    readonly brandId: FieldRef<"MenuTemplate", 'Int'>
    readonly createdAt: FieldRef<"MenuTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuTemplate findUnique
   */
  export type MenuTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MenuTemplate to fetch.
     */
    where: MenuTemplateWhereUniqueInput
  }

  /**
   * MenuTemplate findUniqueOrThrow
   */
  export type MenuTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MenuTemplate to fetch.
     */
    where: MenuTemplateWhereUniqueInput
  }

  /**
   * MenuTemplate findFirst
   */
  export type MenuTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MenuTemplate to fetch.
     */
    where?: MenuTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuTemplates to fetch.
     */
    orderBy?: MenuTemplateOrderByWithRelationInput | MenuTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuTemplates.
     */
    cursor?: MenuTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuTemplates.
     */
    distinct?: MenuTemplateScalarFieldEnum | MenuTemplateScalarFieldEnum[]
  }

  /**
   * MenuTemplate findFirstOrThrow
   */
  export type MenuTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MenuTemplate to fetch.
     */
    where?: MenuTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuTemplates to fetch.
     */
    orderBy?: MenuTemplateOrderByWithRelationInput | MenuTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuTemplates.
     */
    cursor?: MenuTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuTemplates.
     */
    distinct?: MenuTemplateScalarFieldEnum | MenuTemplateScalarFieldEnum[]
  }

  /**
   * MenuTemplate findMany
   */
  export type MenuTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MenuTemplates to fetch.
     */
    where?: MenuTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuTemplates to fetch.
     */
    orderBy?: MenuTemplateOrderByWithRelationInput | MenuTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuTemplates.
     */
    cursor?: MenuTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuTemplates.
     */
    skip?: number
    distinct?: MenuTemplateScalarFieldEnum | MenuTemplateScalarFieldEnum[]
  }

  /**
   * MenuTemplate create
   */
  export type MenuTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuTemplate.
     */
    data: XOR<MenuTemplateCreateInput, MenuTemplateUncheckedCreateInput>
  }

  /**
   * MenuTemplate createMany
   */
  export type MenuTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuTemplates.
     */
    data: MenuTemplateCreateManyInput | MenuTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuTemplate createManyAndReturn
   */
  export type MenuTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many MenuTemplates.
     */
    data: MenuTemplateCreateManyInput | MenuTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuTemplate update
   */
  export type MenuTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuTemplate.
     */
    data: XOR<MenuTemplateUpdateInput, MenuTemplateUncheckedUpdateInput>
    /**
     * Choose, which MenuTemplate to update.
     */
    where: MenuTemplateWhereUniqueInput
  }

  /**
   * MenuTemplate updateMany
   */
  export type MenuTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuTemplates.
     */
    data: XOR<MenuTemplateUpdateManyMutationInput, MenuTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MenuTemplates to update
     */
    where?: MenuTemplateWhereInput
    /**
     * Limit how many MenuTemplates to update.
     */
    limit?: number
  }

  /**
   * MenuTemplate updateManyAndReturn
   */
  export type MenuTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * The data used to update MenuTemplates.
     */
    data: XOR<MenuTemplateUpdateManyMutationInput, MenuTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MenuTemplates to update
     */
    where?: MenuTemplateWhereInput
    /**
     * Limit how many MenuTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuTemplate upsert
   */
  export type MenuTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuTemplate to update in case it exists.
     */
    where: MenuTemplateWhereUniqueInput
    /**
     * In case the MenuTemplate found by the `where` argument doesn't exist, create a new MenuTemplate with this data.
     */
    create: XOR<MenuTemplateCreateInput, MenuTemplateUncheckedCreateInput>
    /**
     * In case the MenuTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuTemplateUpdateInput, MenuTemplateUncheckedUpdateInput>
  }

  /**
   * MenuTemplate delete
   */
  export type MenuTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
    /**
     * Filter which MenuTemplate to delete.
     */
    where: MenuTemplateWhereUniqueInput
  }

  /**
   * MenuTemplate deleteMany
   */
  export type MenuTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuTemplates to delete
     */
    where?: MenuTemplateWhereInput
    /**
     * Limit how many MenuTemplates to delete.
     */
    limit?: number
  }

  /**
   * MenuTemplate.items
   */
  export type MenuTemplate$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    where?: TemplateItemWhereInput
    orderBy?: TemplateItemOrderByWithRelationInput | TemplateItemOrderByWithRelationInput[]
    cursor?: TemplateItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemScalarFieldEnum | TemplateItemScalarFieldEnum[]
  }

  /**
   * MenuTemplate.Menu
   */
  export type MenuTemplate$MenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * MenuTemplate.Addon
   */
  export type MenuTemplate$AddonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    where?: AddonWhereInput
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    cursor?: AddonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * MenuTemplate.AddonCategory
   */
  export type MenuTemplate$AddonCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    where?: AddonCategoryWhereInput
    orderBy?: AddonCategoryOrderByWithRelationInput | AddonCategoryOrderByWithRelationInput[]
    cursor?: AddonCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddonCategoryScalarFieldEnum | AddonCategoryScalarFieldEnum[]
  }

  /**
   * MenuTemplate without action
   */
  export type MenuTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuTemplate
     */
    select?: MenuTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuTemplate
     */
    omit?: MenuTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuTemplateInclude<ExtArgs> | null
  }


  /**
   * Model TemplateItem
   */

  export type AggregateTemplateItem = {
    _count: TemplateItemCountAggregateOutputType | null
    _avg: TemplateItemAvgAggregateOutputType | null
    _sum: TemplateItemSumAggregateOutputType | null
    _min: TemplateItemMinAggregateOutputType | null
    _max: TemplateItemMaxAggregateOutputType | null
  }

  export type TemplateItemAvgAggregateOutputType = {
    id: number | null
    templateId: number | null
  }

  export type TemplateItemSumAggregateOutputType = {
    id: number | null
    templateId: number | null
  }

  export type TemplateItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    templateId: number | null
  }

  export type TemplateItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    templateId: number | null
  }

  export type TemplateItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    category: number
    templateId: number
    _all: number
  }


  export type TemplateItemAvgAggregateInputType = {
    id?: true
    templateId?: true
  }

  export type TemplateItemSumAggregateInputType = {
    id?: true
    templateId?: true
  }

  export type TemplateItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    templateId?: true
  }

  export type TemplateItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    templateId?: true
  }

  export type TemplateItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    templateId?: true
    _all?: true
  }

  export type TemplateItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItem to aggregate.
     */
    where?: TemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItems to fetch.
     */
    orderBy?: TemplateItemOrderByWithRelationInput | TemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateItems
    **/
    _count?: true | TemplateItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateItemMaxAggregateInputType
  }

  export type GetTemplateItemAggregateType<T extends TemplateItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateItem[P]>
      : GetScalarType<T[P], AggregateTemplateItem[P]>
  }




  export type TemplateItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemWhereInput
    orderBy?: TemplateItemOrderByWithAggregationInput | TemplateItemOrderByWithAggregationInput[]
    by: TemplateItemScalarFieldEnum[] | TemplateItemScalarFieldEnum
    having?: TemplateItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateItemCountAggregateInputType | true
    _avg?: TemplateItemAvgAggregateInputType
    _sum?: TemplateItemSumAggregateInputType
    _min?: TemplateItemMinAggregateInputType
    _max?: TemplateItemMaxAggregateInputType
  }

  export type TemplateItemGroupByOutputType = {
    id: number
    name: string
    description: string | null
    imageUrl: string | null
    category: string | null
    templateId: number
    _count: TemplateItemCountAggregateOutputType | null
    _avg: TemplateItemAvgAggregateOutputType | null
    _sum: TemplateItemSumAggregateOutputType | null
    _min: TemplateItemMinAggregateOutputType | null
    _max: TemplateItemMaxAggregateOutputType | null
  }

  type GetTemplateItemGroupByPayload<T extends TemplateItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateItemGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateItemGroupByOutputType[P]>
        }
      >
    >


  export type TemplateItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    variants?: boolean | TemplateItem$variantsArgs<ExtArgs>
    MenuItemOverride?: boolean | TemplateItem$MenuItemOverrideArgs<ExtArgs>
    Tag?: boolean | TemplateItem$TagArgs<ExtArgs>
    OrderItem?: boolean | TemplateItem$OrderItemArgs<ExtArgs>
    TemplateItemTag?: boolean | TemplateItem$TemplateItemTagArgs<ExtArgs>
    TemplateItemAddon?: boolean | TemplateItem$TemplateItemAddonArgs<ExtArgs>
    _count?: boolean | TemplateItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItem"]>

  export type TemplateItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItem"]>

  export type TemplateItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItem"]>

  export type TemplateItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    templateId?: boolean
  }

  export type TemplateItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "category" | "templateId", ExtArgs["result"]["templateItem"]>
  export type TemplateItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    variants?: boolean | TemplateItem$variantsArgs<ExtArgs>
    MenuItemOverride?: boolean | TemplateItem$MenuItemOverrideArgs<ExtArgs>
    Tag?: boolean | TemplateItem$TagArgs<ExtArgs>
    OrderItem?: boolean | TemplateItem$OrderItemArgs<ExtArgs>
    TemplateItemTag?: boolean | TemplateItem$TemplateItemTagArgs<ExtArgs>
    TemplateItemAddon?: boolean | TemplateItem$TemplateItemAddonArgs<ExtArgs>
    _count?: boolean | TemplateItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TemplateItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }
  export type TemplateItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }

  export type $TemplateItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateItem"
    objects: {
      template: Prisma.$MenuTemplatePayload<ExtArgs>
      variants: Prisma.$TemplateItemVariantPayload<ExtArgs>[]
      MenuItemOverride: Prisma.$MenuItemOverridePayload<ExtArgs>[]
      Tag: Prisma.$TagPayload<ExtArgs>[]
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      TemplateItemTag: Prisma.$TemplateItemTagPayload<ExtArgs>[]
      TemplateItemAddon: Prisma.$TemplateItemAddonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      imageUrl: string | null
      category: string | null
      templateId: number
    }, ExtArgs["result"]["templateItem"]>
    composites: {}
  }

  type TemplateItemGetPayload<S extends boolean | null | undefined | TemplateItemDefaultArgs> = $Result.GetResult<Prisma.$TemplateItemPayload, S>

  type TemplateItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateItemCountAggregateInputType | true
    }

  export interface TemplateItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateItem'], meta: { name: 'TemplateItem' } }
    /**
     * Find zero or one TemplateItem that matches the filter.
     * @param {TemplateItemFindUniqueArgs} args - Arguments to find a TemplateItem
     * @example
     * // Get one TemplateItem
     * const templateItem = await prisma.templateItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateItemFindUniqueArgs>(args: SelectSubset<T, TemplateItemFindUniqueArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateItemFindUniqueOrThrowArgs} args - Arguments to find a TemplateItem
     * @example
     * // Get one TemplateItem
     * const templateItem = await prisma.templateItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemFindFirstArgs} args - Arguments to find a TemplateItem
     * @example
     * // Get one TemplateItem
     * const templateItem = await prisma.templateItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateItemFindFirstArgs>(args?: SelectSubset<T, TemplateItemFindFirstArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemFindFirstOrThrowArgs} args - Arguments to find a TemplateItem
     * @example
     * // Get one TemplateItem
     * const templateItem = await prisma.templateItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateItems
     * const templateItems = await prisma.templateItem.findMany()
     * 
     * // Get first 10 TemplateItems
     * const templateItems = await prisma.templateItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateItemWithIdOnly = await prisma.templateItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateItemFindManyArgs>(args?: SelectSubset<T, TemplateItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateItem.
     * @param {TemplateItemCreateArgs} args - Arguments to create a TemplateItem.
     * @example
     * // Create one TemplateItem
     * const TemplateItem = await prisma.templateItem.create({
     *   data: {
     *     // ... data to create a TemplateItem
     *   }
     * })
     * 
     */
    create<T extends TemplateItemCreateArgs>(args: SelectSubset<T, TemplateItemCreateArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateItems.
     * @param {TemplateItemCreateManyArgs} args - Arguments to create many TemplateItems.
     * @example
     * // Create many TemplateItems
     * const templateItem = await prisma.templateItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateItemCreateManyArgs>(args?: SelectSubset<T, TemplateItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateItems and returns the data saved in the database.
     * @param {TemplateItemCreateManyAndReturnArgs} args - Arguments to create many TemplateItems.
     * @example
     * // Create many TemplateItems
     * const templateItem = await prisma.templateItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateItems and only return the `id`
     * const templateItemWithIdOnly = await prisma.templateItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateItem.
     * @param {TemplateItemDeleteArgs} args - Arguments to delete one TemplateItem.
     * @example
     * // Delete one TemplateItem
     * const TemplateItem = await prisma.templateItem.delete({
     *   where: {
     *     // ... filter to delete one TemplateItem
     *   }
     * })
     * 
     */
    delete<T extends TemplateItemDeleteArgs>(args: SelectSubset<T, TemplateItemDeleteArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateItem.
     * @param {TemplateItemUpdateArgs} args - Arguments to update one TemplateItem.
     * @example
     * // Update one TemplateItem
     * const templateItem = await prisma.templateItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateItemUpdateArgs>(args: SelectSubset<T, TemplateItemUpdateArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateItems.
     * @param {TemplateItemDeleteManyArgs} args - Arguments to filter TemplateItems to delete.
     * @example
     * // Delete a few TemplateItems
     * const { count } = await prisma.templateItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateItemDeleteManyArgs>(args?: SelectSubset<T, TemplateItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateItems
     * const templateItem = await prisma.templateItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateItemUpdateManyArgs>(args: SelectSubset<T, TemplateItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItems and returns the data updated in the database.
     * @param {TemplateItemUpdateManyAndReturnArgs} args - Arguments to update many TemplateItems.
     * @example
     * // Update many TemplateItems
     * const templateItem = await prisma.templateItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateItems and only return the `id`
     * const templateItemWithIdOnly = await prisma.templateItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateItem.
     * @param {TemplateItemUpsertArgs} args - Arguments to update or create a TemplateItem.
     * @example
     * // Update or create a TemplateItem
     * const templateItem = await prisma.templateItem.upsert({
     *   create: {
     *     // ... data to create a TemplateItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateItem we want to update
     *   }
     * })
     */
    upsert<T extends TemplateItemUpsertArgs>(args: SelectSubset<T, TemplateItemUpsertArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemCountArgs} args - Arguments to filter TemplateItems to count.
     * @example
     * // Count the number of TemplateItems
     * const count = await prisma.templateItem.count({
     *   where: {
     *     // ... the filter for the TemplateItems we want to count
     *   }
     * })
    **/
    count<T extends TemplateItemCountArgs>(
      args?: Subset<T, TemplateItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateItemAggregateArgs>(args: Subset<T, TemplateItemAggregateArgs>): Prisma.PrismaPromise<GetTemplateItemAggregateType<T>>

    /**
     * Group by TemplateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateItemGroupByArgs['orderBy'] }
        : { orderBy?: TemplateItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateItem model
   */
  readonly fields: TemplateItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends MenuTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplateDefaultArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variants<T extends TemplateItem$variantsArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItem$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MenuItemOverride<T extends TemplateItem$MenuItemOverrideArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItem$MenuItemOverrideArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tag<T extends TemplateItem$TagArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItem$TagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderItem<T extends TemplateItem$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItem$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TemplateItemTag<T extends TemplateItem$TemplateItemTagArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItem$TemplateItemTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TemplateItemAddon<T extends TemplateItem$TemplateItemAddonArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItem$TemplateItemAddonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateItem model
   */
  interface TemplateItemFieldRefs {
    readonly id: FieldRef<"TemplateItem", 'Int'>
    readonly name: FieldRef<"TemplateItem", 'String'>
    readonly description: FieldRef<"TemplateItem", 'String'>
    readonly imageUrl: FieldRef<"TemplateItem", 'String'>
    readonly category: FieldRef<"TemplateItem", 'String'>
    readonly templateId: FieldRef<"TemplateItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateItem findUnique
   */
  export type TemplateItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItem to fetch.
     */
    where: TemplateItemWhereUniqueInput
  }

  /**
   * TemplateItem findUniqueOrThrow
   */
  export type TemplateItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItem to fetch.
     */
    where: TemplateItemWhereUniqueInput
  }

  /**
   * TemplateItem findFirst
   */
  export type TemplateItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItem to fetch.
     */
    where?: TemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItems to fetch.
     */
    orderBy?: TemplateItemOrderByWithRelationInput | TemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItems.
     */
    cursor?: TemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItems.
     */
    distinct?: TemplateItemScalarFieldEnum | TemplateItemScalarFieldEnum[]
  }

  /**
   * TemplateItem findFirstOrThrow
   */
  export type TemplateItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItem to fetch.
     */
    where?: TemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItems to fetch.
     */
    orderBy?: TemplateItemOrderByWithRelationInput | TemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItems.
     */
    cursor?: TemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItems.
     */
    distinct?: TemplateItemScalarFieldEnum | TemplateItemScalarFieldEnum[]
  }

  /**
   * TemplateItem findMany
   */
  export type TemplateItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItems to fetch.
     */
    where?: TemplateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItems to fetch.
     */
    orderBy?: TemplateItemOrderByWithRelationInput | TemplateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateItems.
     */
    cursor?: TemplateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItems.
     */
    skip?: number
    distinct?: TemplateItemScalarFieldEnum | TemplateItemScalarFieldEnum[]
  }

  /**
   * TemplateItem create
   */
  export type TemplateItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateItem.
     */
    data: XOR<TemplateItemCreateInput, TemplateItemUncheckedCreateInput>
  }

  /**
   * TemplateItem createMany
   */
  export type TemplateItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateItems.
     */
    data: TemplateItemCreateManyInput | TemplateItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateItem createManyAndReturn
   */
  export type TemplateItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateItems.
     */
    data: TemplateItemCreateManyInput | TemplateItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItem update
   */
  export type TemplateItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateItem.
     */
    data: XOR<TemplateItemUpdateInput, TemplateItemUncheckedUpdateInput>
    /**
     * Choose, which TemplateItem to update.
     */
    where: TemplateItemWhereUniqueInput
  }

  /**
   * TemplateItem updateMany
   */
  export type TemplateItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateItems.
     */
    data: XOR<TemplateItemUpdateManyMutationInput, TemplateItemUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItems to update
     */
    where?: TemplateItemWhereInput
    /**
     * Limit how many TemplateItems to update.
     */
    limit?: number
  }

  /**
   * TemplateItem updateManyAndReturn
   */
  export type TemplateItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * The data used to update TemplateItems.
     */
    data: XOR<TemplateItemUpdateManyMutationInput, TemplateItemUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItems to update
     */
    where?: TemplateItemWhereInput
    /**
     * Limit how many TemplateItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItem upsert
   */
  export type TemplateItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateItem to update in case it exists.
     */
    where: TemplateItemWhereUniqueInput
    /**
     * In case the TemplateItem found by the `where` argument doesn't exist, create a new TemplateItem with this data.
     */
    create: XOR<TemplateItemCreateInput, TemplateItemUncheckedCreateInput>
    /**
     * In case the TemplateItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateItemUpdateInput, TemplateItemUncheckedUpdateInput>
  }

  /**
   * TemplateItem delete
   */
  export type TemplateItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    /**
     * Filter which TemplateItem to delete.
     */
    where: TemplateItemWhereUniqueInput
  }

  /**
   * TemplateItem deleteMany
   */
  export type TemplateItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItems to delete
     */
    where?: TemplateItemWhereInput
    /**
     * Limit how many TemplateItems to delete.
     */
    limit?: number
  }

  /**
   * TemplateItem.variants
   */
  export type TemplateItem$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    where?: TemplateItemVariantWhereInput
    orderBy?: TemplateItemVariantOrderByWithRelationInput | TemplateItemVariantOrderByWithRelationInput[]
    cursor?: TemplateItemVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemVariantScalarFieldEnum | TemplateItemVariantScalarFieldEnum[]
  }

  /**
   * TemplateItem.MenuItemOverride
   */
  export type TemplateItem$MenuItemOverrideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    where?: MenuItemOverrideWhereInput
    orderBy?: MenuItemOverrideOrderByWithRelationInput | MenuItemOverrideOrderByWithRelationInput[]
    cursor?: MenuItemOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemOverrideScalarFieldEnum | MenuItemOverrideScalarFieldEnum[]
  }

  /**
   * TemplateItem.Tag
   */
  export type TemplateItem$TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * TemplateItem.OrderItem
   */
  export type TemplateItem$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * TemplateItem.TemplateItemTag
   */
  export type TemplateItem$TemplateItemTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    where?: TemplateItemTagWhereInput
    orderBy?: TemplateItemTagOrderByWithRelationInput | TemplateItemTagOrderByWithRelationInput[]
    cursor?: TemplateItemTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemTagScalarFieldEnum | TemplateItemTagScalarFieldEnum[]
  }

  /**
   * TemplateItem.TemplateItemAddon
   */
  export type TemplateItem$TemplateItemAddonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    where?: TemplateItemAddonWhereInput
    orderBy?: TemplateItemAddonOrderByWithRelationInput | TemplateItemAddonOrderByWithRelationInput[]
    cursor?: TemplateItemAddonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemAddonScalarFieldEnum | TemplateItemAddonScalarFieldEnum[]
  }

  /**
   * TemplateItem without action
   */
  export type TemplateItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
  }


  /**
   * Model TemplateItemVariant
   */

  export type AggregateTemplateItemVariant = {
    _count: TemplateItemVariantCountAggregateOutputType | null
    _avg: TemplateItemVariantAvgAggregateOutputType | null
    _sum: TemplateItemVariantSumAggregateOutputType | null
    _min: TemplateItemVariantMinAggregateOutputType | null
    _max: TemplateItemVariantMaxAggregateOutputType | null
  }

  export type TemplateItemVariantAvgAggregateOutputType = {
    id: number | null
    price: number | null
    itemId: number | null
  }

  export type TemplateItemVariantSumAggregateOutputType = {
    id: number | null
    price: number | null
    itemId: number | null
  }

  export type TemplateItemVariantMinAggregateOutputType = {
    id: number | null
    label: string | null
    price: number | null
    itemId: number | null
  }

  export type TemplateItemVariantMaxAggregateOutputType = {
    id: number | null
    label: string | null
    price: number | null
    itemId: number | null
  }

  export type TemplateItemVariantCountAggregateOutputType = {
    id: number
    label: number
    price: number
    itemId: number
    _all: number
  }


  export type TemplateItemVariantAvgAggregateInputType = {
    id?: true
    price?: true
    itemId?: true
  }

  export type TemplateItemVariantSumAggregateInputType = {
    id?: true
    price?: true
    itemId?: true
  }

  export type TemplateItemVariantMinAggregateInputType = {
    id?: true
    label?: true
    price?: true
    itemId?: true
  }

  export type TemplateItemVariantMaxAggregateInputType = {
    id?: true
    label?: true
    price?: true
    itemId?: true
  }

  export type TemplateItemVariantCountAggregateInputType = {
    id?: true
    label?: true
    price?: true
    itemId?: true
    _all?: true
  }

  export type TemplateItemVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItemVariant to aggregate.
     */
    where?: TemplateItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemVariants to fetch.
     */
    orderBy?: TemplateItemVariantOrderByWithRelationInput | TemplateItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateItemVariants
    **/
    _count?: true | TemplateItemVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateItemVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateItemVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateItemVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateItemVariantMaxAggregateInputType
  }

  export type GetTemplateItemVariantAggregateType<T extends TemplateItemVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateItemVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateItemVariant[P]>
      : GetScalarType<T[P], AggregateTemplateItemVariant[P]>
  }




  export type TemplateItemVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemVariantWhereInput
    orderBy?: TemplateItemVariantOrderByWithAggregationInput | TemplateItemVariantOrderByWithAggregationInput[]
    by: TemplateItemVariantScalarFieldEnum[] | TemplateItemVariantScalarFieldEnum
    having?: TemplateItemVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateItemVariantCountAggregateInputType | true
    _avg?: TemplateItemVariantAvgAggregateInputType
    _sum?: TemplateItemVariantSumAggregateInputType
    _min?: TemplateItemVariantMinAggregateInputType
    _max?: TemplateItemVariantMaxAggregateInputType
  }

  export type TemplateItemVariantGroupByOutputType = {
    id: number
    label: string
    price: number
    itemId: number
    _count: TemplateItemVariantCountAggregateOutputType | null
    _avg: TemplateItemVariantAvgAggregateOutputType | null
    _sum: TemplateItemVariantSumAggregateOutputType | null
    _min: TemplateItemVariantMinAggregateOutputType | null
    _max: TemplateItemVariantMaxAggregateOutputType | null
  }

  type GetTemplateItemVariantGroupByPayload<T extends TemplateItemVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateItemVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateItemVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateItemVariantGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateItemVariantGroupByOutputType[P]>
        }
      >
    >


  export type TemplateItemVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    price?: boolean
    itemId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    OrderItem?: boolean | TemplateItemVariant$OrderItemArgs<ExtArgs>
    _count?: boolean | TemplateItemVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemVariant"]>

  export type TemplateItemVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    price?: boolean
    itemId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemVariant"]>

  export type TemplateItemVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    price?: boolean
    itemId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemVariant"]>

  export type TemplateItemVariantSelectScalar = {
    id?: boolean
    label?: boolean
    price?: boolean
    itemId?: boolean
  }

  export type TemplateItemVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "price" | "itemId", ExtArgs["result"]["templateItemVariant"]>
  export type TemplateItemVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    OrderItem?: boolean | TemplateItemVariant$OrderItemArgs<ExtArgs>
    _count?: boolean | TemplateItemVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TemplateItemVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }
  export type TemplateItemVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }

  export type $TemplateItemVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateItemVariant"
    objects: {
      templateItem: Prisma.$TemplateItemPayload<ExtArgs>
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      price: number
      itemId: number
    }, ExtArgs["result"]["templateItemVariant"]>
    composites: {}
  }

  type TemplateItemVariantGetPayload<S extends boolean | null | undefined | TemplateItemVariantDefaultArgs> = $Result.GetResult<Prisma.$TemplateItemVariantPayload, S>

  type TemplateItemVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateItemVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateItemVariantCountAggregateInputType | true
    }

  export interface TemplateItemVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateItemVariant'], meta: { name: 'TemplateItemVariant' } }
    /**
     * Find zero or one TemplateItemVariant that matches the filter.
     * @param {TemplateItemVariantFindUniqueArgs} args - Arguments to find a TemplateItemVariant
     * @example
     * // Get one TemplateItemVariant
     * const templateItemVariant = await prisma.templateItemVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateItemVariantFindUniqueArgs>(args: SelectSubset<T, TemplateItemVariantFindUniqueArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateItemVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateItemVariantFindUniqueOrThrowArgs} args - Arguments to find a TemplateItemVariant
     * @example
     * // Get one TemplateItemVariant
     * const templateItemVariant = await prisma.templateItemVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateItemVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateItemVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItemVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantFindFirstArgs} args - Arguments to find a TemplateItemVariant
     * @example
     * // Get one TemplateItemVariant
     * const templateItemVariant = await prisma.templateItemVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateItemVariantFindFirstArgs>(args?: SelectSubset<T, TemplateItemVariantFindFirstArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItemVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantFindFirstOrThrowArgs} args - Arguments to find a TemplateItemVariant
     * @example
     * // Get one TemplateItemVariant
     * const templateItemVariant = await prisma.templateItemVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateItemVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateItemVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateItemVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateItemVariants
     * const templateItemVariants = await prisma.templateItemVariant.findMany()
     * 
     * // Get first 10 TemplateItemVariants
     * const templateItemVariants = await prisma.templateItemVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateItemVariantWithIdOnly = await prisma.templateItemVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateItemVariantFindManyArgs>(args?: SelectSubset<T, TemplateItemVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateItemVariant.
     * @param {TemplateItemVariantCreateArgs} args - Arguments to create a TemplateItemVariant.
     * @example
     * // Create one TemplateItemVariant
     * const TemplateItemVariant = await prisma.templateItemVariant.create({
     *   data: {
     *     // ... data to create a TemplateItemVariant
     *   }
     * })
     * 
     */
    create<T extends TemplateItemVariantCreateArgs>(args: SelectSubset<T, TemplateItemVariantCreateArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateItemVariants.
     * @param {TemplateItemVariantCreateManyArgs} args - Arguments to create many TemplateItemVariants.
     * @example
     * // Create many TemplateItemVariants
     * const templateItemVariant = await prisma.templateItemVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateItemVariantCreateManyArgs>(args?: SelectSubset<T, TemplateItemVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateItemVariants and returns the data saved in the database.
     * @param {TemplateItemVariantCreateManyAndReturnArgs} args - Arguments to create many TemplateItemVariants.
     * @example
     * // Create many TemplateItemVariants
     * const templateItemVariant = await prisma.templateItemVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateItemVariants and only return the `id`
     * const templateItemVariantWithIdOnly = await prisma.templateItemVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateItemVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateItemVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateItemVariant.
     * @param {TemplateItemVariantDeleteArgs} args - Arguments to delete one TemplateItemVariant.
     * @example
     * // Delete one TemplateItemVariant
     * const TemplateItemVariant = await prisma.templateItemVariant.delete({
     *   where: {
     *     // ... filter to delete one TemplateItemVariant
     *   }
     * })
     * 
     */
    delete<T extends TemplateItemVariantDeleteArgs>(args: SelectSubset<T, TemplateItemVariantDeleteArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateItemVariant.
     * @param {TemplateItemVariantUpdateArgs} args - Arguments to update one TemplateItemVariant.
     * @example
     * // Update one TemplateItemVariant
     * const templateItemVariant = await prisma.templateItemVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateItemVariantUpdateArgs>(args: SelectSubset<T, TemplateItemVariantUpdateArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateItemVariants.
     * @param {TemplateItemVariantDeleteManyArgs} args - Arguments to filter TemplateItemVariants to delete.
     * @example
     * // Delete a few TemplateItemVariants
     * const { count } = await prisma.templateItemVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateItemVariantDeleteManyArgs>(args?: SelectSubset<T, TemplateItemVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItemVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateItemVariants
     * const templateItemVariant = await prisma.templateItemVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateItemVariantUpdateManyArgs>(args: SelectSubset<T, TemplateItemVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItemVariants and returns the data updated in the database.
     * @param {TemplateItemVariantUpdateManyAndReturnArgs} args - Arguments to update many TemplateItemVariants.
     * @example
     * // Update many TemplateItemVariants
     * const templateItemVariant = await prisma.templateItemVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateItemVariants and only return the `id`
     * const templateItemVariantWithIdOnly = await prisma.templateItemVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateItemVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateItemVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateItemVariant.
     * @param {TemplateItemVariantUpsertArgs} args - Arguments to update or create a TemplateItemVariant.
     * @example
     * // Update or create a TemplateItemVariant
     * const templateItemVariant = await prisma.templateItemVariant.upsert({
     *   create: {
     *     // ... data to create a TemplateItemVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateItemVariant we want to update
     *   }
     * })
     */
    upsert<T extends TemplateItemVariantUpsertArgs>(args: SelectSubset<T, TemplateItemVariantUpsertArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateItemVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantCountArgs} args - Arguments to filter TemplateItemVariants to count.
     * @example
     * // Count the number of TemplateItemVariants
     * const count = await prisma.templateItemVariant.count({
     *   where: {
     *     // ... the filter for the TemplateItemVariants we want to count
     *   }
     * })
    **/
    count<T extends TemplateItemVariantCountArgs>(
      args?: Subset<T, TemplateItemVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateItemVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateItemVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateItemVariantAggregateArgs>(args: Subset<T, TemplateItemVariantAggregateArgs>): Prisma.PrismaPromise<GetTemplateItemVariantAggregateType<T>>

    /**
     * Group by TemplateItemVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateItemVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateItemVariantGroupByArgs['orderBy'] }
        : { orderBy?: TemplateItemVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateItemVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateItemVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateItemVariant model
   */
  readonly fields: TemplateItemVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateItemVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateItemVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    templateItem<T extends TemplateItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItemDefaultArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OrderItem<T extends TemplateItemVariant$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItemVariant$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateItemVariant model
   */
  interface TemplateItemVariantFieldRefs {
    readonly id: FieldRef<"TemplateItemVariant", 'Int'>
    readonly label: FieldRef<"TemplateItemVariant", 'String'>
    readonly price: FieldRef<"TemplateItemVariant", 'Float'>
    readonly itemId: FieldRef<"TemplateItemVariant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateItemVariant findUnique
   */
  export type TemplateItemVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemVariant to fetch.
     */
    where: TemplateItemVariantWhereUniqueInput
  }

  /**
   * TemplateItemVariant findUniqueOrThrow
   */
  export type TemplateItemVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemVariant to fetch.
     */
    where: TemplateItemVariantWhereUniqueInput
  }

  /**
   * TemplateItemVariant findFirst
   */
  export type TemplateItemVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemVariant to fetch.
     */
    where?: TemplateItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemVariants to fetch.
     */
    orderBy?: TemplateItemVariantOrderByWithRelationInput | TemplateItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItemVariants.
     */
    cursor?: TemplateItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItemVariants.
     */
    distinct?: TemplateItemVariantScalarFieldEnum | TemplateItemVariantScalarFieldEnum[]
  }

  /**
   * TemplateItemVariant findFirstOrThrow
   */
  export type TemplateItemVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemVariant to fetch.
     */
    where?: TemplateItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemVariants to fetch.
     */
    orderBy?: TemplateItemVariantOrderByWithRelationInput | TemplateItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItemVariants.
     */
    cursor?: TemplateItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItemVariants.
     */
    distinct?: TemplateItemVariantScalarFieldEnum | TemplateItemVariantScalarFieldEnum[]
  }

  /**
   * TemplateItemVariant findMany
   */
  export type TemplateItemVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemVariants to fetch.
     */
    where?: TemplateItemVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemVariants to fetch.
     */
    orderBy?: TemplateItemVariantOrderByWithRelationInput | TemplateItemVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateItemVariants.
     */
    cursor?: TemplateItemVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemVariants.
     */
    skip?: number
    distinct?: TemplateItemVariantScalarFieldEnum | TemplateItemVariantScalarFieldEnum[]
  }

  /**
   * TemplateItemVariant create
   */
  export type TemplateItemVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateItemVariant.
     */
    data: XOR<TemplateItemVariantCreateInput, TemplateItemVariantUncheckedCreateInput>
  }

  /**
   * TemplateItemVariant createMany
   */
  export type TemplateItemVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateItemVariants.
     */
    data: TemplateItemVariantCreateManyInput | TemplateItemVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateItemVariant createManyAndReturn
   */
  export type TemplateItemVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateItemVariants.
     */
    data: TemplateItemVariantCreateManyInput | TemplateItemVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItemVariant update
   */
  export type TemplateItemVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateItemVariant.
     */
    data: XOR<TemplateItemVariantUpdateInput, TemplateItemVariantUncheckedUpdateInput>
    /**
     * Choose, which TemplateItemVariant to update.
     */
    where: TemplateItemVariantWhereUniqueInput
  }

  /**
   * TemplateItemVariant updateMany
   */
  export type TemplateItemVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateItemVariants.
     */
    data: XOR<TemplateItemVariantUpdateManyMutationInput, TemplateItemVariantUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItemVariants to update
     */
    where?: TemplateItemVariantWhereInput
    /**
     * Limit how many TemplateItemVariants to update.
     */
    limit?: number
  }

  /**
   * TemplateItemVariant updateManyAndReturn
   */
  export type TemplateItemVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * The data used to update TemplateItemVariants.
     */
    data: XOR<TemplateItemVariantUpdateManyMutationInput, TemplateItemVariantUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItemVariants to update
     */
    where?: TemplateItemVariantWhereInput
    /**
     * Limit how many TemplateItemVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItemVariant upsert
   */
  export type TemplateItemVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateItemVariant to update in case it exists.
     */
    where: TemplateItemVariantWhereUniqueInput
    /**
     * In case the TemplateItemVariant found by the `where` argument doesn't exist, create a new TemplateItemVariant with this data.
     */
    create: XOR<TemplateItemVariantCreateInput, TemplateItemVariantUncheckedCreateInput>
    /**
     * In case the TemplateItemVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateItemVariantUpdateInput, TemplateItemVariantUncheckedUpdateInput>
  }

  /**
   * TemplateItemVariant delete
   */
  export type TemplateItemVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    /**
     * Filter which TemplateItemVariant to delete.
     */
    where: TemplateItemVariantWhereUniqueInput
  }

  /**
   * TemplateItemVariant deleteMany
   */
  export type TemplateItemVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItemVariants to delete
     */
    where?: TemplateItemVariantWhereInput
    /**
     * Limit how many TemplateItemVariants to delete.
     */
    limit?: number
  }

  /**
   * TemplateItemVariant.OrderItem
   */
  export type TemplateItemVariant$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * TemplateItemVariant without action
   */
  export type TemplateItemVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
    templateId: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    locationId: number | null
    templateId: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    locationId: number | null
    templateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    locationId: number | null
    templateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    locationId: number
    templateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    locationId?: true
    templateId?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    locationId?: true
    templateId?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    locationId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    locationId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    locationId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: number
    locationId: number
    templateId: number
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    overrides?: boolean | Menu$overridesArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    locationId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "templateId" | "createdAt" | "updatedAt", ExtArgs["result"]["menu"]>
  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    overrides?: boolean | Menu$overridesArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }
  export type MenuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      template: Prisma.$MenuTemplatePayload<ExtArgs>
      overrides: Prisma.$MenuItemOverridePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      locationId: number
      templateId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus and returns the data updated in the database.
     * @param {MenuUpdateManyAndReturnArgs} args - Arguments to update many Menus.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends MenuTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplateDefaultArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    overrides<T extends Menu$overridesArgs<ExtArgs> = {}>(args?: Subset<T, Menu$overridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'Int'>
    readonly locationId: FieldRef<"Menu", 'Int'>
    readonly templateId: FieldRef<"Menu", 'Int'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu updateManyAndReturn
   */
  export type MenuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to delete.
     */
    limit?: number
  }

  /**
   * Menu.overrides
   */
  export type Menu$overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    where?: MenuItemOverrideWhereInput
    orderBy?: MenuItemOverrideOrderByWithRelationInput | MenuItemOverrideOrderByWithRelationInput[]
    cursor?: MenuItemOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemOverrideScalarFieldEnum | MenuItemOverrideScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model MenuItemOverride
   */

  export type AggregateMenuItemOverride = {
    _count: MenuItemOverrideCountAggregateOutputType | null
    _avg: MenuItemOverrideAvgAggregateOutputType | null
    _sum: MenuItemOverrideSumAggregateOutputType | null
    _min: MenuItemOverrideMinAggregateOutputType | null
    _max: MenuItemOverrideMaxAggregateOutputType | null
  }

  export type MenuItemOverrideAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    templateItemId: number | null
    priceOverride: number | null
  }

  export type MenuItemOverrideSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    templateItemId: number | null
    priceOverride: number | null
  }

  export type MenuItemOverrideMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    templateItemId: number | null
    isAvailable: boolean | null
    priceOverride: number | null
  }

  export type MenuItemOverrideMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    templateItemId: number | null
    isAvailable: boolean | null
    priceOverride: number | null
  }

  export type MenuItemOverrideCountAggregateOutputType = {
    id: number
    menuId: number
    templateItemId: number
    isAvailable: number
    priceOverride: number
    _all: number
  }


  export type MenuItemOverrideAvgAggregateInputType = {
    id?: true
    menuId?: true
    templateItemId?: true
    priceOverride?: true
  }

  export type MenuItemOverrideSumAggregateInputType = {
    id?: true
    menuId?: true
    templateItemId?: true
    priceOverride?: true
  }

  export type MenuItemOverrideMinAggregateInputType = {
    id?: true
    menuId?: true
    templateItemId?: true
    isAvailable?: true
    priceOverride?: true
  }

  export type MenuItemOverrideMaxAggregateInputType = {
    id?: true
    menuId?: true
    templateItemId?: true
    isAvailable?: true
    priceOverride?: true
  }

  export type MenuItemOverrideCountAggregateInputType = {
    id?: true
    menuId?: true
    templateItemId?: true
    isAvailable?: true
    priceOverride?: true
    _all?: true
  }

  export type MenuItemOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItemOverride to aggregate.
     */
    where?: MenuItemOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemOverrides to fetch.
     */
    orderBy?: MenuItemOverrideOrderByWithRelationInput | MenuItemOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItemOverrides
    **/
    _count?: true | MenuItemOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemOverrideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemOverrideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemOverrideMaxAggregateInputType
  }

  export type GetMenuItemOverrideAggregateType<T extends MenuItemOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItemOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItemOverride[P]>
      : GetScalarType<T[P], AggregateMenuItemOverride[P]>
  }




  export type MenuItemOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemOverrideWhereInput
    orderBy?: MenuItemOverrideOrderByWithAggregationInput | MenuItemOverrideOrderByWithAggregationInput[]
    by: MenuItemOverrideScalarFieldEnum[] | MenuItemOverrideScalarFieldEnum
    having?: MenuItemOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemOverrideCountAggregateInputType | true
    _avg?: MenuItemOverrideAvgAggregateInputType
    _sum?: MenuItemOverrideSumAggregateInputType
    _min?: MenuItemOverrideMinAggregateInputType
    _max?: MenuItemOverrideMaxAggregateInputType
  }

  export type MenuItemOverrideGroupByOutputType = {
    id: number
    menuId: number
    templateItemId: number
    isAvailable: boolean | null
    priceOverride: number | null
    _count: MenuItemOverrideCountAggregateOutputType | null
    _avg: MenuItemOverrideAvgAggregateOutputType | null
    _sum: MenuItemOverrideSumAggregateOutputType | null
    _min: MenuItemOverrideMinAggregateOutputType | null
    _max: MenuItemOverrideMaxAggregateOutputType | null
  }

  type GetMenuItemOverrideGroupByPayload<T extends MenuItemOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemOverrideGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    templateItemId?: boolean
    isAvailable?: boolean
    priceOverride?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItemOverride"]>

  export type MenuItemOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    templateItemId?: boolean
    isAvailable?: boolean
    priceOverride?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItemOverride"]>

  export type MenuItemOverrideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    templateItemId?: boolean
    isAvailable?: boolean
    priceOverride?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItemOverride"]>

  export type MenuItemOverrideSelectScalar = {
    id?: boolean
    menuId?: boolean
    templateItemId?: boolean
    isAvailable?: boolean
    priceOverride?: boolean
  }

  export type MenuItemOverrideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuId" | "templateItemId" | "isAvailable" | "priceOverride", ExtArgs["result"]["menuItemOverride"]>
  export type MenuItemOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }
  export type MenuItemOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }
  export type MenuItemOverrideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
  }

  export type $MenuItemOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItemOverride"
    objects: {
      menu: Prisma.$MenuPayload<ExtArgs>
      templateItem: Prisma.$TemplateItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      menuId: number
      templateItemId: number
      isAvailable: boolean | null
      priceOverride: number | null
    }, ExtArgs["result"]["menuItemOverride"]>
    composites: {}
  }

  type MenuItemOverrideGetPayload<S extends boolean | null | undefined | MenuItemOverrideDefaultArgs> = $Result.GetResult<Prisma.$MenuItemOverridePayload, S>

  type MenuItemOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuItemOverrideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuItemOverrideCountAggregateInputType | true
    }

  export interface MenuItemOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItemOverride'], meta: { name: 'MenuItemOverride' } }
    /**
     * Find zero or one MenuItemOverride that matches the filter.
     * @param {MenuItemOverrideFindUniqueArgs} args - Arguments to find a MenuItemOverride
     * @example
     * // Get one MenuItemOverride
     * const menuItemOverride = await prisma.menuItemOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemOverrideFindUniqueArgs>(args: SelectSubset<T, MenuItemOverrideFindUniqueArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuItemOverride that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuItemOverrideFindUniqueOrThrowArgs} args - Arguments to find a MenuItemOverride
     * @example
     * // Get one MenuItemOverride
     * const menuItemOverride = await prisma.menuItemOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItemOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideFindFirstArgs} args - Arguments to find a MenuItemOverride
     * @example
     * // Get one MenuItemOverride
     * const menuItemOverride = await prisma.menuItemOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemOverrideFindFirstArgs>(args?: SelectSubset<T, MenuItemOverrideFindFirstArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItemOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideFindFirstOrThrowArgs} args - Arguments to find a MenuItemOverride
     * @example
     * // Get one MenuItemOverride
     * const menuItemOverride = await prisma.menuItemOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuItemOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItemOverrides
     * const menuItemOverrides = await prisma.menuItemOverride.findMany()
     * 
     * // Get first 10 MenuItemOverrides
     * const menuItemOverrides = await prisma.menuItemOverride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemOverrideWithIdOnly = await prisma.menuItemOverride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemOverrideFindManyArgs>(args?: SelectSubset<T, MenuItemOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuItemOverride.
     * @param {MenuItemOverrideCreateArgs} args - Arguments to create a MenuItemOverride.
     * @example
     * // Create one MenuItemOverride
     * const MenuItemOverride = await prisma.menuItemOverride.create({
     *   data: {
     *     // ... data to create a MenuItemOverride
     *   }
     * })
     * 
     */
    create<T extends MenuItemOverrideCreateArgs>(args: SelectSubset<T, MenuItemOverrideCreateArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuItemOverrides.
     * @param {MenuItemOverrideCreateManyArgs} args - Arguments to create many MenuItemOverrides.
     * @example
     * // Create many MenuItemOverrides
     * const menuItemOverride = await prisma.menuItemOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemOverrideCreateManyArgs>(args?: SelectSubset<T, MenuItemOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItemOverrides and returns the data saved in the database.
     * @param {MenuItemOverrideCreateManyAndReturnArgs} args - Arguments to create many MenuItemOverrides.
     * @example
     * // Create many MenuItemOverrides
     * const menuItemOverride = await prisma.menuItemOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItemOverrides and only return the `id`
     * const menuItemOverrideWithIdOnly = await prisma.menuItemOverride.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuItemOverride.
     * @param {MenuItemOverrideDeleteArgs} args - Arguments to delete one MenuItemOverride.
     * @example
     * // Delete one MenuItemOverride
     * const MenuItemOverride = await prisma.menuItemOverride.delete({
     *   where: {
     *     // ... filter to delete one MenuItemOverride
     *   }
     * })
     * 
     */
    delete<T extends MenuItemOverrideDeleteArgs>(args: SelectSubset<T, MenuItemOverrideDeleteArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuItemOverride.
     * @param {MenuItemOverrideUpdateArgs} args - Arguments to update one MenuItemOverride.
     * @example
     * // Update one MenuItemOverride
     * const menuItemOverride = await prisma.menuItemOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemOverrideUpdateArgs>(args: SelectSubset<T, MenuItemOverrideUpdateArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuItemOverrides.
     * @param {MenuItemOverrideDeleteManyArgs} args - Arguments to filter MenuItemOverrides to delete.
     * @example
     * // Delete a few MenuItemOverrides
     * const { count } = await prisma.menuItemOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemOverrideDeleteManyArgs>(args?: SelectSubset<T, MenuItemOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItemOverrides
     * const menuItemOverride = await prisma.menuItemOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemOverrideUpdateManyArgs>(args: SelectSubset<T, MenuItemOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemOverrides and returns the data updated in the database.
     * @param {MenuItemOverrideUpdateManyAndReturnArgs} args - Arguments to update many MenuItemOverrides.
     * @example
     * // Update many MenuItemOverrides
     * const menuItemOverride = await prisma.menuItemOverride.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuItemOverrides and only return the `id`
     * const menuItemOverrideWithIdOnly = await prisma.menuItemOverride.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuItemOverrideUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuItemOverrideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuItemOverride.
     * @param {MenuItemOverrideUpsertArgs} args - Arguments to update or create a MenuItemOverride.
     * @example
     * // Update or create a MenuItemOverride
     * const menuItemOverride = await prisma.menuItemOverride.upsert({
     *   create: {
     *     // ... data to create a MenuItemOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItemOverride we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemOverrideUpsertArgs>(args: SelectSubset<T, MenuItemOverrideUpsertArgs<ExtArgs>>): Prisma__MenuItemOverrideClient<$Result.GetResult<Prisma.$MenuItemOverridePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuItemOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideCountArgs} args - Arguments to filter MenuItemOverrides to count.
     * @example
     * // Count the number of MenuItemOverrides
     * const count = await prisma.menuItemOverride.count({
     *   where: {
     *     // ... the filter for the MenuItemOverrides we want to count
     *   }
     * })
    **/
    count<T extends MenuItemOverrideCountArgs>(
      args?: Subset<T, MenuItemOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItemOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemOverrideAggregateArgs>(args: Subset<T, MenuItemOverrideAggregateArgs>): Prisma.PrismaPromise<GetMenuItemOverrideAggregateType<T>>

    /**
     * Group by MenuItemOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemOverrideGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItemOverride model
   */
  readonly fields: MenuItemOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItemOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    templateItem<T extends TemplateItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItemDefaultArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItemOverride model
   */
  interface MenuItemOverrideFieldRefs {
    readonly id: FieldRef<"MenuItemOverride", 'Int'>
    readonly menuId: FieldRef<"MenuItemOverride", 'Int'>
    readonly templateItemId: FieldRef<"MenuItemOverride", 'Int'>
    readonly isAvailable: FieldRef<"MenuItemOverride", 'Boolean'>
    readonly priceOverride: FieldRef<"MenuItemOverride", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MenuItemOverride findUnique
   */
  export type MenuItemOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemOverride to fetch.
     */
    where: MenuItemOverrideWhereUniqueInput
  }

  /**
   * MenuItemOverride findUniqueOrThrow
   */
  export type MenuItemOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemOverride to fetch.
     */
    where: MenuItemOverrideWhereUniqueInput
  }

  /**
   * MenuItemOverride findFirst
   */
  export type MenuItemOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemOverride to fetch.
     */
    where?: MenuItemOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemOverrides to fetch.
     */
    orderBy?: MenuItemOverrideOrderByWithRelationInput | MenuItemOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemOverrides.
     */
    cursor?: MenuItemOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemOverrides.
     */
    distinct?: MenuItemOverrideScalarFieldEnum | MenuItemOverrideScalarFieldEnum[]
  }

  /**
   * MenuItemOverride findFirstOrThrow
   */
  export type MenuItemOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemOverride to fetch.
     */
    where?: MenuItemOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemOverrides to fetch.
     */
    orderBy?: MenuItemOverrideOrderByWithRelationInput | MenuItemOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemOverrides.
     */
    cursor?: MenuItemOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemOverrides.
     */
    distinct?: MenuItemOverrideScalarFieldEnum | MenuItemOverrideScalarFieldEnum[]
  }

  /**
   * MenuItemOverride findMany
   */
  export type MenuItemOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemOverrides to fetch.
     */
    where?: MenuItemOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemOverrides to fetch.
     */
    orderBy?: MenuItemOverrideOrderByWithRelationInput | MenuItemOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItemOverrides.
     */
    cursor?: MenuItemOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemOverrides.
     */
    skip?: number
    distinct?: MenuItemOverrideScalarFieldEnum | MenuItemOverrideScalarFieldEnum[]
  }

  /**
   * MenuItemOverride create
   */
  export type MenuItemOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItemOverride.
     */
    data: XOR<MenuItemOverrideCreateInput, MenuItemOverrideUncheckedCreateInput>
  }

  /**
   * MenuItemOverride createMany
   */
  export type MenuItemOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItemOverrides.
     */
    data: MenuItemOverrideCreateManyInput | MenuItemOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItemOverride createManyAndReturn
   */
  export type MenuItemOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * The data used to create many MenuItemOverrides.
     */
    data: MenuItemOverrideCreateManyInput | MenuItemOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItemOverride update
   */
  export type MenuItemOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItemOverride.
     */
    data: XOR<MenuItemOverrideUpdateInput, MenuItemOverrideUncheckedUpdateInput>
    /**
     * Choose, which MenuItemOverride to update.
     */
    where: MenuItemOverrideWhereUniqueInput
  }

  /**
   * MenuItemOverride updateMany
   */
  export type MenuItemOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItemOverrides.
     */
    data: XOR<MenuItemOverrideUpdateManyMutationInput, MenuItemOverrideUncheckedUpdateManyInput>
    /**
     * Filter which MenuItemOverrides to update
     */
    where?: MenuItemOverrideWhereInput
    /**
     * Limit how many MenuItemOverrides to update.
     */
    limit?: number
  }

  /**
   * MenuItemOverride updateManyAndReturn
   */
  export type MenuItemOverrideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * The data used to update MenuItemOverrides.
     */
    data: XOR<MenuItemOverrideUpdateManyMutationInput, MenuItemOverrideUncheckedUpdateManyInput>
    /**
     * Filter which MenuItemOverrides to update
     */
    where?: MenuItemOverrideWhereInput
    /**
     * Limit how many MenuItemOverrides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItemOverride upsert
   */
  export type MenuItemOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItemOverride to update in case it exists.
     */
    where: MenuItemOverrideWhereUniqueInput
    /**
     * In case the MenuItemOverride found by the `where` argument doesn't exist, create a new MenuItemOverride with this data.
     */
    create: XOR<MenuItemOverrideCreateInput, MenuItemOverrideUncheckedCreateInput>
    /**
     * In case the MenuItemOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemOverrideUpdateInput, MenuItemOverrideUncheckedUpdateInput>
  }

  /**
   * MenuItemOverride delete
   */
  export type MenuItemOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
    /**
     * Filter which MenuItemOverride to delete.
     */
    where: MenuItemOverrideWhereUniqueInput
  }

  /**
   * MenuItemOverride deleteMany
   */
  export type MenuItemOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItemOverrides to delete
     */
    where?: MenuItemOverrideWhereInput
    /**
     * Limit how many MenuItemOverrides to delete.
     */
    limit?: number
  }

  /**
   * MenuItemOverride without action
   */
  export type MenuItemOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemOverride
     */
    select?: MenuItemOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemOverride
     */
    omit?: MenuItemOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemOverrideInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    items?: boolean | Tag$itemsArgs<ExtArgs>
    TemplateItem?: boolean | Tag$TemplateItemArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Tag$itemsArgs<ExtArgs>
    TemplateItem?: boolean | Tag$TemplateItemArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      items: Prisma.$TemplateItemTagPayload<ExtArgs>[]
      TemplateItem: Prisma.$TemplateItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Tag$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TemplateItem<T extends Tag$TemplateItemArgs<ExtArgs> = {}>(args?: Subset<T, Tag$TemplateItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.items
   */
  export type Tag$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    where?: TemplateItemTagWhereInput
    orderBy?: TemplateItemTagOrderByWithRelationInput | TemplateItemTagOrderByWithRelationInput[]
    cursor?: TemplateItemTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemTagScalarFieldEnum | TemplateItemTagScalarFieldEnum[]
  }

  /**
   * Tag.TemplateItem
   */
  export type Tag$TemplateItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItem
     */
    select?: TemplateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItem
     */
    omit?: TemplateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemInclude<ExtArgs> | null
    where?: TemplateItemWhereInput
    orderBy?: TemplateItemOrderByWithRelationInput | TemplateItemOrderByWithRelationInput[]
    cursor?: TemplateItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemScalarFieldEnum | TemplateItemScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TemplateItemTag
   */

  export type AggregateTemplateItemTag = {
    _count: TemplateItemTagCountAggregateOutputType | null
    _avg: TemplateItemTagAvgAggregateOutputType | null
    _sum: TemplateItemTagSumAggregateOutputType | null
    _min: TemplateItemTagMinAggregateOutputType | null
    _max: TemplateItemTagMaxAggregateOutputType | null
  }

  export type TemplateItemTagAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    tagId: number | null
  }

  export type TemplateItemTagSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    tagId: number | null
  }

  export type TemplateItemTagMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    tagId: number | null
  }

  export type TemplateItemTagMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    tagId: number | null
  }

  export type TemplateItemTagCountAggregateOutputType = {
    id: number
    itemId: number
    tagId: number
    _all: number
  }


  export type TemplateItemTagAvgAggregateInputType = {
    id?: true
    itemId?: true
    tagId?: true
  }

  export type TemplateItemTagSumAggregateInputType = {
    id?: true
    itemId?: true
    tagId?: true
  }

  export type TemplateItemTagMinAggregateInputType = {
    id?: true
    itemId?: true
    tagId?: true
  }

  export type TemplateItemTagMaxAggregateInputType = {
    id?: true
    itemId?: true
    tagId?: true
  }

  export type TemplateItemTagCountAggregateInputType = {
    id?: true
    itemId?: true
    tagId?: true
    _all?: true
  }

  export type TemplateItemTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItemTag to aggregate.
     */
    where?: TemplateItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemTags to fetch.
     */
    orderBy?: TemplateItemTagOrderByWithRelationInput | TemplateItemTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateItemTags
    **/
    _count?: true | TemplateItemTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateItemTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateItemTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateItemTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateItemTagMaxAggregateInputType
  }

  export type GetTemplateItemTagAggregateType<T extends TemplateItemTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateItemTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateItemTag[P]>
      : GetScalarType<T[P], AggregateTemplateItemTag[P]>
  }




  export type TemplateItemTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemTagWhereInput
    orderBy?: TemplateItemTagOrderByWithAggregationInput | TemplateItemTagOrderByWithAggregationInput[]
    by: TemplateItemTagScalarFieldEnum[] | TemplateItemTagScalarFieldEnum
    having?: TemplateItemTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateItemTagCountAggregateInputType | true
    _avg?: TemplateItemTagAvgAggregateInputType
    _sum?: TemplateItemTagSumAggregateInputType
    _min?: TemplateItemTagMinAggregateInputType
    _max?: TemplateItemTagMaxAggregateInputType
  }

  export type TemplateItemTagGroupByOutputType = {
    id: number
    itemId: number
    tagId: number
    _count: TemplateItemTagCountAggregateOutputType | null
    _avg: TemplateItemTagAvgAggregateOutputType | null
    _sum: TemplateItemTagSumAggregateOutputType | null
    _min: TemplateItemTagMinAggregateOutputType | null
    _max: TemplateItemTagMaxAggregateOutputType | null
  }

  type GetTemplateItemTagGroupByPayload<T extends TemplateItemTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateItemTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateItemTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateItemTagGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateItemTagGroupByOutputType[P]>
        }
      >
    >


  export type TemplateItemTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    tagId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemTag"]>

  export type TemplateItemTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    tagId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemTag"]>

  export type TemplateItemTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    tagId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemTag"]>

  export type TemplateItemTagSelectScalar = {
    id?: boolean
    itemId?: boolean
    tagId?: boolean
  }

  export type TemplateItemTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "tagId", ExtArgs["result"]["templateItemTag"]>
  export type TemplateItemTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TemplateItemTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TemplateItemTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TemplateItemTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateItemTag"
    objects: {
      templateItem: Prisma.$TemplateItemPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      tagId: number
    }, ExtArgs["result"]["templateItemTag"]>
    composites: {}
  }

  type TemplateItemTagGetPayload<S extends boolean | null | undefined | TemplateItemTagDefaultArgs> = $Result.GetResult<Prisma.$TemplateItemTagPayload, S>

  type TemplateItemTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateItemTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateItemTagCountAggregateInputType | true
    }

  export interface TemplateItemTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateItemTag'], meta: { name: 'TemplateItemTag' } }
    /**
     * Find zero or one TemplateItemTag that matches the filter.
     * @param {TemplateItemTagFindUniqueArgs} args - Arguments to find a TemplateItemTag
     * @example
     * // Get one TemplateItemTag
     * const templateItemTag = await prisma.templateItemTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateItemTagFindUniqueArgs>(args: SelectSubset<T, TemplateItemTagFindUniqueArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateItemTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateItemTagFindUniqueOrThrowArgs} args - Arguments to find a TemplateItemTag
     * @example
     * // Get one TemplateItemTag
     * const templateItemTag = await prisma.templateItemTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateItemTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateItemTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItemTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagFindFirstArgs} args - Arguments to find a TemplateItemTag
     * @example
     * // Get one TemplateItemTag
     * const templateItemTag = await prisma.templateItemTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateItemTagFindFirstArgs>(args?: SelectSubset<T, TemplateItemTagFindFirstArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItemTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagFindFirstOrThrowArgs} args - Arguments to find a TemplateItemTag
     * @example
     * // Get one TemplateItemTag
     * const templateItemTag = await prisma.templateItemTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateItemTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateItemTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateItemTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateItemTags
     * const templateItemTags = await prisma.templateItemTag.findMany()
     * 
     * // Get first 10 TemplateItemTags
     * const templateItemTags = await prisma.templateItemTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateItemTagWithIdOnly = await prisma.templateItemTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateItemTagFindManyArgs>(args?: SelectSubset<T, TemplateItemTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateItemTag.
     * @param {TemplateItemTagCreateArgs} args - Arguments to create a TemplateItemTag.
     * @example
     * // Create one TemplateItemTag
     * const TemplateItemTag = await prisma.templateItemTag.create({
     *   data: {
     *     // ... data to create a TemplateItemTag
     *   }
     * })
     * 
     */
    create<T extends TemplateItemTagCreateArgs>(args: SelectSubset<T, TemplateItemTagCreateArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateItemTags.
     * @param {TemplateItemTagCreateManyArgs} args - Arguments to create many TemplateItemTags.
     * @example
     * // Create many TemplateItemTags
     * const templateItemTag = await prisma.templateItemTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateItemTagCreateManyArgs>(args?: SelectSubset<T, TemplateItemTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateItemTags and returns the data saved in the database.
     * @param {TemplateItemTagCreateManyAndReturnArgs} args - Arguments to create many TemplateItemTags.
     * @example
     * // Create many TemplateItemTags
     * const templateItemTag = await prisma.templateItemTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateItemTags and only return the `id`
     * const templateItemTagWithIdOnly = await prisma.templateItemTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateItemTagCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateItemTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateItemTag.
     * @param {TemplateItemTagDeleteArgs} args - Arguments to delete one TemplateItemTag.
     * @example
     * // Delete one TemplateItemTag
     * const TemplateItemTag = await prisma.templateItemTag.delete({
     *   where: {
     *     // ... filter to delete one TemplateItemTag
     *   }
     * })
     * 
     */
    delete<T extends TemplateItemTagDeleteArgs>(args: SelectSubset<T, TemplateItemTagDeleteArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateItemTag.
     * @param {TemplateItemTagUpdateArgs} args - Arguments to update one TemplateItemTag.
     * @example
     * // Update one TemplateItemTag
     * const templateItemTag = await prisma.templateItemTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateItemTagUpdateArgs>(args: SelectSubset<T, TemplateItemTagUpdateArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateItemTags.
     * @param {TemplateItemTagDeleteManyArgs} args - Arguments to filter TemplateItemTags to delete.
     * @example
     * // Delete a few TemplateItemTags
     * const { count } = await prisma.templateItemTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateItemTagDeleteManyArgs>(args?: SelectSubset<T, TemplateItemTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateItemTags
     * const templateItemTag = await prisma.templateItemTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateItemTagUpdateManyArgs>(args: SelectSubset<T, TemplateItemTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItemTags and returns the data updated in the database.
     * @param {TemplateItemTagUpdateManyAndReturnArgs} args - Arguments to update many TemplateItemTags.
     * @example
     * // Update many TemplateItemTags
     * const templateItemTag = await prisma.templateItemTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateItemTags and only return the `id`
     * const templateItemTagWithIdOnly = await prisma.templateItemTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateItemTagUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateItemTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateItemTag.
     * @param {TemplateItemTagUpsertArgs} args - Arguments to update or create a TemplateItemTag.
     * @example
     * // Update or create a TemplateItemTag
     * const templateItemTag = await prisma.templateItemTag.upsert({
     *   create: {
     *     // ... data to create a TemplateItemTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateItemTag we want to update
     *   }
     * })
     */
    upsert<T extends TemplateItemTagUpsertArgs>(args: SelectSubset<T, TemplateItemTagUpsertArgs<ExtArgs>>): Prisma__TemplateItemTagClient<$Result.GetResult<Prisma.$TemplateItemTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateItemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagCountArgs} args - Arguments to filter TemplateItemTags to count.
     * @example
     * // Count the number of TemplateItemTags
     * const count = await prisma.templateItemTag.count({
     *   where: {
     *     // ... the filter for the TemplateItemTags we want to count
     *   }
     * })
    **/
    count<T extends TemplateItemTagCountArgs>(
      args?: Subset<T, TemplateItemTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateItemTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateItemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateItemTagAggregateArgs>(args: Subset<T, TemplateItemTagAggregateArgs>): Prisma.PrismaPromise<GetTemplateItemTagAggregateType<T>>

    /**
     * Group by TemplateItemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateItemTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateItemTagGroupByArgs['orderBy'] }
        : { orderBy?: TemplateItemTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateItemTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateItemTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateItemTag model
   */
  readonly fields: TemplateItemTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateItemTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateItemTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    templateItem<T extends TemplateItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItemDefaultArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateItemTag model
   */
  interface TemplateItemTagFieldRefs {
    readonly id: FieldRef<"TemplateItemTag", 'Int'>
    readonly itemId: FieldRef<"TemplateItemTag", 'Int'>
    readonly tagId: FieldRef<"TemplateItemTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateItemTag findUnique
   */
  export type TemplateItemTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemTag to fetch.
     */
    where: TemplateItemTagWhereUniqueInput
  }

  /**
   * TemplateItemTag findUniqueOrThrow
   */
  export type TemplateItemTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemTag to fetch.
     */
    where: TemplateItemTagWhereUniqueInput
  }

  /**
   * TemplateItemTag findFirst
   */
  export type TemplateItemTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemTag to fetch.
     */
    where?: TemplateItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemTags to fetch.
     */
    orderBy?: TemplateItemTagOrderByWithRelationInput | TemplateItemTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItemTags.
     */
    cursor?: TemplateItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItemTags.
     */
    distinct?: TemplateItemTagScalarFieldEnum | TemplateItemTagScalarFieldEnum[]
  }

  /**
   * TemplateItemTag findFirstOrThrow
   */
  export type TemplateItemTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemTag to fetch.
     */
    where?: TemplateItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemTags to fetch.
     */
    orderBy?: TemplateItemTagOrderByWithRelationInput | TemplateItemTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItemTags.
     */
    cursor?: TemplateItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItemTags.
     */
    distinct?: TemplateItemTagScalarFieldEnum | TemplateItemTagScalarFieldEnum[]
  }

  /**
   * TemplateItemTag findMany
   */
  export type TemplateItemTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemTags to fetch.
     */
    where?: TemplateItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemTags to fetch.
     */
    orderBy?: TemplateItemTagOrderByWithRelationInput | TemplateItemTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateItemTags.
     */
    cursor?: TemplateItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemTags.
     */
    skip?: number
    distinct?: TemplateItemTagScalarFieldEnum | TemplateItemTagScalarFieldEnum[]
  }

  /**
   * TemplateItemTag create
   */
  export type TemplateItemTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateItemTag.
     */
    data: XOR<TemplateItemTagCreateInput, TemplateItemTagUncheckedCreateInput>
  }

  /**
   * TemplateItemTag createMany
   */
  export type TemplateItemTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateItemTags.
     */
    data: TemplateItemTagCreateManyInput | TemplateItemTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateItemTag createManyAndReturn
   */
  export type TemplateItemTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateItemTags.
     */
    data: TemplateItemTagCreateManyInput | TemplateItemTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItemTag update
   */
  export type TemplateItemTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateItemTag.
     */
    data: XOR<TemplateItemTagUpdateInput, TemplateItemTagUncheckedUpdateInput>
    /**
     * Choose, which TemplateItemTag to update.
     */
    where: TemplateItemTagWhereUniqueInput
  }

  /**
   * TemplateItemTag updateMany
   */
  export type TemplateItemTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateItemTags.
     */
    data: XOR<TemplateItemTagUpdateManyMutationInput, TemplateItemTagUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItemTags to update
     */
    where?: TemplateItemTagWhereInput
    /**
     * Limit how many TemplateItemTags to update.
     */
    limit?: number
  }

  /**
   * TemplateItemTag updateManyAndReturn
   */
  export type TemplateItemTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * The data used to update TemplateItemTags.
     */
    data: XOR<TemplateItemTagUpdateManyMutationInput, TemplateItemTagUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItemTags to update
     */
    where?: TemplateItemTagWhereInput
    /**
     * Limit how many TemplateItemTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItemTag upsert
   */
  export type TemplateItemTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateItemTag to update in case it exists.
     */
    where: TemplateItemTagWhereUniqueInput
    /**
     * In case the TemplateItemTag found by the `where` argument doesn't exist, create a new TemplateItemTag with this data.
     */
    create: XOR<TemplateItemTagCreateInput, TemplateItemTagUncheckedCreateInput>
    /**
     * In case the TemplateItemTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateItemTagUpdateInput, TemplateItemTagUncheckedUpdateInput>
  }

  /**
   * TemplateItemTag delete
   */
  export type TemplateItemTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
    /**
     * Filter which TemplateItemTag to delete.
     */
    where: TemplateItemTagWhereUniqueInput
  }

  /**
   * TemplateItemTag deleteMany
   */
  export type TemplateItemTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItemTags to delete
     */
    where?: TemplateItemTagWhereInput
    /**
     * Limit how many TemplateItemTags to delete.
     */
    limit?: number
  }

  /**
   * TemplateItemTag without action
   */
  export type TemplateItemTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemTag
     */
    select?: TemplateItemTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemTag
     */
    omit?: TemplateItemTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemTagInclude<ExtArgs> | null
  }


  /**
   * Model Addon
   */

  export type AggregateAddon = {
    _count: AddonCountAggregateOutputType | null
    _avg: AddonAvgAggregateOutputType | null
    _sum: AddonSumAggregateOutputType | null
    _min: AddonMinAggregateOutputType | null
    _max: AddonMaxAggregateOutputType | null
  }

  export type AddonAvgAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
    templateId: number | null
  }

  export type AddonSumAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
    templateId: number | null
  }

  export type AddonMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    categoryId: number | null
    templateId: number | null
  }

  export type AddonMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    categoryId: number | null
    templateId: number | null
  }

  export type AddonCountAggregateOutputType = {
    id: number
    name: number
    price: number
    categoryId: number
    templateId: number
    _all: number
  }


  export type AddonAvgAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
    templateId?: true
  }

  export type AddonSumAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
    templateId?: true
  }

  export type AddonMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    categoryId?: true
    templateId?: true
  }

  export type AddonMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    categoryId?: true
    templateId?: true
  }

  export type AddonCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    categoryId?: true
    templateId?: true
    _all?: true
  }

  export type AddonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addon to aggregate.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addons
    **/
    _count?: true | AddonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddonMaxAggregateInputType
  }

  export type GetAddonAggregateType<T extends AddonAggregateArgs> = {
        [P in keyof T & keyof AggregateAddon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddon[P]>
      : GetScalarType<T[P], AggregateAddon[P]>
  }




  export type AddonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonWhereInput
    orderBy?: AddonOrderByWithAggregationInput | AddonOrderByWithAggregationInput[]
    by: AddonScalarFieldEnum[] | AddonScalarFieldEnum
    having?: AddonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddonCountAggregateInputType | true
    _avg?: AddonAvgAggregateInputType
    _sum?: AddonSumAggregateInputType
    _min?: AddonMinAggregateInputType
    _max?: AddonMaxAggregateInputType
  }

  export type AddonGroupByOutputType = {
    id: number
    name: string
    price: number
    categoryId: number
    templateId: number
    _count: AddonCountAggregateOutputType | null
    _avg: AddonAvgAggregateOutputType | null
    _sum: AddonSumAggregateOutputType | null
    _min: AddonMinAggregateOutputType | null
    _max: AddonMaxAggregateOutputType | null
  }

  type GetAddonGroupByPayload<T extends AddonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddonGroupByOutputType[P]>
            : GetScalarType<T[P], AddonGroupByOutputType[P]>
        }
      >
    >


  export type AddonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    categoryId?: boolean
    templateId?: boolean
    category?: boolean | AddonCategoryDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    items?: boolean | Addon$itemsArgs<ExtArgs>
    _count?: boolean | AddonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addon"]>

  export type AddonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    categoryId?: boolean
    templateId?: boolean
    category?: boolean | AddonCategoryDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addon"]>

  export type AddonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    categoryId?: boolean
    templateId?: boolean
    category?: boolean | AddonCategoryDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addon"]>

  export type AddonSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    categoryId?: boolean
    templateId?: boolean
  }

  export type AddonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "categoryId" | "templateId", ExtArgs["result"]["addon"]>
  export type AddonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | AddonCategoryDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    items?: boolean | Addon$itemsArgs<ExtArgs>
    _count?: boolean | AddonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | AddonCategoryDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }
  export type AddonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | AddonCategoryDefaultArgs<ExtArgs>
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }

  export type $AddonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Addon"
    objects: {
      category: Prisma.$AddonCategoryPayload<ExtArgs>
      template: Prisma.$MenuTemplatePayload<ExtArgs>
      items: Prisma.$TemplateItemAddonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      price: number
      categoryId: number
      templateId: number
    }, ExtArgs["result"]["addon"]>
    composites: {}
  }

  type AddonGetPayload<S extends boolean | null | undefined | AddonDefaultArgs> = $Result.GetResult<Prisma.$AddonPayload, S>

  type AddonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddonCountAggregateInputType | true
    }

  export interface AddonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Addon'], meta: { name: 'Addon' } }
    /**
     * Find zero or one Addon that matches the filter.
     * @param {AddonFindUniqueArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddonFindUniqueArgs>(args: SelectSubset<T, AddonFindUniqueArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Addon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddonFindUniqueOrThrowArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddonFindUniqueOrThrowArgs>(args: SelectSubset<T, AddonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonFindFirstArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddonFindFirstArgs>(args?: SelectSubset<T, AddonFindFirstArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonFindFirstOrThrowArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddonFindFirstOrThrowArgs>(args?: SelectSubset<T, AddonFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addons
     * const addons = await prisma.addon.findMany()
     * 
     * // Get first 10 Addons
     * const addons = await prisma.addon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addonWithIdOnly = await prisma.addon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddonFindManyArgs>(args?: SelectSubset<T, AddonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Addon.
     * @param {AddonCreateArgs} args - Arguments to create a Addon.
     * @example
     * // Create one Addon
     * const Addon = await prisma.addon.create({
     *   data: {
     *     // ... data to create a Addon
     *   }
     * })
     * 
     */
    create<T extends AddonCreateArgs>(args: SelectSubset<T, AddonCreateArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addons.
     * @param {AddonCreateManyArgs} args - Arguments to create many Addons.
     * @example
     * // Create many Addons
     * const addon = await prisma.addon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddonCreateManyArgs>(args?: SelectSubset<T, AddonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addons and returns the data saved in the database.
     * @param {AddonCreateManyAndReturnArgs} args - Arguments to create many Addons.
     * @example
     * // Create many Addons
     * const addon = await prisma.addon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addons and only return the `id`
     * const addonWithIdOnly = await prisma.addon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddonCreateManyAndReturnArgs>(args?: SelectSubset<T, AddonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Addon.
     * @param {AddonDeleteArgs} args - Arguments to delete one Addon.
     * @example
     * // Delete one Addon
     * const Addon = await prisma.addon.delete({
     *   where: {
     *     // ... filter to delete one Addon
     *   }
     * })
     * 
     */
    delete<T extends AddonDeleteArgs>(args: SelectSubset<T, AddonDeleteArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Addon.
     * @param {AddonUpdateArgs} args - Arguments to update one Addon.
     * @example
     * // Update one Addon
     * const addon = await prisma.addon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddonUpdateArgs>(args: SelectSubset<T, AddonUpdateArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addons.
     * @param {AddonDeleteManyArgs} args - Arguments to filter Addons to delete.
     * @example
     * // Delete a few Addons
     * const { count } = await prisma.addon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddonDeleteManyArgs>(args?: SelectSubset<T, AddonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addons
     * const addon = await prisma.addon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddonUpdateManyArgs>(args: SelectSubset<T, AddonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addons and returns the data updated in the database.
     * @param {AddonUpdateManyAndReturnArgs} args - Arguments to update many Addons.
     * @example
     * // Update many Addons
     * const addon = await prisma.addon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addons and only return the `id`
     * const addonWithIdOnly = await prisma.addon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddonUpdateManyAndReturnArgs>(args: SelectSubset<T, AddonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Addon.
     * @param {AddonUpsertArgs} args - Arguments to update or create a Addon.
     * @example
     * // Update or create a Addon
     * const addon = await prisma.addon.upsert({
     *   create: {
     *     // ... data to create a Addon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addon we want to update
     *   }
     * })
     */
    upsert<T extends AddonUpsertArgs>(args: SelectSubset<T, AddonUpsertArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCountArgs} args - Arguments to filter Addons to count.
     * @example
     * // Count the number of Addons
     * const count = await prisma.addon.count({
     *   where: {
     *     // ... the filter for the Addons we want to count
     *   }
     * })
    **/
    count<T extends AddonCountArgs>(
      args?: Subset<T, AddonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Addon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddonAggregateArgs>(args: Subset<T, AddonAggregateArgs>): Prisma.PrismaPromise<GetAddonAggregateType<T>>

    /**
     * Group by Addon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddonGroupByArgs['orderBy'] }
        : { orderBy?: AddonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Addon model
   */
  readonly fields: AddonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Addon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends AddonCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddonCategoryDefaultArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends MenuTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplateDefaultArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Addon$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Addon$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Addon model
   */
  interface AddonFieldRefs {
    readonly id: FieldRef<"Addon", 'Int'>
    readonly name: FieldRef<"Addon", 'String'>
    readonly price: FieldRef<"Addon", 'Float'>
    readonly categoryId: FieldRef<"Addon", 'Int'>
    readonly templateId: FieldRef<"Addon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Addon findUnique
   */
  export type AddonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon findUniqueOrThrow
   */
  export type AddonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon findFirst
   */
  export type AddonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addons.
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addons.
     */
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Addon findFirstOrThrow
   */
  export type AddonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addons.
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addons.
     */
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Addon findMany
   */
  export type AddonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addons to fetch.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addons.
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Addon create
   */
  export type AddonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * The data needed to create a Addon.
     */
    data: XOR<AddonCreateInput, AddonUncheckedCreateInput>
  }

  /**
   * Addon createMany
   */
  export type AddonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addons.
     */
    data: AddonCreateManyInput | AddonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Addon createManyAndReturn
   */
  export type AddonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * The data used to create many Addons.
     */
    data: AddonCreateManyInput | AddonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Addon update
   */
  export type AddonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * The data needed to update a Addon.
     */
    data: XOR<AddonUpdateInput, AddonUncheckedUpdateInput>
    /**
     * Choose, which Addon to update.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon updateMany
   */
  export type AddonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addons.
     */
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyInput>
    /**
     * Filter which Addons to update
     */
    where?: AddonWhereInput
    /**
     * Limit how many Addons to update.
     */
    limit?: number
  }

  /**
   * Addon updateManyAndReturn
   */
  export type AddonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * The data used to update Addons.
     */
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyInput>
    /**
     * Filter which Addons to update
     */
    where?: AddonWhereInput
    /**
     * Limit how many Addons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Addon upsert
   */
  export type AddonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * The filter to search for the Addon to update in case it exists.
     */
    where: AddonWhereUniqueInput
    /**
     * In case the Addon found by the `where` argument doesn't exist, create a new Addon with this data.
     */
    create: XOR<AddonCreateInput, AddonUncheckedCreateInput>
    /**
     * In case the Addon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddonUpdateInput, AddonUncheckedUpdateInput>
  }

  /**
   * Addon delete
   */
  export type AddonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter which Addon to delete.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon deleteMany
   */
  export type AddonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addons to delete
     */
    where?: AddonWhereInput
    /**
     * Limit how many Addons to delete.
     */
    limit?: number
  }

  /**
   * Addon.items
   */
  export type Addon$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    where?: TemplateItemAddonWhereInput
    orderBy?: TemplateItemAddonOrderByWithRelationInput | TemplateItemAddonOrderByWithRelationInput[]
    cursor?: TemplateItemAddonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateItemAddonScalarFieldEnum | TemplateItemAddonScalarFieldEnum[]
  }

  /**
   * Addon without action
   */
  export type AddonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
  }


  /**
   * Model TemplateItemAddon
   */

  export type AggregateTemplateItemAddon = {
    _count: TemplateItemAddonCountAggregateOutputType | null
    _avg: TemplateItemAddonAvgAggregateOutputType | null
    _sum: TemplateItemAddonSumAggregateOutputType | null
    _min: TemplateItemAddonMinAggregateOutputType | null
    _max: TemplateItemAddonMaxAggregateOutputType | null
  }

  export type TemplateItemAddonAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    addonId: number | null
  }

  export type TemplateItemAddonSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    addonId: number | null
  }

  export type TemplateItemAddonMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    addonId: number | null
  }

  export type TemplateItemAddonMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    addonId: number | null
  }

  export type TemplateItemAddonCountAggregateOutputType = {
    id: number
    itemId: number
    addonId: number
    _all: number
  }


  export type TemplateItemAddonAvgAggregateInputType = {
    id?: true
    itemId?: true
    addonId?: true
  }

  export type TemplateItemAddonSumAggregateInputType = {
    id?: true
    itemId?: true
    addonId?: true
  }

  export type TemplateItemAddonMinAggregateInputType = {
    id?: true
    itemId?: true
    addonId?: true
  }

  export type TemplateItemAddonMaxAggregateInputType = {
    id?: true
    itemId?: true
    addonId?: true
  }

  export type TemplateItemAddonCountAggregateInputType = {
    id?: true
    itemId?: true
    addonId?: true
    _all?: true
  }

  export type TemplateItemAddonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItemAddon to aggregate.
     */
    where?: TemplateItemAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemAddons to fetch.
     */
    orderBy?: TemplateItemAddonOrderByWithRelationInput | TemplateItemAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateItemAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateItemAddons
    **/
    _count?: true | TemplateItemAddonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateItemAddonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateItemAddonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateItemAddonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateItemAddonMaxAggregateInputType
  }

  export type GetTemplateItemAddonAggregateType<T extends TemplateItemAddonAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateItemAddon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateItemAddon[P]>
      : GetScalarType<T[P], AggregateTemplateItemAddon[P]>
  }




  export type TemplateItemAddonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateItemAddonWhereInput
    orderBy?: TemplateItemAddonOrderByWithAggregationInput | TemplateItemAddonOrderByWithAggregationInput[]
    by: TemplateItemAddonScalarFieldEnum[] | TemplateItemAddonScalarFieldEnum
    having?: TemplateItemAddonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateItemAddonCountAggregateInputType | true
    _avg?: TemplateItemAddonAvgAggregateInputType
    _sum?: TemplateItemAddonSumAggregateInputType
    _min?: TemplateItemAddonMinAggregateInputType
    _max?: TemplateItemAddonMaxAggregateInputType
  }

  export type TemplateItemAddonGroupByOutputType = {
    id: number
    itemId: number
    addonId: number
    _count: TemplateItemAddonCountAggregateOutputType | null
    _avg: TemplateItemAddonAvgAggregateOutputType | null
    _sum: TemplateItemAddonSumAggregateOutputType | null
    _min: TemplateItemAddonMinAggregateOutputType | null
    _max: TemplateItemAddonMaxAggregateOutputType | null
  }

  type GetTemplateItemAddonGroupByPayload<T extends TemplateItemAddonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateItemAddonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateItemAddonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateItemAddonGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateItemAddonGroupByOutputType[P]>
        }
      >
    >


  export type TemplateItemAddonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    addonId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    addon?: boolean | AddonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemAddon"]>

  export type TemplateItemAddonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    addonId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    addon?: boolean | AddonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemAddon"]>

  export type TemplateItemAddonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    addonId?: boolean
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    addon?: boolean | AddonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateItemAddon"]>

  export type TemplateItemAddonSelectScalar = {
    id?: boolean
    itemId?: boolean
    addonId?: boolean
  }

  export type TemplateItemAddonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "addonId", ExtArgs["result"]["templateItemAddon"]>
  export type TemplateItemAddonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    addon?: boolean | AddonDefaultArgs<ExtArgs>
  }
  export type TemplateItemAddonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    addon?: boolean | AddonDefaultArgs<ExtArgs>
  }
  export type TemplateItemAddonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    addon?: boolean | AddonDefaultArgs<ExtArgs>
  }

  export type $TemplateItemAddonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateItemAddon"
    objects: {
      templateItem: Prisma.$TemplateItemPayload<ExtArgs>
      addon: Prisma.$AddonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      addonId: number
    }, ExtArgs["result"]["templateItemAddon"]>
    composites: {}
  }

  type TemplateItemAddonGetPayload<S extends boolean | null | undefined | TemplateItemAddonDefaultArgs> = $Result.GetResult<Prisma.$TemplateItemAddonPayload, S>

  type TemplateItemAddonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateItemAddonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateItemAddonCountAggregateInputType | true
    }

  export interface TemplateItemAddonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateItemAddon'], meta: { name: 'TemplateItemAddon' } }
    /**
     * Find zero or one TemplateItemAddon that matches the filter.
     * @param {TemplateItemAddonFindUniqueArgs} args - Arguments to find a TemplateItemAddon
     * @example
     * // Get one TemplateItemAddon
     * const templateItemAddon = await prisma.templateItemAddon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateItemAddonFindUniqueArgs>(args: SelectSubset<T, TemplateItemAddonFindUniqueArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateItemAddon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateItemAddonFindUniqueOrThrowArgs} args - Arguments to find a TemplateItemAddon
     * @example
     * // Get one TemplateItemAddon
     * const templateItemAddon = await prisma.templateItemAddon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateItemAddonFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateItemAddonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItemAddon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonFindFirstArgs} args - Arguments to find a TemplateItemAddon
     * @example
     * // Get one TemplateItemAddon
     * const templateItemAddon = await prisma.templateItemAddon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateItemAddonFindFirstArgs>(args?: SelectSubset<T, TemplateItemAddonFindFirstArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateItemAddon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonFindFirstOrThrowArgs} args - Arguments to find a TemplateItemAddon
     * @example
     * // Get one TemplateItemAddon
     * const templateItemAddon = await prisma.templateItemAddon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateItemAddonFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateItemAddonFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateItemAddons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateItemAddons
     * const templateItemAddons = await prisma.templateItemAddon.findMany()
     * 
     * // Get first 10 TemplateItemAddons
     * const templateItemAddons = await prisma.templateItemAddon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateItemAddonWithIdOnly = await prisma.templateItemAddon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateItemAddonFindManyArgs>(args?: SelectSubset<T, TemplateItemAddonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateItemAddon.
     * @param {TemplateItemAddonCreateArgs} args - Arguments to create a TemplateItemAddon.
     * @example
     * // Create one TemplateItemAddon
     * const TemplateItemAddon = await prisma.templateItemAddon.create({
     *   data: {
     *     // ... data to create a TemplateItemAddon
     *   }
     * })
     * 
     */
    create<T extends TemplateItemAddonCreateArgs>(args: SelectSubset<T, TemplateItemAddonCreateArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateItemAddons.
     * @param {TemplateItemAddonCreateManyArgs} args - Arguments to create many TemplateItemAddons.
     * @example
     * // Create many TemplateItemAddons
     * const templateItemAddon = await prisma.templateItemAddon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateItemAddonCreateManyArgs>(args?: SelectSubset<T, TemplateItemAddonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateItemAddons and returns the data saved in the database.
     * @param {TemplateItemAddonCreateManyAndReturnArgs} args - Arguments to create many TemplateItemAddons.
     * @example
     * // Create many TemplateItemAddons
     * const templateItemAddon = await prisma.templateItemAddon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateItemAddons and only return the `id`
     * const templateItemAddonWithIdOnly = await prisma.templateItemAddon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateItemAddonCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateItemAddonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateItemAddon.
     * @param {TemplateItemAddonDeleteArgs} args - Arguments to delete one TemplateItemAddon.
     * @example
     * // Delete one TemplateItemAddon
     * const TemplateItemAddon = await prisma.templateItemAddon.delete({
     *   where: {
     *     // ... filter to delete one TemplateItemAddon
     *   }
     * })
     * 
     */
    delete<T extends TemplateItemAddonDeleteArgs>(args: SelectSubset<T, TemplateItemAddonDeleteArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateItemAddon.
     * @param {TemplateItemAddonUpdateArgs} args - Arguments to update one TemplateItemAddon.
     * @example
     * // Update one TemplateItemAddon
     * const templateItemAddon = await prisma.templateItemAddon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateItemAddonUpdateArgs>(args: SelectSubset<T, TemplateItemAddonUpdateArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateItemAddons.
     * @param {TemplateItemAddonDeleteManyArgs} args - Arguments to filter TemplateItemAddons to delete.
     * @example
     * // Delete a few TemplateItemAddons
     * const { count } = await prisma.templateItemAddon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateItemAddonDeleteManyArgs>(args?: SelectSubset<T, TemplateItemAddonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItemAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateItemAddons
     * const templateItemAddon = await prisma.templateItemAddon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateItemAddonUpdateManyArgs>(args: SelectSubset<T, TemplateItemAddonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateItemAddons and returns the data updated in the database.
     * @param {TemplateItemAddonUpdateManyAndReturnArgs} args - Arguments to update many TemplateItemAddons.
     * @example
     * // Update many TemplateItemAddons
     * const templateItemAddon = await prisma.templateItemAddon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateItemAddons and only return the `id`
     * const templateItemAddonWithIdOnly = await prisma.templateItemAddon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateItemAddonUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateItemAddonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateItemAddon.
     * @param {TemplateItemAddonUpsertArgs} args - Arguments to update or create a TemplateItemAddon.
     * @example
     * // Update or create a TemplateItemAddon
     * const templateItemAddon = await prisma.templateItemAddon.upsert({
     *   create: {
     *     // ... data to create a TemplateItemAddon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateItemAddon we want to update
     *   }
     * })
     */
    upsert<T extends TemplateItemAddonUpsertArgs>(args: SelectSubset<T, TemplateItemAddonUpsertArgs<ExtArgs>>): Prisma__TemplateItemAddonClient<$Result.GetResult<Prisma.$TemplateItemAddonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateItemAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonCountArgs} args - Arguments to filter TemplateItemAddons to count.
     * @example
     * // Count the number of TemplateItemAddons
     * const count = await prisma.templateItemAddon.count({
     *   where: {
     *     // ... the filter for the TemplateItemAddons we want to count
     *   }
     * })
    **/
    count<T extends TemplateItemAddonCountArgs>(
      args?: Subset<T, TemplateItemAddonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateItemAddonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateItemAddon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateItemAddonAggregateArgs>(args: Subset<T, TemplateItemAddonAggregateArgs>): Prisma.PrismaPromise<GetTemplateItemAddonAggregateType<T>>

    /**
     * Group by TemplateItemAddon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateItemAddonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateItemAddonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateItemAddonGroupByArgs['orderBy'] }
        : { orderBy?: TemplateItemAddonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateItemAddonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateItemAddonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateItemAddon model
   */
  readonly fields: TemplateItemAddonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateItemAddon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateItemAddonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    templateItem<T extends TemplateItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItemDefaultArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addon<T extends AddonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddonDefaultArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateItemAddon model
   */
  interface TemplateItemAddonFieldRefs {
    readonly id: FieldRef<"TemplateItemAddon", 'Int'>
    readonly itemId: FieldRef<"TemplateItemAddon", 'Int'>
    readonly addonId: FieldRef<"TemplateItemAddon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateItemAddon findUnique
   */
  export type TemplateItemAddonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemAddon to fetch.
     */
    where: TemplateItemAddonWhereUniqueInput
  }

  /**
   * TemplateItemAddon findUniqueOrThrow
   */
  export type TemplateItemAddonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemAddon to fetch.
     */
    where: TemplateItemAddonWhereUniqueInput
  }

  /**
   * TemplateItemAddon findFirst
   */
  export type TemplateItemAddonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemAddon to fetch.
     */
    where?: TemplateItemAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemAddons to fetch.
     */
    orderBy?: TemplateItemAddonOrderByWithRelationInput | TemplateItemAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItemAddons.
     */
    cursor?: TemplateItemAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItemAddons.
     */
    distinct?: TemplateItemAddonScalarFieldEnum | TemplateItemAddonScalarFieldEnum[]
  }

  /**
   * TemplateItemAddon findFirstOrThrow
   */
  export type TemplateItemAddonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemAddon to fetch.
     */
    where?: TemplateItemAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemAddons to fetch.
     */
    orderBy?: TemplateItemAddonOrderByWithRelationInput | TemplateItemAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateItemAddons.
     */
    cursor?: TemplateItemAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateItemAddons.
     */
    distinct?: TemplateItemAddonScalarFieldEnum | TemplateItemAddonScalarFieldEnum[]
  }

  /**
   * TemplateItemAddon findMany
   */
  export type TemplateItemAddonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * Filter, which TemplateItemAddons to fetch.
     */
    where?: TemplateItemAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateItemAddons to fetch.
     */
    orderBy?: TemplateItemAddonOrderByWithRelationInput | TemplateItemAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateItemAddons.
     */
    cursor?: TemplateItemAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateItemAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateItemAddons.
     */
    skip?: number
    distinct?: TemplateItemAddonScalarFieldEnum | TemplateItemAddonScalarFieldEnum[]
  }

  /**
   * TemplateItemAddon create
   */
  export type TemplateItemAddonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateItemAddon.
     */
    data: XOR<TemplateItemAddonCreateInput, TemplateItemAddonUncheckedCreateInput>
  }

  /**
   * TemplateItemAddon createMany
   */
  export type TemplateItemAddonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateItemAddons.
     */
    data: TemplateItemAddonCreateManyInput | TemplateItemAddonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateItemAddon createManyAndReturn
   */
  export type TemplateItemAddonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateItemAddons.
     */
    data: TemplateItemAddonCreateManyInput | TemplateItemAddonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItemAddon update
   */
  export type TemplateItemAddonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateItemAddon.
     */
    data: XOR<TemplateItemAddonUpdateInput, TemplateItemAddonUncheckedUpdateInput>
    /**
     * Choose, which TemplateItemAddon to update.
     */
    where: TemplateItemAddonWhereUniqueInput
  }

  /**
   * TemplateItemAddon updateMany
   */
  export type TemplateItemAddonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateItemAddons.
     */
    data: XOR<TemplateItemAddonUpdateManyMutationInput, TemplateItemAddonUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItemAddons to update
     */
    where?: TemplateItemAddonWhereInput
    /**
     * Limit how many TemplateItemAddons to update.
     */
    limit?: number
  }

  /**
   * TemplateItemAddon updateManyAndReturn
   */
  export type TemplateItemAddonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * The data used to update TemplateItemAddons.
     */
    data: XOR<TemplateItemAddonUpdateManyMutationInput, TemplateItemAddonUncheckedUpdateManyInput>
    /**
     * Filter which TemplateItemAddons to update
     */
    where?: TemplateItemAddonWhereInput
    /**
     * Limit how many TemplateItemAddons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateItemAddon upsert
   */
  export type TemplateItemAddonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateItemAddon to update in case it exists.
     */
    where: TemplateItemAddonWhereUniqueInput
    /**
     * In case the TemplateItemAddon found by the `where` argument doesn't exist, create a new TemplateItemAddon with this data.
     */
    create: XOR<TemplateItemAddonCreateInput, TemplateItemAddonUncheckedCreateInput>
    /**
     * In case the TemplateItemAddon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateItemAddonUpdateInput, TemplateItemAddonUncheckedUpdateInput>
  }

  /**
   * TemplateItemAddon delete
   */
  export type TemplateItemAddonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
    /**
     * Filter which TemplateItemAddon to delete.
     */
    where: TemplateItemAddonWhereUniqueInput
  }

  /**
   * TemplateItemAddon deleteMany
   */
  export type TemplateItemAddonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateItemAddons to delete
     */
    where?: TemplateItemAddonWhereInput
    /**
     * Limit how many TemplateItemAddons to delete.
     */
    limit?: number
  }

  /**
   * TemplateItemAddon without action
   */
  export type TemplateItemAddonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemAddon
     */
    select?: TemplateItemAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemAddon
     */
    omit?: TemplateItemAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemAddonInclude<ExtArgs> | null
  }


  /**
   * Model AddonCategory
   */

  export type AggregateAddonCategory = {
    _count: AddonCategoryCountAggregateOutputType | null
    _avg: AddonCategoryAvgAggregateOutputType | null
    _sum: AddonCategorySumAggregateOutputType | null
    _min: AddonCategoryMinAggregateOutputType | null
    _max: AddonCategoryMaxAggregateOutputType | null
  }

  export type AddonCategoryAvgAggregateOutputType = {
    id: number | null
    maxSelectable: number | null
    templateId: number | null
  }

  export type AddonCategorySumAggregateOutputType = {
    id: number | null
    maxSelectable: number | null
    templateId: number | null
  }

  export type AddonCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    maxSelectable: number | null
    isRequired: boolean | null
    templateId: number | null
  }

  export type AddonCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    maxSelectable: number | null
    isRequired: boolean | null
    templateId: number | null
  }

  export type AddonCategoryCountAggregateOutputType = {
    id: number
    name: number
    maxSelectable: number
    isRequired: number
    templateId: number
    _all: number
  }


  export type AddonCategoryAvgAggregateInputType = {
    id?: true
    maxSelectable?: true
    templateId?: true
  }

  export type AddonCategorySumAggregateInputType = {
    id?: true
    maxSelectable?: true
    templateId?: true
  }

  export type AddonCategoryMinAggregateInputType = {
    id?: true
    name?: true
    maxSelectable?: true
    isRequired?: true
    templateId?: true
  }

  export type AddonCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    maxSelectable?: true
    isRequired?: true
    templateId?: true
  }

  export type AddonCategoryCountAggregateInputType = {
    id?: true
    name?: true
    maxSelectable?: true
    isRequired?: true
    templateId?: true
    _all?: true
  }

  export type AddonCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddonCategory to aggregate.
     */
    where?: AddonCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonCategories to fetch.
     */
    orderBy?: AddonCategoryOrderByWithRelationInput | AddonCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddonCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddonCategories
    **/
    _count?: true | AddonCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddonCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddonCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddonCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddonCategoryMaxAggregateInputType
  }

  export type GetAddonCategoryAggregateType<T extends AddonCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAddonCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddonCategory[P]>
      : GetScalarType<T[P], AggregateAddonCategory[P]>
  }




  export type AddonCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonCategoryWhereInput
    orderBy?: AddonCategoryOrderByWithAggregationInput | AddonCategoryOrderByWithAggregationInput[]
    by: AddonCategoryScalarFieldEnum[] | AddonCategoryScalarFieldEnum
    having?: AddonCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddonCategoryCountAggregateInputType | true
    _avg?: AddonCategoryAvgAggregateInputType
    _sum?: AddonCategorySumAggregateInputType
    _min?: AddonCategoryMinAggregateInputType
    _max?: AddonCategoryMaxAggregateInputType
  }

  export type AddonCategoryGroupByOutputType = {
    id: number
    name: string
    maxSelectable: number
    isRequired: boolean
    templateId: number
    _count: AddonCategoryCountAggregateOutputType | null
    _avg: AddonCategoryAvgAggregateOutputType | null
    _sum: AddonCategorySumAggregateOutputType | null
    _min: AddonCategoryMinAggregateOutputType | null
    _max: AddonCategoryMaxAggregateOutputType | null
  }

  type GetAddonCategoryGroupByPayload<T extends AddonCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddonCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddonCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddonCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], AddonCategoryGroupByOutputType[P]>
        }
      >
    >


  export type AddonCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    maxSelectable?: boolean
    isRequired?: boolean
    templateId?: boolean
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    addons?: boolean | AddonCategory$addonsArgs<ExtArgs>
    _count?: boolean | AddonCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addonCategory"]>

  export type AddonCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    maxSelectable?: boolean
    isRequired?: boolean
    templateId?: boolean
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addonCategory"]>

  export type AddonCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    maxSelectable?: boolean
    isRequired?: boolean
    templateId?: boolean
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addonCategory"]>

  export type AddonCategorySelectScalar = {
    id?: boolean
    name?: boolean
    maxSelectable?: boolean
    isRequired?: boolean
    templateId?: boolean
  }

  export type AddonCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "maxSelectable" | "isRequired" | "templateId", ExtArgs["result"]["addonCategory"]>
  export type AddonCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
    addons?: boolean | AddonCategory$addonsArgs<ExtArgs>
    _count?: boolean | AddonCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddonCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }
  export type AddonCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | MenuTemplateDefaultArgs<ExtArgs>
  }

  export type $AddonCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddonCategory"
    objects: {
      template: Prisma.$MenuTemplatePayload<ExtArgs>
      addons: Prisma.$AddonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      maxSelectable: number
      isRequired: boolean
      templateId: number
    }, ExtArgs["result"]["addonCategory"]>
    composites: {}
  }

  type AddonCategoryGetPayload<S extends boolean | null | undefined | AddonCategoryDefaultArgs> = $Result.GetResult<Prisma.$AddonCategoryPayload, S>

  type AddonCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddonCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddonCategoryCountAggregateInputType | true
    }

  export interface AddonCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddonCategory'], meta: { name: 'AddonCategory' } }
    /**
     * Find zero or one AddonCategory that matches the filter.
     * @param {AddonCategoryFindUniqueArgs} args - Arguments to find a AddonCategory
     * @example
     * // Get one AddonCategory
     * const addonCategory = await prisma.addonCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddonCategoryFindUniqueArgs>(args: SelectSubset<T, AddonCategoryFindUniqueArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddonCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddonCategoryFindUniqueOrThrowArgs} args - Arguments to find a AddonCategory
     * @example
     * // Get one AddonCategory
     * const addonCategory = await prisma.addonCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddonCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AddonCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddonCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryFindFirstArgs} args - Arguments to find a AddonCategory
     * @example
     * // Get one AddonCategory
     * const addonCategory = await prisma.addonCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddonCategoryFindFirstArgs>(args?: SelectSubset<T, AddonCategoryFindFirstArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddonCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryFindFirstOrThrowArgs} args - Arguments to find a AddonCategory
     * @example
     * // Get one AddonCategory
     * const addonCategory = await prisma.addonCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddonCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AddonCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddonCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddonCategories
     * const addonCategories = await prisma.addonCategory.findMany()
     * 
     * // Get first 10 AddonCategories
     * const addonCategories = await prisma.addonCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addonCategoryWithIdOnly = await prisma.addonCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddonCategoryFindManyArgs>(args?: SelectSubset<T, AddonCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddonCategory.
     * @param {AddonCategoryCreateArgs} args - Arguments to create a AddonCategory.
     * @example
     * // Create one AddonCategory
     * const AddonCategory = await prisma.addonCategory.create({
     *   data: {
     *     // ... data to create a AddonCategory
     *   }
     * })
     * 
     */
    create<T extends AddonCategoryCreateArgs>(args: SelectSubset<T, AddonCategoryCreateArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddonCategories.
     * @param {AddonCategoryCreateManyArgs} args - Arguments to create many AddonCategories.
     * @example
     * // Create many AddonCategories
     * const addonCategory = await prisma.addonCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddonCategoryCreateManyArgs>(args?: SelectSubset<T, AddonCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddonCategories and returns the data saved in the database.
     * @param {AddonCategoryCreateManyAndReturnArgs} args - Arguments to create many AddonCategories.
     * @example
     * // Create many AddonCategories
     * const addonCategory = await prisma.addonCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddonCategories and only return the `id`
     * const addonCategoryWithIdOnly = await prisma.addonCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddonCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AddonCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddonCategory.
     * @param {AddonCategoryDeleteArgs} args - Arguments to delete one AddonCategory.
     * @example
     * // Delete one AddonCategory
     * const AddonCategory = await prisma.addonCategory.delete({
     *   where: {
     *     // ... filter to delete one AddonCategory
     *   }
     * })
     * 
     */
    delete<T extends AddonCategoryDeleteArgs>(args: SelectSubset<T, AddonCategoryDeleteArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddonCategory.
     * @param {AddonCategoryUpdateArgs} args - Arguments to update one AddonCategory.
     * @example
     * // Update one AddonCategory
     * const addonCategory = await prisma.addonCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddonCategoryUpdateArgs>(args: SelectSubset<T, AddonCategoryUpdateArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddonCategories.
     * @param {AddonCategoryDeleteManyArgs} args - Arguments to filter AddonCategories to delete.
     * @example
     * // Delete a few AddonCategories
     * const { count } = await prisma.addonCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddonCategoryDeleteManyArgs>(args?: SelectSubset<T, AddonCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddonCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddonCategories
     * const addonCategory = await prisma.addonCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddonCategoryUpdateManyArgs>(args: SelectSubset<T, AddonCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddonCategories and returns the data updated in the database.
     * @param {AddonCategoryUpdateManyAndReturnArgs} args - Arguments to update many AddonCategories.
     * @example
     * // Update many AddonCategories
     * const addonCategory = await prisma.addonCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddonCategories and only return the `id`
     * const addonCategoryWithIdOnly = await prisma.addonCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddonCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AddonCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddonCategory.
     * @param {AddonCategoryUpsertArgs} args - Arguments to update or create a AddonCategory.
     * @example
     * // Update or create a AddonCategory
     * const addonCategory = await prisma.addonCategory.upsert({
     *   create: {
     *     // ... data to create a AddonCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddonCategory we want to update
     *   }
     * })
     */
    upsert<T extends AddonCategoryUpsertArgs>(args: SelectSubset<T, AddonCategoryUpsertArgs<ExtArgs>>): Prisma__AddonCategoryClient<$Result.GetResult<Prisma.$AddonCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddonCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryCountArgs} args - Arguments to filter AddonCategories to count.
     * @example
     * // Count the number of AddonCategories
     * const count = await prisma.addonCategory.count({
     *   where: {
     *     // ... the filter for the AddonCategories we want to count
     *   }
     * })
    **/
    count<T extends AddonCategoryCountArgs>(
      args?: Subset<T, AddonCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddonCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddonCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddonCategoryAggregateArgs>(args: Subset<T, AddonCategoryAggregateArgs>): Prisma.PrismaPromise<GetAddonCategoryAggregateType<T>>

    /**
     * Group by AddonCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddonCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddonCategoryGroupByArgs['orderBy'] }
        : { orderBy?: AddonCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddonCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddonCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddonCategory model
   */
  readonly fields: AddonCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddonCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddonCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends MenuTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuTemplateDefaultArgs<ExtArgs>>): Prisma__MenuTemplateClient<$Result.GetResult<Prisma.$MenuTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addons<T extends AddonCategory$addonsArgs<ExtArgs> = {}>(args?: Subset<T, AddonCategory$addonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddonCategory model
   */
  interface AddonCategoryFieldRefs {
    readonly id: FieldRef<"AddonCategory", 'Int'>
    readonly name: FieldRef<"AddonCategory", 'String'>
    readonly maxSelectable: FieldRef<"AddonCategory", 'Int'>
    readonly isRequired: FieldRef<"AddonCategory", 'Boolean'>
    readonly templateId: FieldRef<"AddonCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AddonCategory findUnique
   */
  export type AddonCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AddonCategory to fetch.
     */
    where: AddonCategoryWhereUniqueInput
  }

  /**
   * AddonCategory findUniqueOrThrow
   */
  export type AddonCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AddonCategory to fetch.
     */
    where: AddonCategoryWhereUniqueInput
  }

  /**
   * AddonCategory findFirst
   */
  export type AddonCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AddonCategory to fetch.
     */
    where?: AddonCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonCategories to fetch.
     */
    orderBy?: AddonCategoryOrderByWithRelationInput | AddonCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddonCategories.
     */
    cursor?: AddonCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddonCategories.
     */
    distinct?: AddonCategoryScalarFieldEnum | AddonCategoryScalarFieldEnum[]
  }

  /**
   * AddonCategory findFirstOrThrow
   */
  export type AddonCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AddonCategory to fetch.
     */
    where?: AddonCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonCategories to fetch.
     */
    orderBy?: AddonCategoryOrderByWithRelationInput | AddonCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddonCategories.
     */
    cursor?: AddonCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddonCategories.
     */
    distinct?: AddonCategoryScalarFieldEnum | AddonCategoryScalarFieldEnum[]
  }

  /**
   * AddonCategory findMany
   */
  export type AddonCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AddonCategories to fetch.
     */
    where?: AddonCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonCategories to fetch.
     */
    orderBy?: AddonCategoryOrderByWithRelationInput | AddonCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddonCategories.
     */
    cursor?: AddonCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonCategories.
     */
    skip?: number
    distinct?: AddonCategoryScalarFieldEnum | AddonCategoryScalarFieldEnum[]
  }

  /**
   * AddonCategory create
   */
  export type AddonCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AddonCategory.
     */
    data: XOR<AddonCategoryCreateInput, AddonCategoryUncheckedCreateInput>
  }

  /**
   * AddonCategory createMany
   */
  export type AddonCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddonCategories.
     */
    data: AddonCategoryCreateManyInput | AddonCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddonCategory createManyAndReturn
   */
  export type AddonCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many AddonCategories.
     */
    data: AddonCategoryCreateManyInput | AddonCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddonCategory update
   */
  export type AddonCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AddonCategory.
     */
    data: XOR<AddonCategoryUpdateInput, AddonCategoryUncheckedUpdateInput>
    /**
     * Choose, which AddonCategory to update.
     */
    where: AddonCategoryWhereUniqueInput
  }

  /**
   * AddonCategory updateMany
   */
  export type AddonCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddonCategories.
     */
    data: XOR<AddonCategoryUpdateManyMutationInput, AddonCategoryUncheckedUpdateManyInput>
    /**
     * Filter which AddonCategories to update
     */
    where?: AddonCategoryWhereInput
    /**
     * Limit how many AddonCategories to update.
     */
    limit?: number
  }

  /**
   * AddonCategory updateManyAndReturn
   */
  export type AddonCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * The data used to update AddonCategories.
     */
    data: XOR<AddonCategoryUpdateManyMutationInput, AddonCategoryUncheckedUpdateManyInput>
    /**
     * Filter which AddonCategories to update
     */
    where?: AddonCategoryWhereInput
    /**
     * Limit how many AddonCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddonCategory upsert
   */
  export type AddonCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AddonCategory to update in case it exists.
     */
    where: AddonCategoryWhereUniqueInput
    /**
     * In case the AddonCategory found by the `where` argument doesn't exist, create a new AddonCategory with this data.
     */
    create: XOR<AddonCategoryCreateInput, AddonCategoryUncheckedCreateInput>
    /**
     * In case the AddonCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddonCategoryUpdateInput, AddonCategoryUncheckedUpdateInput>
  }

  /**
   * AddonCategory delete
   */
  export type AddonCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
    /**
     * Filter which AddonCategory to delete.
     */
    where: AddonCategoryWhereUniqueInput
  }

  /**
   * AddonCategory deleteMany
   */
  export type AddonCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddonCategories to delete
     */
    where?: AddonCategoryWhereInput
    /**
     * Limit how many AddonCategories to delete.
     */
    limit?: number
  }

  /**
   * AddonCategory.addons
   */
  export type AddonCategory$addonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    where?: AddonWhereInput
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    cursor?: AddonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * AddonCategory without action
   */
  export type AddonCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCategory
     */
    select?: AddonCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonCategory
     */
    omit?: AddonCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    total: number | null
    locationId: number | null
    CustomerId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    total: number | null
    locationId: number | null
    CustomerId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    total: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    locationId: number | null
    CustomerId: number | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    total: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    locationId: number | null
    CustomerId: number | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    total: number
    status: number
    createdAt: number
    updatedAt: number
    locationId: number
    CustomerId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    total?: true
    locationId?: true
    CustomerId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    total?: true
    locationId?: true
    CustomerId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    total?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    CustomerId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    total?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    CustomerId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    total?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    CustomerId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    total: number
    status: string
    createdAt: Date
    updatedAt: Date
    locationId: number
    CustomerId: number
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    CustomerId?: boolean
    items?: boolean | Order$itemsArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    CustomerId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    CustomerId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    total?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    CustomerId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "total" | "status" | "createdAt" | "updatedAt" | "locationId" | "CustomerId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Order$itemsArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs>
      Customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      total: number
      status: string
      createdAt: Date
      updatedAt: Date
      locationId: number
      CustomerId: number
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly total: FieldRef<"Order", 'Float'>
    readonly status: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly locationId: FieldRef<"Order", 'Int'>
    readonly CustomerId: FieldRef<"Order", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    phone: string
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    templateItemId: number | null
    variantId: number | null
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    templateItemId: number | null
    variantId: number | null
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    templateItemId: number | null
    variantId: number | null
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    templateItemId: number | null
    variantId: number | null
    quantity: number | null
    unitPrice: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    templateItemId: number
    variantId: number
    quantity: number
    unitPrice: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    templateItemId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    templateItemId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    templateItemId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    templateItemId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    templateItemId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    templateItemId: number
    variantId: number | null
    quantity: number
    unitPrice: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    templateItemId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    templateItemId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    templateItemId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    templateItemId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "templateItemId" | "variantId" | "quantity" | "unitPrice", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    templateItem?: boolean | TemplateItemDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      templateItem: Prisma.$TemplateItemPayload<ExtArgs>
      variant: Prisma.$TemplateItemVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      templateItemId: number
      variantId: number | null
      quantity: number
      unitPrice: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    templateItem<T extends TemplateItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateItemDefaultArgs<ExtArgs>>): Prisma__TemplateItemClient<$Result.GetResult<Prisma.$TemplateItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends OrderItem$variantArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$variantArgs<ExtArgs>>): Prisma__TemplateItemVariantClient<$Result.GetResult<Prisma.$TemplateItemVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly templateItemId: FieldRef<"OrderItem", 'Int'>
    readonly variantId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.variant
   */
  export type OrderItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateItemVariant
     */
    select?: TemplateItemVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateItemVariant
     */
    omit?: TemplateItemVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateItemVariantInclude<ExtArgs> | null
    where?: TemplateItemVariantWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    refreshToken: 'refreshToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    userId: 'userId'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    latitude: 'latitude',
    longitude: 'longitude',
    placeId: 'placeId',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    postalCode: 'postalCode',
    geohash: 'geohash',
    timezone: 'timezone',
    accuracy: 'accuracy',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    BrandId: 'BrandId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const LocationStaffScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    staffId: 'staffId'
  };

  export type LocationStaffScalarFieldEnum = (typeof LocationStaffScalarFieldEnum)[keyof typeof LocationStaffScalarFieldEnum]


  export const MenuTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brandId: 'brandId',
    createdAt: 'createdAt'
  };

  export type MenuTemplateScalarFieldEnum = (typeof MenuTemplateScalarFieldEnum)[keyof typeof MenuTemplateScalarFieldEnum]


  export const TemplateItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    category: 'category',
    templateId: 'templateId'
  };

  export type TemplateItemScalarFieldEnum = (typeof TemplateItemScalarFieldEnum)[keyof typeof TemplateItemScalarFieldEnum]


  export const TemplateItemVariantScalarFieldEnum: {
    id: 'id',
    label: 'label',
    price: 'price',
    itemId: 'itemId'
  };

  export type TemplateItemVariantScalarFieldEnum = (typeof TemplateItemVariantScalarFieldEnum)[keyof typeof TemplateItemVariantScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    templateId: 'templateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MenuItemOverrideScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    templateItemId: 'templateItemId',
    isAvailable: 'isAvailable',
    priceOverride: 'priceOverride'
  };

  export type MenuItemOverrideScalarFieldEnum = (typeof MenuItemOverrideScalarFieldEnum)[keyof typeof MenuItemOverrideScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TemplateItemTagScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    tagId: 'tagId'
  };

  export type TemplateItemTagScalarFieldEnum = (typeof TemplateItemTagScalarFieldEnum)[keyof typeof TemplateItemTagScalarFieldEnum]


  export const AddonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    categoryId: 'categoryId',
    templateId: 'templateId'
  };

  export type AddonScalarFieldEnum = (typeof AddonScalarFieldEnum)[keyof typeof AddonScalarFieldEnum]


  export const TemplateItemAddonScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    addonId: 'addonId'
  };

  export type TemplateItemAddonScalarFieldEnum = (typeof TemplateItemAddonScalarFieldEnum)[keyof typeof TemplateItemAddonScalarFieldEnum]


  export const AddonCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    maxSelectable: 'maxSelectable',
    isRequired: 'isRequired',
    templateId: 'templateId'
  };

  export type AddonCategoryScalarFieldEnum = (typeof AddonCategoryScalarFieldEnum)[keyof typeof AddonCategoryScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    total: 'total',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    locationId: 'locationId',
    CustomerId: 'CustomerId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    templateItemId: 'templateItemId',
    variantId: 'variantId',
    quantity: 'quantity',
    unitPrice: 'unitPrice'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    refreshToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Brand?: BrandListRelationFilter
    Location?: LocationListRelationFilter
    LocationStaff?: LocationStaffListRelationFilter
    UserProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Brand?: BrandOrderByRelationAggregateInput
    Location?: LocationOrderByRelationAggregateInput
    LocationStaff?: LocationStaffOrderByRelationAggregateInput
    UserProfile?: UserProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    refreshToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Brand?: BrandListRelationFilter
    Location?: LocationListRelationFilter
    LocationStaff?: LocationStaffListRelationFilter
    UserProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: IntFilter<"UserProfile"> | number
    firstName?: StringFilter<"UserProfile"> | string
    lastName?: StringFilter<"UserProfile"> | string
    phoneNumber?: StringNullableFilter<"UserProfile"> | string | null
    userId?: IntFilter<"UserProfile"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    firstName?: StringFilter<"UserProfile"> | string
    lastName?: StringFilter<"UserProfile"> | string
    phoneNumber?: StringNullableFilter<"UserProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserProfile"> | number
    firstName?: StringWithAggregatesFilter<"UserProfile"> | string
    lastName?: StringWithAggregatesFilter<"UserProfile"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    userId?: IntWithAggregatesFilter<"UserProfile"> | number
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringFilter<"Brand"> | string
    ownerId?: IntFilter<"Brand"> | number
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    Location?: LocationListRelationFilter
    MenuTemplate?: MenuTemplateListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    Location?: LocationOrderByRelationAggregateInput
    MenuTemplate?: MenuTemplateOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringFilter<"Brand"> | string
    ownerId?: IntFilter<"Brand"> | number
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    Location?: LocationListRelationFilter
    MenuTemplate?: MenuTemplateListRelationFilter
  }, "id">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brand"> | number
    name?: StringWithAggregatesFilter<"Brand"> | string
    ownerId?: IntWithAggregatesFilter<"Brand"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    placeId?: StringNullableFilter<"Location"> | string | null
    name?: StringNullableFilter<"Location"> | string | null
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    postalCode?: StringNullableFilter<"Location"> | string | null
    geohash?: StringNullableFilter<"Location"> | string | null
    timezone?: StringNullableFilter<"Location"> | string | null
    accuracy?: FloatNullableFilter<"Location"> | number | null
    managerId?: IntNullableFilter<"Location"> | number | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    BrandId?: IntFilter<"Location"> | number
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    LocationStaff?: LocationStaffListRelationFilter
    Menu?: MenuListRelationFilter
    Order?: OrderListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    placeId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    geohash?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BrandId?: SortOrder
    manager?: UserOrderByWithRelationInput
    Brand?: BrandOrderByWithRelationInput
    LocationStaff?: LocationStaffOrderByRelationAggregateInput
    Menu?: MenuOrderByRelationAggregateInput
    Order?: OrderOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    placeId?: StringNullableFilter<"Location"> | string | null
    name?: StringNullableFilter<"Location"> | string | null
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    postalCode?: StringNullableFilter<"Location"> | string | null
    geohash?: StringNullableFilter<"Location"> | string | null
    timezone?: StringNullableFilter<"Location"> | string | null
    accuracy?: FloatNullableFilter<"Location"> | number | null
    managerId?: IntNullableFilter<"Location"> | number | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    BrandId?: IntFilter<"Location"> | number
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    LocationStaff?: LocationStaffListRelationFilter
    Menu?: MenuListRelationFilter
    Order?: OrderListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    placeId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    geohash?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BrandId?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    latitude?: FloatWithAggregatesFilter<"Location"> | number
    longitude?: FloatWithAggregatesFilter<"Location"> | number
    placeId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    name?: StringNullableWithAggregatesFilter<"Location"> | string | null
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    city?: StringNullableWithAggregatesFilter<"Location"> | string | null
    state?: StringNullableWithAggregatesFilter<"Location"> | string | null
    country?: StringNullableWithAggregatesFilter<"Location"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Location"> | string | null
    geohash?: StringNullableWithAggregatesFilter<"Location"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"Location"> | string | null
    accuracy?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    managerId?: IntNullableWithAggregatesFilter<"Location"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    BrandId?: IntWithAggregatesFilter<"Location"> | number
  }

  export type LocationStaffWhereInput = {
    AND?: LocationStaffWhereInput | LocationStaffWhereInput[]
    OR?: LocationStaffWhereInput[]
    NOT?: LocationStaffWhereInput | LocationStaffWhereInput[]
    id?: IntFilter<"LocationStaff"> | number
    locationId?: IntFilter<"LocationStaff"> | number
    staffId?: IntFilter<"LocationStaff"> | number
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LocationStaffOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
    location?: LocationOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
  }

  export type LocationStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationStaffWhereInput | LocationStaffWhereInput[]
    OR?: LocationStaffWhereInput[]
    NOT?: LocationStaffWhereInput | LocationStaffWhereInput[]
    locationId?: IntFilter<"LocationStaff"> | number
    staffId?: IntFilter<"LocationStaff"> | number
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LocationStaffOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
    _count?: LocationStaffCountOrderByAggregateInput
    _avg?: LocationStaffAvgOrderByAggregateInput
    _max?: LocationStaffMaxOrderByAggregateInput
    _min?: LocationStaffMinOrderByAggregateInput
    _sum?: LocationStaffSumOrderByAggregateInput
  }

  export type LocationStaffScalarWhereWithAggregatesInput = {
    AND?: LocationStaffScalarWhereWithAggregatesInput | LocationStaffScalarWhereWithAggregatesInput[]
    OR?: LocationStaffScalarWhereWithAggregatesInput[]
    NOT?: LocationStaffScalarWhereWithAggregatesInput | LocationStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocationStaff"> | number
    locationId?: IntWithAggregatesFilter<"LocationStaff"> | number
    staffId?: IntWithAggregatesFilter<"LocationStaff"> | number
  }

  export type MenuTemplateWhereInput = {
    AND?: MenuTemplateWhereInput | MenuTemplateWhereInput[]
    OR?: MenuTemplateWhereInput[]
    NOT?: MenuTemplateWhereInput | MenuTemplateWhereInput[]
    id?: IntFilter<"MenuTemplate"> | number
    name?: StringFilter<"MenuTemplate"> | string
    brandId?: IntFilter<"MenuTemplate"> | number
    createdAt?: DateTimeFilter<"MenuTemplate"> | Date | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    items?: TemplateItemListRelationFilter
    Menu?: MenuListRelationFilter
    Addon?: AddonListRelationFilter
    AddonCategory?: AddonCategoryListRelationFilter
  }

  export type MenuTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    brand?: BrandOrderByWithRelationInput
    items?: TemplateItemOrderByRelationAggregateInput
    Menu?: MenuOrderByRelationAggregateInput
    Addon?: AddonOrderByRelationAggregateInput
    AddonCategory?: AddonCategoryOrderByRelationAggregateInput
  }

  export type MenuTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MenuTemplateWhereInput | MenuTemplateWhereInput[]
    OR?: MenuTemplateWhereInput[]
    NOT?: MenuTemplateWhereInput | MenuTemplateWhereInput[]
    name?: StringFilter<"MenuTemplate"> | string
    brandId?: IntFilter<"MenuTemplate"> | number
    createdAt?: DateTimeFilter<"MenuTemplate"> | Date | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    items?: TemplateItemListRelationFilter
    Menu?: MenuListRelationFilter
    Addon?: AddonListRelationFilter
    AddonCategory?: AddonCategoryListRelationFilter
  }, "id">

  export type MenuTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    _count?: MenuTemplateCountOrderByAggregateInput
    _avg?: MenuTemplateAvgOrderByAggregateInput
    _max?: MenuTemplateMaxOrderByAggregateInput
    _min?: MenuTemplateMinOrderByAggregateInput
    _sum?: MenuTemplateSumOrderByAggregateInput
  }

  export type MenuTemplateScalarWhereWithAggregatesInput = {
    AND?: MenuTemplateScalarWhereWithAggregatesInput | MenuTemplateScalarWhereWithAggregatesInput[]
    OR?: MenuTemplateScalarWhereWithAggregatesInput[]
    NOT?: MenuTemplateScalarWhereWithAggregatesInput | MenuTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MenuTemplate"> | number
    name?: StringWithAggregatesFilter<"MenuTemplate"> | string
    brandId?: IntWithAggregatesFilter<"MenuTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MenuTemplate"> | Date | string
  }

  export type TemplateItemWhereInput = {
    AND?: TemplateItemWhereInput | TemplateItemWhereInput[]
    OR?: TemplateItemWhereInput[]
    NOT?: TemplateItemWhereInput | TemplateItemWhereInput[]
    id?: IntFilter<"TemplateItem"> | number
    name?: StringFilter<"TemplateItem"> | string
    description?: StringNullableFilter<"TemplateItem"> | string | null
    imageUrl?: StringNullableFilter<"TemplateItem"> | string | null
    category?: StringNullableFilter<"TemplateItem"> | string | null
    templateId?: IntFilter<"TemplateItem"> | number
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    variants?: TemplateItemVariantListRelationFilter
    MenuItemOverride?: MenuItemOverrideListRelationFilter
    Tag?: TagListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    TemplateItemTag?: TemplateItemTagListRelationFilter
    TemplateItemAddon?: TemplateItemAddonListRelationFilter
  }

  export type TemplateItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    templateId?: SortOrder
    template?: MenuTemplateOrderByWithRelationInput
    variants?: TemplateItemVariantOrderByRelationAggregateInput
    MenuItemOverride?: MenuItemOverrideOrderByRelationAggregateInput
    Tag?: TagOrderByRelationAggregateInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
    TemplateItemTag?: TemplateItemTagOrderByRelationAggregateInput
    TemplateItemAddon?: TemplateItemAddonOrderByRelationAggregateInput
  }

  export type TemplateItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateItemWhereInput | TemplateItemWhereInput[]
    OR?: TemplateItemWhereInput[]
    NOT?: TemplateItemWhereInput | TemplateItemWhereInput[]
    name?: StringFilter<"TemplateItem"> | string
    description?: StringNullableFilter<"TemplateItem"> | string | null
    imageUrl?: StringNullableFilter<"TemplateItem"> | string | null
    category?: StringNullableFilter<"TemplateItem"> | string | null
    templateId?: IntFilter<"TemplateItem"> | number
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    variants?: TemplateItemVariantListRelationFilter
    MenuItemOverride?: MenuItemOverrideListRelationFilter
    Tag?: TagListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    TemplateItemTag?: TemplateItemTagListRelationFilter
    TemplateItemAddon?: TemplateItemAddonListRelationFilter
  }, "id">

  export type TemplateItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    templateId?: SortOrder
    _count?: TemplateItemCountOrderByAggregateInput
    _avg?: TemplateItemAvgOrderByAggregateInput
    _max?: TemplateItemMaxOrderByAggregateInput
    _min?: TemplateItemMinOrderByAggregateInput
    _sum?: TemplateItemSumOrderByAggregateInput
  }

  export type TemplateItemScalarWhereWithAggregatesInput = {
    AND?: TemplateItemScalarWhereWithAggregatesInput | TemplateItemScalarWhereWithAggregatesInput[]
    OR?: TemplateItemScalarWhereWithAggregatesInput[]
    NOT?: TemplateItemScalarWhereWithAggregatesInput | TemplateItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateItem"> | number
    name?: StringWithAggregatesFilter<"TemplateItem"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateItem"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"TemplateItem"> | string | null
    category?: StringNullableWithAggregatesFilter<"TemplateItem"> | string | null
    templateId?: IntWithAggregatesFilter<"TemplateItem"> | number
  }

  export type TemplateItemVariantWhereInput = {
    AND?: TemplateItemVariantWhereInput | TemplateItemVariantWhereInput[]
    OR?: TemplateItemVariantWhereInput[]
    NOT?: TemplateItemVariantWhereInput | TemplateItemVariantWhereInput[]
    id?: IntFilter<"TemplateItemVariant"> | number
    label?: StringFilter<"TemplateItemVariant"> | string
    price?: FloatFilter<"TemplateItemVariant"> | number
    itemId?: IntFilter<"TemplateItemVariant"> | number
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    OrderItem?: OrderItemListRelationFilter
  }

  export type TemplateItemVariantOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
    templateItem?: TemplateItemOrderByWithRelationInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
  }

  export type TemplateItemVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateItemVariantWhereInput | TemplateItemVariantWhereInput[]
    OR?: TemplateItemVariantWhereInput[]
    NOT?: TemplateItemVariantWhereInput | TemplateItemVariantWhereInput[]
    label?: StringFilter<"TemplateItemVariant"> | string
    price?: FloatFilter<"TemplateItemVariant"> | number
    itemId?: IntFilter<"TemplateItemVariant"> | number
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    OrderItem?: OrderItemListRelationFilter
  }, "id">

  export type TemplateItemVariantOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
    _count?: TemplateItemVariantCountOrderByAggregateInput
    _avg?: TemplateItemVariantAvgOrderByAggregateInput
    _max?: TemplateItemVariantMaxOrderByAggregateInput
    _min?: TemplateItemVariantMinOrderByAggregateInput
    _sum?: TemplateItemVariantSumOrderByAggregateInput
  }

  export type TemplateItemVariantScalarWhereWithAggregatesInput = {
    AND?: TemplateItemVariantScalarWhereWithAggregatesInput | TemplateItemVariantScalarWhereWithAggregatesInput[]
    OR?: TemplateItemVariantScalarWhereWithAggregatesInput[]
    NOT?: TemplateItemVariantScalarWhereWithAggregatesInput | TemplateItemVariantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateItemVariant"> | number
    label?: StringWithAggregatesFilter<"TemplateItemVariant"> | string
    price?: FloatWithAggregatesFilter<"TemplateItemVariant"> | number
    itemId?: IntWithAggregatesFilter<"TemplateItemVariant"> | number
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: IntFilter<"Menu"> | number
    locationId?: IntFilter<"Menu"> | number
    templateId?: IntFilter<"Menu"> | number
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    overrides?: MenuItemOverrideListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    template?: MenuTemplateOrderByWithRelationInput
    overrides?: MenuItemOverrideOrderByRelationAggregateInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    locationId?: number
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    templateId?: IntFilter<"Menu"> | number
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    overrides?: MenuItemOverrideListRelationFilter
  }, "id" | "locationId">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Menu"> | number
    locationId?: IntWithAggregatesFilter<"Menu"> | number
    templateId?: IntWithAggregatesFilter<"Menu"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
  }

  export type MenuItemOverrideWhereInput = {
    AND?: MenuItemOverrideWhereInput | MenuItemOverrideWhereInput[]
    OR?: MenuItemOverrideWhereInput[]
    NOT?: MenuItemOverrideWhereInput | MenuItemOverrideWhereInput[]
    id?: IntFilter<"MenuItemOverride"> | number
    menuId?: IntFilter<"MenuItemOverride"> | number
    templateItemId?: IntFilter<"MenuItemOverride"> | number
    isAvailable?: BoolNullableFilter<"MenuItemOverride"> | boolean | null
    priceOverride?: FloatNullableFilter<"MenuItemOverride"> | number | null
    menu?: XOR<MenuScalarRelationFilter, MenuWhereInput>
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
  }

  export type MenuItemOverrideOrderByWithRelationInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    isAvailable?: SortOrderInput | SortOrder
    priceOverride?: SortOrderInput | SortOrder
    menu?: MenuOrderByWithRelationInput
    templateItem?: TemplateItemOrderByWithRelationInput
  }

  export type MenuItemOverrideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MenuItemOverrideWhereInput | MenuItemOverrideWhereInput[]
    OR?: MenuItemOverrideWhereInput[]
    NOT?: MenuItemOverrideWhereInput | MenuItemOverrideWhereInput[]
    menuId?: IntFilter<"MenuItemOverride"> | number
    templateItemId?: IntFilter<"MenuItemOverride"> | number
    isAvailable?: BoolNullableFilter<"MenuItemOverride"> | boolean | null
    priceOverride?: FloatNullableFilter<"MenuItemOverride"> | number | null
    menu?: XOR<MenuScalarRelationFilter, MenuWhereInput>
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
  }, "id">

  export type MenuItemOverrideOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    isAvailable?: SortOrderInput | SortOrder
    priceOverride?: SortOrderInput | SortOrder
    _count?: MenuItemOverrideCountOrderByAggregateInput
    _avg?: MenuItemOverrideAvgOrderByAggregateInput
    _max?: MenuItemOverrideMaxOrderByAggregateInput
    _min?: MenuItemOverrideMinOrderByAggregateInput
    _sum?: MenuItemOverrideSumOrderByAggregateInput
  }

  export type MenuItemOverrideScalarWhereWithAggregatesInput = {
    AND?: MenuItemOverrideScalarWhereWithAggregatesInput | MenuItemOverrideScalarWhereWithAggregatesInput[]
    OR?: MenuItemOverrideScalarWhereWithAggregatesInput[]
    NOT?: MenuItemOverrideScalarWhereWithAggregatesInput | MenuItemOverrideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MenuItemOverride"> | number
    menuId?: IntWithAggregatesFilter<"MenuItemOverride"> | number
    templateItemId?: IntWithAggregatesFilter<"MenuItemOverride"> | number
    isAvailable?: BoolNullableWithAggregatesFilter<"MenuItemOverride"> | boolean | null
    priceOverride?: FloatNullableWithAggregatesFilter<"MenuItemOverride"> | number | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    items?: TemplateItemTagListRelationFilter
    TemplateItem?: TemplateItemListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    items?: TemplateItemTagOrderByRelationAggregateInput
    TemplateItem?: TemplateItemOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    items?: TemplateItemTagListRelationFilter
    TemplateItem?: TemplateItemListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type TemplateItemTagWhereInput = {
    AND?: TemplateItemTagWhereInput | TemplateItemTagWhereInput[]
    OR?: TemplateItemTagWhereInput[]
    NOT?: TemplateItemTagWhereInput | TemplateItemTagWhereInput[]
    id?: IntFilter<"TemplateItemTag"> | number
    itemId?: IntFilter<"TemplateItemTag"> | number
    tagId?: IntFilter<"TemplateItemTag"> | number
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type TemplateItemTagOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
    templateItem?: TemplateItemOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TemplateItemTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId_tagId?: TemplateItemTagItemIdTagIdCompoundUniqueInput
    AND?: TemplateItemTagWhereInput | TemplateItemTagWhereInput[]
    OR?: TemplateItemTagWhereInput[]
    NOT?: TemplateItemTagWhereInput | TemplateItemTagWhereInput[]
    itemId?: IntFilter<"TemplateItemTag"> | number
    tagId?: IntFilter<"TemplateItemTag"> | number
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "itemId_tagId">

  export type TemplateItemTagOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
    _count?: TemplateItemTagCountOrderByAggregateInput
    _avg?: TemplateItemTagAvgOrderByAggregateInput
    _max?: TemplateItemTagMaxOrderByAggregateInput
    _min?: TemplateItemTagMinOrderByAggregateInput
    _sum?: TemplateItemTagSumOrderByAggregateInput
  }

  export type TemplateItemTagScalarWhereWithAggregatesInput = {
    AND?: TemplateItemTagScalarWhereWithAggregatesInput | TemplateItemTagScalarWhereWithAggregatesInput[]
    OR?: TemplateItemTagScalarWhereWithAggregatesInput[]
    NOT?: TemplateItemTagScalarWhereWithAggregatesInput | TemplateItemTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateItemTag"> | number
    itemId?: IntWithAggregatesFilter<"TemplateItemTag"> | number
    tagId?: IntWithAggregatesFilter<"TemplateItemTag"> | number
  }

  export type AddonWhereInput = {
    AND?: AddonWhereInput | AddonWhereInput[]
    OR?: AddonWhereInput[]
    NOT?: AddonWhereInput | AddonWhereInput[]
    id?: IntFilter<"Addon"> | number
    name?: StringFilter<"Addon"> | string
    price?: FloatFilter<"Addon"> | number
    categoryId?: IntFilter<"Addon"> | number
    templateId?: IntFilter<"Addon"> | number
    category?: XOR<AddonCategoryScalarRelationFilter, AddonCategoryWhereInput>
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    items?: TemplateItemAddonListRelationFilter
  }

  export type AddonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
    category?: AddonCategoryOrderByWithRelationInput
    template?: MenuTemplateOrderByWithRelationInput
    items?: TemplateItemAddonOrderByRelationAggregateInput
  }

  export type AddonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddonWhereInput | AddonWhereInput[]
    OR?: AddonWhereInput[]
    NOT?: AddonWhereInput | AddonWhereInput[]
    name?: StringFilter<"Addon"> | string
    price?: FloatFilter<"Addon"> | number
    categoryId?: IntFilter<"Addon"> | number
    templateId?: IntFilter<"Addon"> | number
    category?: XOR<AddonCategoryScalarRelationFilter, AddonCategoryWhereInput>
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    items?: TemplateItemAddonListRelationFilter
  }, "id">

  export type AddonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
    _count?: AddonCountOrderByAggregateInput
    _avg?: AddonAvgOrderByAggregateInput
    _max?: AddonMaxOrderByAggregateInput
    _min?: AddonMinOrderByAggregateInput
    _sum?: AddonSumOrderByAggregateInput
  }

  export type AddonScalarWhereWithAggregatesInput = {
    AND?: AddonScalarWhereWithAggregatesInput | AddonScalarWhereWithAggregatesInput[]
    OR?: AddonScalarWhereWithAggregatesInput[]
    NOT?: AddonScalarWhereWithAggregatesInput | AddonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Addon"> | number
    name?: StringWithAggregatesFilter<"Addon"> | string
    price?: FloatWithAggregatesFilter<"Addon"> | number
    categoryId?: IntWithAggregatesFilter<"Addon"> | number
    templateId?: IntWithAggregatesFilter<"Addon"> | number
  }

  export type TemplateItemAddonWhereInput = {
    AND?: TemplateItemAddonWhereInput | TemplateItemAddonWhereInput[]
    OR?: TemplateItemAddonWhereInput[]
    NOT?: TemplateItemAddonWhereInput | TemplateItemAddonWhereInput[]
    id?: IntFilter<"TemplateItemAddon"> | number
    itemId?: IntFilter<"TemplateItemAddon"> | number
    addonId?: IntFilter<"TemplateItemAddon"> | number
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    addon?: XOR<AddonScalarRelationFilter, AddonWhereInput>
  }

  export type TemplateItemAddonOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
    templateItem?: TemplateItemOrderByWithRelationInput
    addon?: AddonOrderByWithRelationInput
  }

  export type TemplateItemAddonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId_addonId?: TemplateItemAddonItemIdAddonIdCompoundUniqueInput
    AND?: TemplateItemAddonWhereInput | TemplateItemAddonWhereInput[]
    OR?: TemplateItemAddonWhereInput[]
    NOT?: TemplateItemAddonWhereInput | TemplateItemAddonWhereInput[]
    itemId?: IntFilter<"TemplateItemAddon"> | number
    addonId?: IntFilter<"TemplateItemAddon"> | number
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    addon?: XOR<AddonScalarRelationFilter, AddonWhereInput>
  }, "id" | "itemId_addonId">

  export type TemplateItemAddonOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
    _count?: TemplateItemAddonCountOrderByAggregateInput
    _avg?: TemplateItemAddonAvgOrderByAggregateInput
    _max?: TemplateItemAddonMaxOrderByAggregateInput
    _min?: TemplateItemAddonMinOrderByAggregateInput
    _sum?: TemplateItemAddonSumOrderByAggregateInput
  }

  export type TemplateItemAddonScalarWhereWithAggregatesInput = {
    AND?: TemplateItemAddonScalarWhereWithAggregatesInput | TemplateItemAddonScalarWhereWithAggregatesInput[]
    OR?: TemplateItemAddonScalarWhereWithAggregatesInput[]
    NOT?: TemplateItemAddonScalarWhereWithAggregatesInput | TemplateItemAddonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateItemAddon"> | number
    itemId?: IntWithAggregatesFilter<"TemplateItemAddon"> | number
    addonId?: IntWithAggregatesFilter<"TemplateItemAddon"> | number
  }

  export type AddonCategoryWhereInput = {
    AND?: AddonCategoryWhereInput | AddonCategoryWhereInput[]
    OR?: AddonCategoryWhereInput[]
    NOT?: AddonCategoryWhereInput | AddonCategoryWhereInput[]
    id?: IntFilter<"AddonCategory"> | number
    name?: StringFilter<"AddonCategory"> | string
    maxSelectable?: IntFilter<"AddonCategory"> | number
    isRequired?: BoolFilter<"AddonCategory"> | boolean
    templateId?: IntFilter<"AddonCategory"> | number
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    addons?: AddonListRelationFilter
  }

  export type AddonCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    maxSelectable?: SortOrder
    isRequired?: SortOrder
    templateId?: SortOrder
    template?: MenuTemplateOrderByWithRelationInput
    addons?: AddonOrderByRelationAggregateInput
  }

  export type AddonCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddonCategoryWhereInput | AddonCategoryWhereInput[]
    OR?: AddonCategoryWhereInput[]
    NOT?: AddonCategoryWhereInput | AddonCategoryWhereInput[]
    name?: StringFilter<"AddonCategory"> | string
    maxSelectable?: IntFilter<"AddonCategory"> | number
    isRequired?: BoolFilter<"AddonCategory"> | boolean
    templateId?: IntFilter<"AddonCategory"> | number
    template?: XOR<MenuTemplateScalarRelationFilter, MenuTemplateWhereInput>
    addons?: AddonListRelationFilter
  }, "id">

  export type AddonCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    maxSelectable?: SortOrder
    isRequired?: SortOrder
    templateId?: SortOrder
    _count?: AddonCategoryCountOrderByAggregateInput
    _avg?: AddonCategoryAvgOrderByAggregateInput
    _max?: AddonCategoryMaxOrderByAggregateInput
    _min?: AddonCategoryMinOrderByAggregateInput
    _sum?: AddonCategorySumOrderByAggregateInput
  }

  export type AddonCategoryScalarWhereWithAggregatesInput = {
    AND?: AddonCategoryScalarWhereWithAggregatesInput | AddonCategoryScalarWhereWithAggregatesInput[]
    OR?: AddonCategoryScalarWhereWithAggregatesInput[]
    NOT?: AddonCategoryScalarWhereWithAggregatesInput | AddonCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddonCategory"> | number
    name?: StringWithAggregatesFilter<"AddonCategory"> | string
    maxSelectable?: IntWithAggregatesFilter<"AddonCategory"> | number
    isRequired?: BoolWithAggregatesFilter<"AddonCategory"> | boolean
    templateId?: IntWithAggregatesFilter<"AddonCategory"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    locationId?: IntFilter<"Order"> | number
    CustomerId?: IntFilter<"Order"> | number
    items?: OrderItemListRelationFilter
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    Customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
    items?: OrderItemOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
    Customer?: CustomerOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    total?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    locationId?: IntFilter<"Order"> | number
    CustomerId?: IntFilter<"Order"> | number
    items?: OrderItemListRelationFilter
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    Customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    total?: FloatWithAggregatesFilter<"Order"> | number
    status?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    locationId?: IntWithAggregatesFilter<"Order"> | number
    CustomerId?: IntWithAggregatesFilter<"Order"> | number
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    orders?: OrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    orders?: OrderListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    templateItemId?: IntFilter<"OrderItem"> | number
    variantId?: IntNullableFilter<"OrderItem"> | number | null
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    variant?: XOR<TemplateItemVariantNullableScalarRelationFilter, TemplateItemVariantWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    order?: OrderOrderByWithRelationInput
    templateItem?: TemplateItemOrderByWithRelationInput
    variant?: TemplateItemVariantOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    templateItemId?: IntFilter<"OrderItem"> | number
    variantId?: IntNullableFilter<"OrderItem"> | number | null
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    templateItem?: XOR<TemplateItemScalarRelationFilter, TemplateItemWhereInput>
    variant?: XOR<TemplateItemVariantNullableScalarRelationFilter, TemplateItemVariantWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    templateItemId?: IntWithAggregatesFilter<"OrderItem"> | number
    variantId?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
  }

  export type UserCreateInput = {
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandCreateNestedManyWithoutOwnerInput
    Location?: LocationCreateNestedManyWithoutManagerInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutStaffInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandUncheckedCreateNestedManyWithoutOwnerInput
    Location?: LocationUncheckedCreateNestedManyWithoutManagerInput
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutStaffInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUpdateManyWithoutOwnerNestedInput
    Location?: LocationUpdateManyWithoutManagerNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutStaffNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUncheckedUpdateManyWithoutOwnerNestedInput
    Location?: LocationUncheckedUpdateManyWithoutManagerNestedInput
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutStaffNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    firstName: string
    lastName: string
    phoneNumber?: string | null
    user: UserCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    phoneNumber?: string | null
    userId: number
  }

  export type UserProfileUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserProfileCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    phoneNumber?: string | null
    userId: number
  }

  export type UserProfileUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BrandCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBrandInput
    Location?: LocationCreateNestedManyWithoutBrandInput
    MenuTemplate?: MenuTemplateCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: number
    name: string
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationUncheckedCreateNestedManyWithoutBrandInput
    MenuTemplate?: MenuTemplateUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBrandNestedInput
    Location?: LocationUpdateManyWithoutBrandNestedInput
    MenuTemplate?: MenuTemplateUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUncheckedUpdateManyWithoutBrandNestedInput
    MenuTemplate?: MenuTemplateUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: number
    name: string
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutLocationInput
    Brand: BrandCreateNestedOneWithoutLocationInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutLocationInput
    Menu?: MenuCreateNestedManyWithoutLocationInput
    Order?: OrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutLocationInput
    Menu?: MenuUncheckedCreateNestedManyWithoutLocationInput
    Order?: OrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutLocationNestedInput
    Brand?: BrandUpdateOneRequiredWithoutLocationNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutLocationNestedInput
    Menu?: MenuUpdateManyWithoutLocationNestedInput
    Order?: OrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutLocationNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    Order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
  }

  export type LocationUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationStaffCreateInput = {
    location: LocationCreateNestedOneWithoutLocationStaffInput
    staff: UserCreateNestedOneWithoutLocationStaffInput
  }

  export type LocationStaffUncheckedCreateInput = {
    id?: number
    locationId: number
    staffId: number
  }

  export type LocationStaffUpdateInput = {
    location?: LocationUpdateOneRequiredWithoutLocationStaffNestedInput
    staff?: UserUpdateOneRequiredWithoutLocationStaffNestedInput
  }

  export type LocationStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationStaffCreateManyInput = {
    id?: number
    locationId: number
    staffId: number
  }

  export type LocationStaffUpdateManyMutationInput = {

  }

  export type LocationStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuTemplateCreateInput = {
    name: string
    createdAt?: Date | string
    brand: BrandCreateNestedOneWithoutMenuTemplateInput
    items?: TemplateItemCreateNestedManyWithoutTemplateInput
    Menu?: MenuCreateNestedManyWithoutTemplateInput
    Addon?: AddonCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUncheckedCreateInput = {
    id?: number
    name: string
    brandId: number
    createdAt?: Date | string
    items?: TemplateItemUncheckedCreateNestedManyWithoutTemplateInput
    Menu?: MenuUncheckedCreateNestedManyWithoutTemplateInput
    Addon?: AddonUncheckedCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutMenuTemplateNestedInput
    items?: TemplateItemUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateItemUncheckedUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUncheckedUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateCreateManyInput = {
    id?: number
    name: string
    brandId: number
    createdAt?: Date | string
  }

  export type MenuTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateItemCreateInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
  }

  export type TemplateItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemVariantCreateInput = {
    label: string
    price: number
    templateItem: TemplateItemCreateNestedOneWithoutVariantsInput
    OrderItem?: OrderItemCreateNestedManyWithoutVariantInput
  }

  export type TemplateItemVariantUncheckedCreateInput = {
    id?: number
    label: string
    price: number
    itemId: number
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type TemplateItemVariantUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    templateItem?: TemplateItemUpdateOneRequiredWithoutVariantsNestedInput
    OrderItem?: OrderItemUpdateManyWithoutVariantNestedInput
  }

  export type TemplateItemVariantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    OrderItem?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type TemplateItemVariantCreateManyInput = {
    id?: number
    label: string
    price: number
    itemId: number
  }

  export type TemplateItemVariantUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type TemplateItemVariantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutMenuInput
    template: MenuTemplateCreateNestedOneWithoutMenuInput
    overrides?: MenuItemOverrideCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    locationId: number
    templateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: MenuItemOverrideUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutMenuNestedInput
    template?: MenuTemplateUpdateOneRequiredWithoutMenuNestedInput
    overrides?: MenuItemOverrideUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: MenuItemOverrideUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuCreateManyInput = {
    id?: number
    locationId: number
    templateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemOverrideCreateInput = {
    isAvailable?: boolean | null
    priceOverride?: number | null
    menu: MenuCreateNestedOneWithoutOverridesInput
    templateItem: TemplateItemCreateNestedOneWithoutMenuItemOverrideInput
  }

  export type MenuItemOverrideUncheckedCreateInput = {
    id?: number
    menuId: number
    templateItemId: number
    isAvailable?: boolean | null
    priceOverride?: number | null
  }

  export type MenuItemOverrideUpdateInput = {
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    menu?: MenuUpdateOneRequiredWithoutOverridesNestedInput
    templateItem?: TemplateItemUpdateOneRequiredWithoutMenuItemOverrideNestedInput
  }

  export type MenuItemOverrideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MenuItemOverrideCreateManyInput = {
    id?: number
    menuId: number
    templateItemId: number
    isAvailable?: boolean | null
    priceOverride?: number | null
  }

  export type MenuItemOverrideUpdateManyMutationInput = {
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MenuItemOverrideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TagCreateInput = {
    name: string
    items?: TemplateItemTagCreateNestedManyWithoutTagInput
    TemplateItem?: TemplateItemCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    items?: TemplateItemTagUncheckedCreateNestedManyWithoutTagInput
    TemplateItem?: TemplateItemUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: TemplateItemTagUpdateManyWithoutTagNestedInput
    TemplateItem?: TemplateItemUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    items?: TemplateItemTagUncheckedUpdateManyWithoutTagNestedInput
    TemplateItem?: TemplateItemUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateItemTagCreateInput = {
    templateItem: TemplateItemCreateNestedOneWithoutTemplateItemTagInput
    tag: TagCreateNestedOneWithoutItemsInput
  }

  export type TemplateItemTagUncheckedCreateInput = {
    id?: number
    itemId: number
    tagId: number
  }

  export type TemplateItemTagUpdateInput = {
    templateItem?: TemplateItemUpdateOneRequiredWithoutTemplateItemTagNestedInput
    tag?: TagUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateItemTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemTagCreateManyInput = {
    id?: number
    itemId: number
    tagId: number
  }

  export type TemplateItemTagUpdateManyMutationInput = {

  }

  export type TemplateItemTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type AddonCreateInput = {
    name: string
    price: number
    category: AddonCategoryCreateNestedOneWithoutAddonsInput
    template: MenuTemplateCreateNestedOneWithoutAddonInput
    items?: TemplateItemAddonCreateNestedManyWithoutAddonInput
  }

  export type AddonUncheckedCreateInput = {
    id?: number
    name: string
    price: number
    categoryId: number
    templateId: number
    items?: TemplateItemAddonUncheckedCreateNestedManyWithoutAddonInput
  }

  export type AddonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: AddonCategoryUpdateOneRequiredWithoutAddonsNestedInput
    template?: MenuTemplateUpdateOneRequiredWithoutAddonNestedInput
    items?: TemplateItemAddonUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    items?: TemplateItemAddonUncheckedUpdateManyWithoutAddonNestedInput
  }

  export type AddonCreateManyInput = {
    id?: number
    name: string
    price: number
    categoryId: number
    templateId: number
  }

  export type AddonUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type AddonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemAddonCreateInput = {
    templateItem: TemplateItemCreateNestedOneWithoutTemplateItemAddonInput
    addon: AddonCreateNestedOneWithoutItemsInput
  }

  export type TemplateItemAddonUncheckedCreateInput = {
    id?: number
    itemId: number
    addonId: number
  }

  export type TemplateItemAddonUpdateInput = {
    templateItem?: TemplateItemUpdateOneRequiredWithoutTemplateItemAddonNestedInput
    addon?: AddonUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateItemAddonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    addonId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemAddonCreateManyInput = {
    id?: number
    itemId: number
    addonId: number
  }

  export type TemplateItemAddonUpdateManyMutationInput = {

  }

  export type TemplateItemAddonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    addonId?: IntFieldUpdateOperationsInput | number
  }

  export type AddonCategoryCreateInput = {
    name: string
    maxSelectable?: number
    isRequired?: boolean
    template: MenuTemplateCreateNestedOneWithoutAddonCategoryInput
    addons?: AddonCreateNestedManyWithoutCategoryInput
  }

  export type AddonCategoryUncheckedCreateInput = {
    id?: number
    name: string
    maxSelectable?: number
    isRequired?: boolean
    templateId: number
    addons?: AddonUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AddonCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    template?: MenuTemplateUpdateOneRequiredWithoutAddonCategoryNestedInput
    addons?: AddonUpdateManyWithoutCategoryNestedInput
  }

  export type AddonCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    templateId?: IntFieldUpdateOperationsInput | number
    addons?: AddonUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AddonCategoryCreateManyInput = {
    id?: number
    name: string
    maxSelectable?: number
    isRequired?: boolean
    templateId: number
  }

  export type AddonCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AddonCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    location: LocationCreateNestedOneWithoutOrderInput
    Customer: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: number
    CustomerId: number
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    location?: LocationUpdateOneRequiredWithoutOrderNestedInput
    Customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    CustomerId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: number
    CustomerId: number
  }

  export type OrderUpdateManyMutationInput = {
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    CustomerId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerCreateInput = {
    name: string
    phone: string
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    phone: string
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemCreateInput = {
    quantity: number
    unitPrice: number
    order: OrderCreateNestedOneWithoutItemsInput
    templateItem: TemplateItemCreateNestedOneWithoutOrderItemInput
    variant?: TemplateItemVariantCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    templateItemId: number
    variantId?: number | null
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    templateItem?: TemplateItemUpdateOneRequiredWithoutOrderItemNestedInput
    variant?: TemplateItemVariantUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    variantId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    templateItemId: number
    variantId?: number | null
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    variantId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BrandListRelationFilter = {
    every?: BrandWhereInput
    some?: BrandWhereInput
    none?: BrandWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type LocationStaffListRelationFilter = {
    every?: LocationStaffWhereInput
    some?: LocationStaffWhereInput
    none?: LocationStaffWhereInput
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MenuTemplateListRelationFilter = {
    every?: MenuTemplateWhereInput
    some?: MenuTemplateWhereInput
    none?: MenuTemplateWhereInput
  }

  export type MenuTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BrandScalarRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    placeId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    geohash?: SortOrder
    timezone?: SortOrder
    accuracy?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BrandId?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    managerId?: SortOrder
    BrandId?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    placeId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    geohash?: SortOrder
    timezone?: SortOrder
    accuracy?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BrandId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    placeId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    geohash?: SortOrder
    timezone?: SortOrder
    accuracy?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BrandId?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    managerId?: SortOrder
    BrandId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type LocationStaffCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
  }

  export type LocationStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
  }

  export type LocationStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
  }

  export type LocationStaffMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
  }

  export type LocationStaffSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    staffId?: SortOrder
  }

  export type TemplateItemListRelationFilter = {
    every?: TemplateItemWhereInput
    some?: TemplateItemWhereInput
    none?: TemplateItemWhereInput
  }

  export type AddonListRelationFilter = {
    every?: AddonWhereInput
    some?: AddonWhereInput
    none?: AddonWhereInput
  }

  export type AddonCategoryListRelationFilter = {
    every?: AddonCategoryWhereInput
    some?: AddonCategoryWhereInput
    none?: AddonCategoryWhereInput
  }

  export type TemplateItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddonCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type MenuTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
  }

  export type MenuTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type MenuTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type MenuTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
  }

  export type MenuTemplateScalarRelationFilter = {
    is?: MenuTemplateWhereInput
    isNot?: MenuTemplateWhereInput
  }

  export type TemplateItemVariantListRelationFilter = {
    every?: TemplateItemVariantWhereInput
    some?: TemplateItemVariantWhereInput
    none?: TemplateItemVariantWhereInput
  }

  export type MenuItemOverrideListRelationFilter = {
    every?: MenuItemOverrideWhereInput
    some?: MenuItemOverrideWhereInput
    none?: MenuItemOverrideWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type TemplateItemTagListRelationFilter = {
    every?: TemplateItemTagWhereInput
    some?: TemplateItemTagWhereInput
    none?: TemplateItemTagWhereInput
  }

  export type TemplateItemAddonListRelationFilter = {
    every?: TemplateItemAddonWhereInput
    some?: TemplateItemAddonWhereInput
    none?: TemplateItemAddonWhereInput
  }

  export type TemplateItemVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateItemTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateItemAddonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateItemAvgOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateItemSumOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateItemScalarRelationFilter = {
    is?: TemplateItemWhereInput
    isNot?: TemplateItemWhereInput
  }

  export type TemplateItemVariantCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
  }

  export type TemplateItemVariantAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
  }

  export type TemplateItemVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
  }

  export type TemplateItemVariantMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
  }

  export type TemplateItemVariantSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    itemId?: SortOrder
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    templateId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type MenuScalarRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type MenuItemOverrideCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    isAvailable?: SortOrder
    priceOverride?: SortOrder
  }

  export type MenuItemOverrideAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    priceOverride?: SortOrder
  }

  export type MenuItemOverrideMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    isAvailable?: SortOrder
    priceOverride?: SortOrder
  }

  export type MenuItemOverrideMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    isAvailable?: SortOrder
    priceOverride?: SortOrder
  }

  export type MenuItemOverrideSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    templateItemId?: SortOrder
    priceOverride?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TemplateItemTagItemIdTagIdCompoundUniqueInput = {
    itemId: number
    tagId: number
  }

  export type TemplateItemTagCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
  }

  export type TemplateItemTagAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
  }

  export type TemplateItemTagMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
  }

  export type TemplateItemTagMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
  }

  export type TemplateItemTagSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    tagId?: SortOrder
  }

  export type AddonCategoryScalarRelationFilter = {
    is?: AddonCategoryWhereInput
    isNot?: AddonCategoryWhereInput
  }

  export type AddonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
  }

  export type AddonAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
  }

  export type AddonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
  }

  export type AddonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
  }

  export type AddonSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    templateId?: SortOrder
  }

  export type AddonScalarRelationFilter = {
    is?: AddonWhereInput
    isNot?: AddonWhereInput
  }

  export type TemplateItemAddonItemIdAddonIdCompoundUniqueInput = {
    itemId: number
    addonId: number
  }

  export type TemplateItemAddonCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
  }

  export type TemplateItemAddonAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
  }

  export type TemplateItemAddonMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
  }

  export type TemplateItemAddonMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
  }

  export type TemplateItemAddonSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    addonId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AddonCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxSelectable?: SortOrder
    isRequired?: SortOrder
    templateId?: SortOrder
  }

  export type AddonCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    maxSelectable?: SortOrder
    templateId?: SortOrder
  }

  export type AddonCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxSelectable?: SortOrder
    isRequired?: SortOrder
    templateId?: SortOrder
  }

  export type AddonCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxSelectable?: SortOrder
    isRequired?: SortOrder
    templateId?: SortOrder
  }

  export type AddonCategorySumOrderByAggregateInput = {
    id?: SortOrder
    maxSelectable?: SortOrder
    templateId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    locationId?: SortOrder
    CustomerId?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type TemplateItemVariantNullableScalarRelationFilter = {
    is?: TemplateItemVariantWhereInput | null
    isNot?: TemplateItemVariantWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    templateItemId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type BrandCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BrandCreateWithoutOwnerInput, BrandUncheckedCreateWithoutOwnerInput> | BrandCreateWithoutOwnerInput[] | BrandUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutOwnerInput | BrandCreateOrConnectWithoutOwnerInput[]
    createMany?: BrandCreateManyOwnerInputEnvelope
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutManagerInput = {
    create?: XOR<LocationCreateWithoutManagerInput, LocationUncheckedCreateWithoutManagerInput> | LocationCreateWithoutManagerInput[] | LocationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutManagerInput | LocationCreateOrConnectWithoutManagerInput[]
    createMany?: LocationCreateManyManagerInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationStaffCreateNestedManyWithoutStaffInput = {
    create?: XOR<LocationStaffCreateWithoutStaffInput, LocationStaffUncheckedCreateWithoutStaffInput> | LocationStaffCreateWithoutStaffInput[] | LocationStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutStaffInput | LocationStaffCreateOrConnectWithoutStaffInput[]
    createMany?: LocationStaffCreateManyStaffInputEnvelope
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type BrandUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BrandCreateWithoutOwnerInput, BrandUncheckedCreateWithoutOwnerInput> | BrandCreateWithoutOwnerInput[] | BrandUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutOwnerInput | BrandCreateOrConnectWithoutOwnerInput[]
    createMany?: BrandCreateManyOwnerInputEnvelope
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<LocationCreateWithoutManagerInput, LocationUncheckedCreateWithoutManagerInput> | LocationCreateWithoutManagerInput[] | LocationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutManagerInput | LocationCreateOrConnectWithoutManagerInput[]
    createMany?: LocationCreateManyManagerInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationStaffUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<LocationStaffCreateWithoutStaffInput, LocationStaffUncheckedCreateWithoutStaffInput> | LocationStaffCreateWithoutStaffInput[] | LocationStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutStaffInput | LocationStaffCreateOrConnectWithoutStaffInput[]
    createMany?: LocationStaffCreateManyStaffInputEnvelope
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BrandUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BrandCreateWithoutOwnerInput, BrandUncheckedCreateWithoutOwnerInput> | BrandCreateWithoutOwnerInput[] | BrandUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutOwnerInput | BrandCreateOrConnectWithoutOwnerInput[]
    upsert?: BrandUpsertWithWhereUniqueWithoutOwnerInput | BrandUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BrandCreateManyOwnerInputEnvelope
    set?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    disconnect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    delete?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    update?: BrandUpdateWithWhereUniqueWithoutOwnerInput | BrandUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BrandUpdateManyWithWhereWithoutOwnerInput | BrandUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BrandScalarWhereInput | BrandScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LocationCreateWithoutManagerInput, LocationUncheckedCreateWithoutManagerInput> | LocationCreateWithoutManagerInput[] | LocationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutManagerInput | LocationCreateOrConnectWithoutManagerInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutManagerInput | LocationUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LocationCreateManyManagerInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutManagerInput | LocationUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutManagerInput | LocationUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type LocationStaffUpdateManyWithoutStaffNestedInput = {
    create?: XOR<LocationStaffCreateWithoutStaffInput, LocationStaffUncheckedCreateWithoutStaffInput> | LocationStaffCreateWithoutStaffInput[] | LocationStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutStaffInput | LocationStaffCreateOrConnectWithoutStaffInput[]
    upsert?: LocationStaffUpsertWithWhereUniqueWithoutStaffInput | LocationStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: LocationStaffCreateManyStaffInputEnvelope
    set?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    disconnect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    delete?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    update?: LocationStaffUpdateWithWhereUniqueWithoutStaffInput | LocationStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: LocationStaffUpdateManyWithWhereWithoutStaffInput | LocationStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: LocationStaffScalarWhereInput | LocationStaffScalarWhereInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BrandUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BrandCreateWithoutOwnerInput, BrandUncheckedCreateWithoutOwnerInput> | BrandCreateWithoutOwnerInput[] | BrandUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutOwnerInput | BrandCreateOrConnectWithoutOwnerInput[]
    upsert?: BrandUpsertWithWhereUniqueWithoutOwnerInput | BrandUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BrandCreateManyOwnerInputEnvelope
    set?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    disconnect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    delete?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    update?: BrandUpdateWithWhereUniqueWithoutOwnerInput | BrandUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BrandUpdateManyWithWhereWithoutOwnerInput | BrandUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BrandScalarWhereInput | BrandScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LocationCreateWithoutManagerInput, LocationUncheckedCreateWithoutManagerInput> | LocationCreateWithoutManagerInput[] | LocationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutManagerInput | LocationCreateOrConnectWithoutManagerInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutManagerInput | LocationUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LocationCreateManyManagerInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutManagerInput | LocationUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutManagerInput | LocationUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type LocationStaffUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<LocationStaffCreateWithoutStaffInput, LocationStaffUncheckedCreateWithoutStaffInput> | LocationStaffCreateWithoutStaffInput[] | LocationStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutStaffInput | LocationStaffCreateOrConnectWithoutStaffInput[]
    upsert?: LocationStaffUpsertWithWhereUniqueWithoutStaffInput | LocationStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: LocationStaffCreateManyStaffInputEnvelope
    set?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    disconnect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    delete?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    update?: LocationStaffUpdateWithWhereUniqueWithoutStaffInput | LocationStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: LocationStaffUpdateManyWithWhereWithoutStaffInput | LocationStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: LocationStaffScalarWhereInput | LocationStaffScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    upsert?: UserUpsertWithoutUserProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProfileInput, UserUpdateWithoutUserProfileInput>, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserCreateNestedOneWithoutBrandInput = {
    create?: XOR<UserCreateWithoutBrandInput, UserUncheckedCreateWithoutBrandInput>
    connectOrCreate?: UserCreateOrConnectWithoutBrandInput
    connect?: UserWhereUniqueInput
  }

  export type LocationCreateNestedManyWithoutBrandInput = {
    create?: XOR<LocationCreateWithoutBrandInput, LocationUncheckedCreateWithoutBrandInput> | LocationCreateWithoutBrandInput[] | LocationUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutBrandInput | LocationCreateOrConnectWithoutBrandInput[]
    createMany?: LocationCreateManyBrandInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type MenuTemplateCreateNestedManyWithoutBrandInput = {
    create?: XOR<MenuTemplateCreateWithoutBrandInput, MenuTemplateUncheckedCreateWithoutBrandInput> | MenuTemplateCreateWithoutBrandInput[] | MenuTemplateUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutBrandInput | MenuTemplateCreateOrConnectWithoutBrandInput[]
    createMany?: MenuTemplateCreateManyBrandInputEnvelope
    connect?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<LocationCreateWithoutBrandInput, LocationUncheckedCreateWithoutBrandInput> | LocationCreateWithoutBrandInput[] | LocationUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutBrandInput | LocationCreateOrConnectWithoutBrandInput[]
    createMany?: LocationCreateManyBrandInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type MenuTemplateUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<MenuTemplateCreateWithoutBrandInput, MenuTemplateUncheckedCreateWithoutBrandInput> | MenuTemplateCreateWithoutBrandInput[] | MenuTemplateUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutBrandInput | MenuTemplateCreateOrConnectWithoutBrandInput[]
    createMany?: MenuTemplateCreateManyBrandInputEnvelope
    connect?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBrandNestedInput = {
    create?: XOR<UserCreateWithoutBrandInput, UserUncheckedCreateWithoutBrandInput>
    connectOrCreate?: UserCreateOrConnectWithoutBrandInput
    upsert?: UserUpsertWithoutBrandInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBrandInput, UserUpdateWithoutBrandInput>, UserUncheckedUpdateWithoutBrandInput>
  }

  export type LocationUpdateManyWithoutBrandNestedInput = {
    create?: XOR<LocationCreateWithoutBrandInput, LocationUncheckedCreateWithoutBrandInput> | LocationCreateWithoutBrandInput[] | LocationUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutBrandInput | LocationCreateOrConnectWithoutBrandInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutBrandInput | LocationUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: LocationCreateManyBrandInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutBrandInput | LocationUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutBrandInput | LocationUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MenuTemplateUpdateManyWithoutBrandNestedInput = {
    create?: XOR<MenuTemplateCreateWithoutBrandInput, MenuTemplateUncheckedCreateWithoutBrandInput> | MenuTemplateCreateWithoutBrandInput[] | MenuTemplateUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutBrandInput | MenuTemplateCreateOrConnectWithoutBrandInput[]
    upsert?: MenuTemplateUpsertWithWhereUniqueWithoutBrandInput | MenuTemplateUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: MenuTemplateCreateManyBrandInputEnvelope
    set?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    disconnect?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    delete?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    connect?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    update?: MenuTemplateUpdateWithWhereUniqueWithoutBrandInput | MenuTemplateUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: MenuTemplateUpdateManyWithWhereWithoutBrandInput | MenuTemplateUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: MenuTemplateScalarWhereInput | MenuTemplateScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<LocationCreateWithoutBrandInput, LocationUncheckedCreateWithoutBrandInput> | LocationCreateWithoutBrandInput[] | LocationUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutBrandInput | LocationCreateOrConnectWithoutBrandInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutBrandInput | LocationUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: LocationCreateManyBrandInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutBrandInput | LocationUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutBrandInput | LocationUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MenuTemplateUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<MenuTemplateCreateWithoutBrandInput, MenuTemplateUncheckedCreateWithoutBrandInput> | MenuTemplateCreateWithoutBrandInput[] | MenuTemplateUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutBrandInput | MenuTemplateCreateOrConnectWithoutBrandInput[]
    upsert?: MenuTemplateUpsertWithWhereUniqueWithoutBrandInput | MenuTemplateUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: MenuTemplateCreateManyBrandInputEnvelope
    set?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    disconnect?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    delete?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    connect?: MenuTemplateWhereUniqueInput | MenuTemplateWhereUniqueInput[]
    update?: MenuTemplateUpdateWithWhereUniqueWithoutBrandInput | MenuTemplateUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: MenuTemplateUpdateManyWithWhereWithoutBrandInput | MenuTemplateUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: MenuTemplateScalarWhereInput | MenuTemplateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput
    connect?: UserWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutLocationInput = {
    create?: XOR<BrandCreateWithoutLocationInput, BrandUncheckedCreateWithoutLocationInput>
    connectOrCreate?: BrandCreateOrConnectWithoutLocationInput
    connect?: BrandWhereUniqueInput
  }

  export type LocationStaffCreateNestedManyWithoutLocationInput = {
    create?: XOR<LocationStaffCreateWithoutLocationInput, LocationStaffUncheckedCreateWithoutLocationInput> | LocationStaffCreateWithoutLocationInput[] | LocationStaffUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutLocationInput | LocationStaffCreateOrConnectWithoutLocationInput[]
    createMany?: LocationStaffCreateManyLocationInputEnvelope
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
  }

  export type MenuCreateNestedManyWithoutLocationInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type LocationStaffUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<LocationStaffCreateWithoutLocationInput, LocationStaffUncheckedCreateWithoutLocationInput> | LocationStaffCreateWithoutLocationInput[] | LocationStaffUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutLocationInput | LocationStaffCreateOrConnectWithoutLocationInput[]
    createMany?: LocationStaffCreateManyLocationInputEnvelope
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput
    upsert?: UserUpsertWithoutLocationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLocationInput, UserUpdateWithoutLocationInput>, UserUncheckedUpdateWithoutLocationInput>
  }

  export type BrandUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<BrandCreateWithoutLocationInput, BrandUncheckedCreateWithoutLocationInput>
    connectOrCreate?: BrandCreateOrConnectWithoutLocationInput
    upsert?: BrandUpsertWithoutLocationInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutLocationInput, BrandUpdateWithoutLocationInput>, BrandUncheckedUpdateWithoutLocationInput>
  }

  export type LocationStaffUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LocationStaffCreateWithoutLocationInput, LocationStaffUncheckedCreateWithoutLocationInput> | LocationStaffCreateWithoutLocationInput[] | LocationStaffUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutLocationInput | LocationStaffCreateOrConnectWithoutLocationInput[]
    upsert?: LocationStaffUpsertWithWhereUniqueWithoutLocationInput | LocationStaffUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LocationStaffCreateManyLocationInputEnvelope
    set?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    disconnect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    delete?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    update?: LocationStaffUpdateWithWhereUniqueWithoutLocationInput | LocationStaffUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LocationStaffUpdateManyWithWhereWithoutLocationInput | LocationStaffUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LocationStaffScalarWhereInput | LocationStaffScalarWhereInput[]
  }

  export type MenuUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutLocationInput | MenuUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutLocationInput | MenuUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutLocationInput | MenuUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LocationStaffUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LocationStaffCreateWithoutLocationInput, LocationStaffUncheckedCreateWithoutLocationInput> | LocationStaffCreateWithoutLocationInput[] | LocationStaffUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationStaffCreateOrConnectWithoutLocationInput | LocationStaffCreateOrConnectWithoutLocationInput[]
    upsert?: LocationStaffUpsertWithWhereUniqueWithoutLocationInput | LocationStaffUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LocationStaffCreateManyLocationInputEnvelope
    set?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    disconnect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    delete?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    connect?: LocationStaffWhereUniqueInput | LocationStaffWhereUniqueInput[]
    update?: LocationStaffUpdateWithWhereUniqueWithoutLocationInput | LocationStaffUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LocationStaffUpdateManyWithWhereWithoutLocationInput | LocationStaffUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LocationStaffScalarWhereInput | LocationStaffScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutLocationInput | MenuUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutLocationInput | MenuUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutLocationInput | MenuUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutLocationStaffInput = {
    create?: XOR<LocationCreateWithoutLocationStaffInput, LocationUncheckedCreateWithoutLocationStaffInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLocationStaffInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLocationStaffInput = {
    create?: XOR<UserCreateWithoutLocationStaffInput, UserUncheckedCreateWithoutLocationStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationStaffInput
    connect?: UserWhereUniqueInput
  }

  export type LocationUpdateOneRequiredWithoutLocationStaffNestedInput = {
    create?: XOR<LocationCreateWithoutLocationStaffInput, LocationUncheckedCreateWithoutLocationStaffInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLocationStaffInput
    upsert?: LocationUpsertWithoutLocationStaffInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutLocationStaffInput, LocationUpdateWithoutLocationStaffInput>, LocationUncheckedUpdateWithoutLocationStaffInput>
  }

  export type UserUpdateOneRequiredWithoutLocationStaffNestedInput = {
    create?: XOR<UserCreateWithoutLocationStaffInput, UserUncheckedCreateWithoutLocationStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationStaffInput
    upsert?: UserUpsertWithoutLocationStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLocationStaffInput, UserUpdateWithoutLocationStaffInput>, UserUncheckedUpdateWithoutLocationStaffInput>
  }

  export type BrandCreateNestedOneWithoutMenuTemplateInput = {
    create?: XOR<BrandCreateWithoutMenuTemplateInput, BrandUncheckedCreateWithoutMenuTemplateInput>
    connectOrCreate?: BrandCreateOrConnectWithoutMenuTemplateInput
    connect?: BrandWhereUniqueInput
  }

  export type TemplateItemCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateInput, TemplateItemUncheckedCreateWithoutTemplateInput> | TemplateItemCreateWithoutTemplateInput[] | TemplateItemUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateInput | TemplateItemCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateItemCreateManyTemplateInputEnvelope
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
  }

  export type MenuCreateNestedManyWithoutTemplateInput = {
    create?: XOR<MenuCreateWithoutTemplateInput, MenuUncheckedCreateWithoutTemplateInput> | MenuCreateWithoutTemplateInput[] | MenuUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutTemplateInput | MenuCreateOrConnectWithoutTemplateInput[]
    createMany?: MenuCreateManyTemplateInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type AddonCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AddonCreateWithoutTemplateInput, AddonUncheckedCreateWithoutTemplateInput> | AddonCreateWithoutTemplateInput[] | AddonUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutTemplateInput | AddonCreateOrConnectWithoutTemplateInput[]
    createMany?: AddonCreateManyTemplateInputEnvelope
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
  }

  export type AddonCategoryCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AddonCategoryCreateWithoutTemplateInput, AddonCategoryUncheckedCreateWithoutTemplateInput> | AddonCategoryCreateWithoutTemplateInput[] | AddonCategoryUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCategoryCreateOrConnectWithoutTemplateInput | AddonCategoryCreateOrConnectWithoutTemplateInput[]
    createMany?: AddonCategoryCreateManyTemplateInputEnvelope
    connect?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
  }

  export type TemplateItemUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateInput, TemplateItemUncheckedCreateWithoutTemplateInput> | TemplateItemCreateWithoutTemplateInput[] | TemplateItemUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateInput | TemplateItemCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateItemCreateManyTemplateInputEnvelope
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<MenuCreateWithoutTemplateInput, MenuUncheckedCreateWithoutTemplateInput> | MenuCreateWithoutTemplateInput[] | MenuUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutTemplateInput | MenuCreateOrConnectWithoutTemplateInput[]
    createMany?: MenuCreateManyTemplateInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type AddonUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AddonCreateWithoutTemplateInput, AddonUncheckedCreateWithoutTemplateInput> | AddonCreateWithoutTemplateInput[] | AddonUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutTemplateInput | AddonCreateOrConnectWithoutTemplateInput[]
    createMany?: AddonCreateManyTemplateInputEnvelope
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
  }

  export type AddonCategoryUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AddonCategoryCreateWithoutTemplateInput, AddonCategoryUncheckedCreateWithoutTemplateInput> | AddonCategoryCreateWithoutTemplateInput[] | AddonCategoryUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCategoryCreateOrConnectWithoutTemplateInput | AddonCategoryCreateOrConnectWithoutTemplateInput[]
    createMany?: AddonCategoryCreateManyTemplateInputEnvelope
    connect?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
  }

  export type BrandUpdateOneRequiredWithoutMenuTemplateNestedInput = {
    create?: XOR<BrandCreateWithoutMenuTemplateInput, BrandUncheckedCreateWithoutMenuTemplateInput>
    connectOrCreate?: BrandCreateOrConnectWithoutMenuTemplateInput
    upsert?: BrandUpsertWithoutMenuTemplateInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutMenuTemplateInput, BrandUpdateWithoutMenuTemplateInput>, BrandUncheckedUpdateWithoutMenuTemplateInput>
  }

  export type TemplateItemUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateInput, TemplateItemUncheckedCreateWithoutTemplateInput> | TemplateItemCreateWithoutTemplateInput[] | TemplateItemUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateInput | TemplateItemCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateItemUpsertWithWhereUniqueWithoutTemplateInput | TemplateItemUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateItemCreateManyTemplateInputEnvelope
    set?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    disconnect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    delete?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    update?: TemplateItemUpdateWithWhereUniqueWithoutTemplateInput | TemplateItemUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateItemUpdateManyWithWhereWithoutTemplateInput | TemplateItemUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateItemScalarWhereInput | TemplateItemScalarWhereInput[]
  }

  export type MenuUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<MenuCreateWithoutTemplateInput, MenuUncheckedCreateWithoutTemplateInput> | MenuCreateWithoutTemplateInput[] | MenuUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutTemplateInput | MenuCreateOrConnectWithoutTemplateInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutTemplateInput | MenuUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: MenuCreateManyTemplateInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutTemplateInput | MenuUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutTemplateInput | MenuUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type AddonUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AddonCreateWithoutTemplateInput, AddonUncheckedCreateWithoutTemplateInput> | AddonCreateWithoutTemplateInput[] | AddonUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutTemplateInput | AddonCreateOrConnectWithoutTemplateInput[]
    upsert?: AddonUpsertWithWhereUniqueWithoutTemplateInput | AddonUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AddonCreateManyTemplateInputEnvelope
    set?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    disconnect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    delete?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    update?: AddonUpdateWithWhereUniqueWithoutTemplateInput | AddonUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AddonUpdateManyWithWhereWithoutTemplateInput | AddonUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AddonScalarWhereInput | AddonScalarWhereInput[]
  }

  export type AddonCategoryUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AddonCategoryCreateWithoutTemplateInput, AddonCategoryUncheckedCreateWithoutTemplateInput> | AddonCategoryCreateWithoutTemplateInput[] | AddonCategoryUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCategoryCreateOrConnectWithoutTemplateInput | AddonCategoryCreateOrConnectWithoutTemplateInput[]
    upsert?: AddonCategoryUpsertWithWhereUniqueWithoutTemplateInput | AddonCategoryUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AddonCategoryCreateManyTemplateInputEnvelope
    set?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    disconnect?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    delete?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    connect?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    update?: AddonCategoryUpdateWithWhereUniqueWithoutTemplateInput | AddonCategoryUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AddonCategoryUpdateManyWithWhereWithoutTemplateInput | AddonCategoryUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AddonCategoryScalarWhereInput | AddonCategoryScalarWhereInput[]
  }

  export type TemplateItemUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateInput, TemplateItemUncheckedCreateWithoutTemplateInput> | TemplateItemCreateWithoutTemplateInput[] | TemplateItemUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateInput | TemplateItemCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateItemUpsertWithWhereUniqueWithoutTemplateInput | TemplateItemUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateItemCreateManyTemplateInputEnvelope
    set?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    disconnect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    delete?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    update?: TemplateItemUpdateWithWhereUniqueWithoutTemplateInput | TemplateItemUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateItemUpdateManyWithWhereWithoutTemplateInput | TemplateItemUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateItemScalarWhereInput | TemplateItemScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<MenuCreateWithoutTemplateInput, MenuUncheckedCreateWithoutTemplateInput> | MenuCreateWithoutTemplateInput[] | MenuUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutTemplateInput | MenuCreateOrConnectWithoutTemplateInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutTemplateInput | MenuUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: MenuCreateManyTemplateInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutTemplateInput | MenuUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutTemplateInput | MenuUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type AddonUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AddonCreateWithoutTemplateInput, AddonUncheckedCreateWithoutTemplateInput> | AddonCreateWithoutTemplateInput[] | AddonUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutTemplateInput | AddonCreateOrConnectWithoutTemplateInput[]
    upsert?: AddonUpsertWithWhereUniqueWithoutTemplateInput | AddonUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AddonCreateManyTemplateInputEnvelope
    set?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    disconnect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    delete?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    update?: AddonUpdateWithWhereUniqueWithoutTemplateInput | AddonUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AddonUpdateManyWithWhereWithoutTemplateInput | AddonUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AddonScalarWhereInput | AddonScalarWhereInput[]
  }

  export type AddonCategoryUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AddonCategoryCreateWithoutTemplateInput, AddonCategoryUncheckedCreateWithoutTemplateInput> | AddonCategoryCreateWithoutTemplateInput[] | AddonCategoryUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AddonCategoryCreateOrConnectWithoutTemplateInput | AddonCategoryCreateOrConnectWithoutTemplateInput[]
    upsert?: AddonCategoryUpsertWithWhereUniqueWithoutTemplateInput | AddonCategoryUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AddonCategoryCreateManyTemplateInputEnvelope
    set?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    disconnect?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    delete?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    connect?: AddonCategoryWhereUniqueInput | AddonCategoryWhereUniqueInput[]
    update?: AddonCategoryUpdateWithWhereUniqueWithoutTemplateInput | AddonCategoryUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AddonCategoryUpdateManyWithWhereWithoutTemplateInput | AddonCategoryUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AddonCategoryScalarWhereInput | AddonCategoryScalarWhereInput[]
  }

  export type MenuTemplateCreateNestedOneWithoutItemsInput = {
    create?: XOR<MenuTemplateCreateWithoutItemsInput, MenuTemplateUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutItemsInput
    connect?: MenuTemplateWhereUniqueInput
  }

  export type TemplateItemVariantCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TemplateItemVariantCreateWithoutTemplateItemInput, TemplateItemVariantUncheckedCreateWithoutTemplateItemInput> | TemplateItemVariantCreateWithoutTemplateItemInput[] | TemplateItemVariantUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemVariantCreateOrConnectWithoutTemplateItemInput | TemplateItemVariantCreateOrConnectWithoutTemplateItemInput[]
    createMany?: TemplateItemVariantCreateManyTemplateItemInputEnvelope
    connect?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
  }

  export type MenuItemOverrideCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<MenuItemOverrideCreateWithoutTemplateItemInput, MenuItemOverrideUncheckedCreateWithoutTemplateItemInput> | MenuItemOverrideCreateWithoutTemplateItemInput[] | MenuItemOverrideUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutTemplateItemInput | MenuItemOverrideCreateOrConnectWithoutTemplateItemInput[]
    createMany?: MenuItemOverrideCreateManyTemplateItemInputEnvelope
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TagCreateWithoutTemplateItemInput, TagUncheckedCreateWithoutTemplateItemInput> | TagCreateWithoutTemplateItemInput[] | TagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTemplateItemInput | TagCreateOrConnectWithoutTemplateItemInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<OrderItemCreateWithoutTemplateItemInput, OrderItemUncheckedCreateWithoutTemplateItemInput> | OrderItemCreateWithoutTemplateItemInput[] | OrderItemUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutTemplateItemInput | OrderItemCreateOrConnectWithoutTemplateItemInput[]
    createMany?: OrderItemCreateManyTemplateItemInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TemplateItemTagCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TemplateItemTagCreateWithoutTemplateItemInput, TemplateItemTagUncheckedCreateWithoutTemplateItemInput> | TemplateItemTagCreateWithoutTemplateItemInput[] | TemplateItemTagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTemplateItemInput | TemplateItemTagCreateOrConnectWithoutTemplateItemInput[]
    createMany?: TemplateItemTagCreateManyTemplateItemInputEnvelope
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
  }

  export type TemplateItemAddonCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TemplateItemAddonCreateWithoutTemplateItemInput, TemplateItemAddonUncheckedCreateWithoutTemplateItemInput> | TemplateItemAddonCreateWithoutTemplateItemInput[] | TemplateItemAddonUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutTemplateItemInput | TemplateItemAddonCreateOrConnectWithoutTemplateItemInput[]
    createMany?: TemplateItemAddonCreateManyTemplateItemInputEnvelope
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
  }

  export type TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TemplateItemVariantCreateWithoutTemplateItemInput, TemplateItemVariantUncheckedCreateWithoutTemplateItemInput> | TemplateItemVariantCreateWithoutTemplateItemInput[] | TemplateItemVariantUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemVariantCreateOrConnectWithoutTemplateItemInput | TemplateItemVariantCreateOrConnectWithoutTemplateItemInput[]
    createMany?: TemplateItemVariantCreateManyTemplateItemInputEnvelope
    connect?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
  }

  export type MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<MenuItemOverrideCreateWithoutTemplateItemInput, MenuItemOverrideUncheckedCreateWithoutTemplateItemInput> | MenuItemOverrideCreateWithoutTemplateItemInput[] | MenuItemOverrideUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutTemplateItemInput | MenuItemOverrideCreateOrConnectWithoutTemplateItemInput[]
    createMany?: MenuItemOverrideCreateManyTemplateItemInputEnvelope
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TagCreateWithoutTemplateItemInput, TagUncheckedCreateWithoutTemplateItemInput> | TagCreateWithoutTemplateItemInput[] | TagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTemplateItemInput | TagCreateOrConnectWithoutTemplateItemInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<OrderItemCreateWithoutTemplateItemInput, OrderItemUncheckedCreateWithoutTemplateItemInput> | OrderItemCreateWithoutTemplateItemInput[] | OrderItemUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutTemplateItemInput | OrderItemCreateOrConnectWithoutTemplateItemInput[]
    createMany?: OrderItemCreateManyTemplateItemInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TemplateItemTagCreateWithoutTemplateItemInput, TemplateItemTagUncheckedCreateWithoutTemplateItemInput> | TemplateItemTagCreateWithoutTemplateItemInput[] | TemplateItemTagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTemplateItemInput | TemplateItemTagCreateOrConnectWithoutTemplateItemInput[]
    createMany?: TemplateItemTagCreateManyTemplateItemInputEnvelope
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
  }

  export type TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput = {
    create?: XOR<TemplateItemAddonCreateWithoutTemplateItemInput, TemplateItemAddonUncheckedCreateWithoutTemplateItemInput> | TemplateItemAddonCreateWithoutTemplateItemInput[] | TemplateItemAddonUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutTemplateItemInput | TemplateItemAddonCreateOrConnectWithoutTemplateItemInput[]
    createMany?: TemplateItemAddonCreateManyTemplateItemInputEnvelope
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
  }

  export type MenuTemplateUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<MenuTemplateCreateWithoutItemsInput, MenuTemplateUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutItemsInput
    upsert?: MenuTemplateUpsertWithoutItemsInput
    connect?: MenuTemplateWhereUniqueInput
    update?: XOR<XOR<MenuTemplateUpdateToOneWithWhereWithoutItemsInput, MenuTemplateUpdateWithoutItemsInput>, MenuTemplateUncheckedUpdateWithoutItemsInput>
  }

  export type TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TemplateItemVariantCreateWithoutTemplateItemInput, TemplateItemVariantUncheckedCreateWithoutTemplateItemInput> | TemplateItemVariantCreateWithoutTemplateItemInput[] | TemplateItemVariantUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemVariantCreateOrConnectWithoutTemplateItemInput | TemplateItemVariantCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TemplateItemVariantUpsertWithWhereUniqueWithoutTemplateItemInput | TemplateItemVariantUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: TemplateItemVariantCreateManyTemplateItemInputEnvelope
    set?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    disconnect?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    delete?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    connect?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    update?: TemplateItemVariantUpdateWithWhereUniqueWithoutTemplateItemInput | TemplateItemVariantUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TemplateItemVariantUpdateManyWithWhereWithoutTemplateItemInput | TemplateItemVariantUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TemplateItemVariantScalarWhereInput | TemplateItemVariantScalarWhereInput[]
  }

  export type MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<MenuItemOverrideCreateWithoutTemplateItemInput, MenuItemOverrideUncheckedCreateWithoutTemplateItemInput> | MenuItemOverrideCreateWithoutTemplateItemInput[] | MenuItemOverrideUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutTemplateItemInput | MenuItemOverrideCreateOrConnectWithoutTemplateItemInput[]
    upsert?: MenuItemOverrideUpsertWithWhereUniqueWithoutTemplateItemInput | MenuItemOverrideUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: MenuItemOverrideCreateManyTemplateItemInputEnvelope
    set?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    disconnect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    delete?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    update?: MenuItemOverrideUpdateWithWhereUniqueWithoutTemplateItemInput | MenuItemOverrideUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: MenuItemOverrideUpdateManyWithWhereWithoutTemplateItemInput | MenuItemOverrideUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: MenuItemOverrideScalarWhereInput | MenuItemOverrideScalarWhereInput[]
  }

  export type TagUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TagCreateWithoutTemplateItemInput, TagUncheckedCreateWithoutTemplateItemInput> | TagCreateWithoutTemplateItemInput[] | TagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTemplateItemInput | TagCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTemplateItemInput | TagUpsertWithWhereUniqueWithoutTemplateItemInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTemplateItemInput | TagUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTemplateItemInput | TagUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<OrderItemCreateWithoutTemplateItemInput, OrderItemUncheckedCreateWithoutTemplateItemInput> | OrderItemCreateWithoutTemplateItemInput[] | OrderItemUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutTemplateItemInput | OrderItemCreateOrConnectWithoutTemplateItemInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutTemplateItemInput | OrderItemUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: OrderItemCreateManyTemplateItemInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutTemplateItemInput | OrderItemUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutTemplateItemInput | OrderItemUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TemplateItemTagUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TemplateItemTagCreateWithoutTemplateItemInput, TemplateItemTagUncheckedCreateWithoutTemplateItemInput> | TemplateItemTagCreateWithoutTemplateItemInput[] | TemplateItemTagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTemplateItemInput | TemplateItemTagCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TemplateItemTagUpsertWithWhereUniqueWithoutTemplateItemInput | TemplateItemTagUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: TemplateItemTagCreateManyTemplateItemInputEnvelope
    set?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    disconnect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    delete?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    update?: TemplateItemTagUpdateWithWhereUniqueWithoutTemplateItemInput | TemplateItemTagUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TemplateItemTagUpdateManyWithWhereWithoutTemplateItemInput | TemplateItemTagUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TemplateItemTagScalarWhereInput | TemplateItemTagScalarWhereInput[]
  }

  export type TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TemplateItemAddonCreateWithoutTemplateItemInput, TemplateItemAddonUncheckedCreateWithoutTemplateItemInput> | TemplateItemAddonCreateWithoutTemplateItemInput[] | TemplateItemAddonUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutTemplateItemInput | TemplateItemAddonCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TemplateItemAddonUpsertWithWhereUniqueWithoutTemplateItemInput | TemplateItemAddonUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: TemplateItemAddonCreateManyTemplateItemInputEnvelope
    set?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    disconnect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    delete?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    update?: TemplateItemAddonUpdateWithWhereUniqueWithoutTemplateItemInput | TemplateItemAddonUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TemplateItemAddonUpdateManyWithWhereWithoutTemplateItemInput | TemplateItemAddonUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TemplateItemAddonScalarWhereInput | TemplateItemAddonScalarWhereInput[]
  }

  export type TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TemplateItemVariantCreateWithoutTemplateItemInput, TemplateItemVariantUncheckedCreateWithoutTemplateItemInput> | TemplateItemVariantCreateWithoutTemplateItemInput[] | TemplateItemVariantUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemVariantCreateOrConnectWithoutTemplateItemInput | TemplateItemVariantCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TemplateItemVariantUpsertWithWhereUniqueWithoutTemplateItemInput | TemplateItemVariantUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: TemplateItemVariantCreateManyTemplateItemInputEnvelope
    set?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    disconnect?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    delete?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    connect?: TemplateItemVariantWhereUniqueInput | TemplateItemVariantWhereUniqueInput[]
    update?: TemplateItemVariantUpdateWithWhereUniqueWithoutTemplateItemInput | TemplateItemVariantUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TemplateItemVariantUpdateManyWithWhereWithoutTemplateItemInput | TemplateItemVariantUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TemplateItemVariantScalarWhereInput | TemplateItemVariantScalarWhereInput[]
  }

  export type MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<MenuItemOverrideCreateWithoutTemplateItemInput, MenuItemOverrideUncheckedCreateWithoutTemplateItemInput> | MenuItemOverrideCreateWithoutTemplateItemInput[] | MenuItemOverrideUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutTemplateItemInput | MenuItemOverrideCreateOrConnectWithoutTemplateItemInput[]
    upsert?: MenuItemOverrideUpsertWithWhereUniqueWithoutTemplateItemInput | MenuItemOverrideUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: MenuItemOverrideCreateManyTemplateItemInputEnvelope
    set?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    disconnect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    delete?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    update?: MenuItemOverrideUpdateWithWhereUniqueWithoutTemplateItemInput | MenuItemOverrideUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: MenuItemOverrideUpdateManyWithWhereWithoutTemplateItemInput | MenuItemOverrideUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: MenuItemOverrideScalarWhereInput | MenuItemOverrideScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TagCreateWithoutTemplateItemInput, TagUncheckedCreateWithoutTemplateItemInput> | TagCreateWithoutTemplateItemInput[] | TagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTemplateItemInput | TagCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTemplateItemInput | TagUpsertWithWhereUniqueWithoutTemplateItemInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTemplateItemInput | TagUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTemplateItemInput | TagUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<OrderItemCreateWithoutTemplateItemInput, OrderItemUncheckedCreateWithoutTemplateItemInput> | OrderItemCreateWithoutTemplateItemInput[] | OrderItemUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutTemplateItemInput | OrderItemCreateOrConnectWithoutTemplateItemInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutTemplateItemInput | OrderItemUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: OrderItemCreateManyTemplateItemInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutTemplateItemInput | OrderItemUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutTemplateItemInput | OrderItemUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TemplateItemTagCreateWithoutTemplateItemInput, TemplateItemTagUncheckedCreateWithoutTemplateItemInput> | TemplateItemTagCreateWithoutTemplateItemInput[] | TemplateItemTagUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTemplateItemInput | TemplateItemTagCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TemplateItemTagUpsertWithWhereUniqueWithoutTemplateItemInput | TemplateItemTagUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: TemplateItemTagCreateManyTemplateItemInputEnvelope
    set?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    disconnect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    delete?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    update?: TemplateItemTagUpdateWithWhereUniqueWithoutTemplateItemInput | TemplateItemTagUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TemplateItemTagUpdateManyWithWhereWithoutTemplateItemInput | TemplateItemTagUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TemplateItemTagScalarWhereInput | TemplateItemTagScalarWhereInput[]
  }

  export type TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput = {
    create?: XOR<TemplateItemAddonCreateWithoutTemplateItemInput, TemplateItemAddonUncheckedCreateWithoutTemplateItemInput> | TemplateItemAddonCreateWithoutTemplateItemInput[] | TemplateItemAddonUncheckedCreateWithoutTemplateItemInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutTemplateItemInput | TemplateItemAddonCreateOrConnectWithoutTemplateItemInput[]
    upsert?: TemplateItemAddonUpsertWithWhereUniqueWithoutTemplateItemInput | TemplateItemAddonUpsertWithWhereUniqueWithoutTemplateItemInput[]
    createMany?: TemplateItemAddonCreateManyTemplateItemInputEnvelope
    set?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    disconnect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    delete?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    update?: TemplateItemAddonUpdateWithWhereUniqueWithoutTemplateItemInput | TemplateItemAddonUpdateWithWhereUniqueWithoutTemplateItemInput[]
    updateMany?: TemplateItemAddonUpdateManyWithWhereWithoutTemplateItemInput | TemplateItemAddonUpdateManyWithWhereWithoutTemplateItemInput[]
    deleteMany?: TemplateItemAddonScalarWhereInput | TemplateItemAddonScalarWhereInput[]
  }

  export type TemplateItemCreateNestedOneWithoutVariantsInput = {
    create?: XOR<TemplateItemCreateWithoutVariantsInput, TemplateItemUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutVariantsInput
    connect?: TemplateItemWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TemplateItemUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<TemplateItemCreateWithoutVariantsInput, TemplateItemUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutVariantsInput
    upsert?: TemplateItemUpsertWithoutVariantsInput
    connect?: TemplateItemWhereUniqueInput
    update?: XOR<XOR<TemplateItemUpdateToOneWithWhereWithoutVariantsInput, TemplateItemUpdateWithoutVariantsInput>, TemplateItemUncheckedUpdateWithoutVariantsInput>
  }

  export type OrderItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutMenuInput = {
    create?: XOR<LocationCreateWithoutMenuInput, LocationUncheckedCreateWithoutMenuInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMenuInput
    connect?: LocationWhereUniqueInput
  }

  export type MenuTemplateCreateNestedOneWithoutMenuInput = {
    create?: XOR<MenuTemplateCreateWithoutMenuInput, MenuTemplateUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutMenuInput
    connect?: MenuTemplateWhereUniqueInput
  }

  export type MenuItemOverrideCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuItemOverrideCreateWithoutMenuInput, MenuItemOverrideUncheckedCreateWithoutMenuInput> | MenuItemOverrideCreateWithoutMenuInput[] | MenuItemOverrideUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutMenuInput | MenuItemOverrideCreateOrConnectWithoutMenuInput[]
    createMany?: MenuItemOverrideCreateManyMenuInputEnvelope
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
  }

  export type MenuItemOverrideUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuItemOverrideCreateWithoutMenuInput, MenuItemOverrideUncheckedCreateWithoutMenuInput> | MenuItemOverrideCreateWithoutMenuInput[] | MenuItemOverrideUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutMenuInput | MenuItemOverrideCreateOrConnectWithoutMenuInput[]
    createMany?: MenuItemOverrideCreateManyMenuInputEnvelope
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutMenuNestedInput = {
    create?: XOR<LocationCreateWithoutMenuInput, LocationUncheckedCreateWithoutMenuInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMenuInput
    upsert?: LocationUpsertWithoutMenuInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutMenuInput, LocationUpdateWithoutMenuInput>, LocationUncheckedUpdateWithoutMenuInput>
  }

  export type MenuTemplateUpdateOneRequiredWithoutMenuNestedInput = {
    create?: XOR<MenuTemplateCreateWithoutMenuInput, MenuTemplateUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutMenuInput
    upsert?: MenuTemplateUpsertWithoutMenuInput
    connect?: MenuTemplateWhereUniqueInput
    update?: XOR<XOR<MenuTemplateUpdateToOneWithWhereWithoutMenuInput, MenuTemplateUpdateWithoutMenuInput>, MenuTemplateUncheckedUpdateWithoutMenuInput>
  }

  export type MenuItemOverrideUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuItemOverrideCreateWithoutMenuInput, MenuItemOverrideUncheckedCreateWithoutMenuInput> | MenuItemOverrideCreateWithoutMenuInput[] | MenuItemOverrideUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutMenuInput | MenuItemOverrideCreateOrConnectWithoutMenuInput[]
    upsert?: MenuItemOverrideUpsertWithWhereUniqueWithoutMenuInput | MenuItemOverrideUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuItemOverrideCreateManyMenuInputEnvelope
    set?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    disconnect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    delete?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    update?: MenuItemOverrideUpdateWithWhereUniqueWithoutMenuInput | MenuItemOverrideUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuItemOverrideUpdateManyWithWhereWithoutMenuInput | MenuItemOverrideUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuItemOverrideScalarWhereInput | MenuItemOverrideScalarWhereInput[]
  }

  export type MenuItemOverrideUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuItemOverrideCreateWithoutMenuInput, MenuItemOverrideUncheckedCreateWithoutMenuInput> | MenuItemOverrideCreateWithoutMenuInput[] | MenuItemOverrideUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemOverrideCreateOrConnectWithoutMenuInput | MenuItemOverrideCreateOrConnectWithoutMenuInput[]
    upsert?: MenuItemOverrideUpsertWithWhereUniqueWithoutMenuInput | MenuItemOverrideUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuItemOverrideCreateManyMenuInputEnvelope
    set?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    disconnect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    delete?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    connect?: MenuItemOverrideWhereUniqueInput | MenuItemOverrideWhereUniqueInput[]
    update?: MenuItemOverrideUpdateWithWhereUniqueWithoutMenuInput | MenuItemOverrideUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuItemOverrideUpdateManyWithWhereWithoutMenuInput | MenuItemOverrideUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuItemOverrideScalarWhereInput | MenuItemOverrideScalarWhereInput[]
  }

  export type MenuCreateNestedOneWithoutOverridesInput = {
    create?: XOR<MenuCreateWithoutOverridesInput, MenuUncheckedCreateWithoutOverridesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOverridesInput
    connect?: MenuWhereUniqueInput
  }

  export type TemplateItemCreateNestedOneWithoutMenuItemOverrideInput = {
    create?: XOR<TemplateItemCreateWithoutMenuItemOverrideInput, TemplateItemUncheckedCreateWithoutMenuItemOverrideInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutMenuItemOverrideInput
    connect?: TemplateItemWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type MenuUpdateOneRequiredWithoutOverridesNestedInput = {
    create?: XOR<MenuCreateWithoutOverridesInput, MenuUncheckedCreateWithoutOverridesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOverridesInput
    upsert?: MenuUpsertWithoutOverridesInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutOverridesInput, MenuUpdateWithoutOverridesInput>, MenuUncheckedUpdateWithoutOverridesInput>
  }

  export type TemplateItemUpdateOneRequiredWithoutMenuItemOverrideNestedInput = {
    create?: XOR<TemplateItemCreateWithoutMenuItemOverrideInput, TemplateItemUncheckedCreateWithoutMenuItemOverrideInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutMenuItemOverrideInput
    upsert?: TemplateItemUpsertWithoutMenuItemOverrideInput
    connect?: TemplateItemWhereUniqueInput
    update?: XOR<XOR<TemplateItemUpdateToOneWithWhereWithoutMenuItemOverrideInput, TemplateItemUpdateWithoutMenuItemOverrideInput>, TemplateItemUncheckedUpdateWithoutMenuItemOverrideInput>
  }

  export type TemplateItemTagCreateNestedManyWithoutTagInput = {
    create?: XOR<TemplateItemTagCreateWithoutTagInput, TemplateItemTagUncheckedCreateWithoutTagInput> | TemplateItemTagCreateWithoutTagInput[] | TemplateItemTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTagInput | TemplateItemTagCreateOrConnectWithoutTagInput[]
    createMany?: TemplateItemTagCreateManyTagInputEnvelope
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
  }

  export type TemplateItemCreateNestedManyWithoutTagInput = {
    create?: XOR<TemplateItemCreateWithoutTagInput, TemplateItemUncheckedCreateWithoutTagInput> | TemplateItemCreateWithoutTagInput[] | TemplateItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTagInput | TemplateItemCreateOrConnectWithoutTagInput[]
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
  }

  export type TemplateItemTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TemplateItemTagCreateWithoutTagInput, TemplateItemTagUncheckedCreateWithoutTagInput> | TemplateItemTagCreateWithoutTagInput[] | TemplateItemTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTagInput | TemplateItemTagCreateOrConnectWithoutTagInput[]
    createMany?: TemplateItemTagCreateManyTagInputEnvelope
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
  }

  export type TemplateItemUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TemplateItemCreateWithoutTagInput, TemplateItemUncheckedCreateWithoutTagInput> | TemplateItemCreateWithoutTagInput[] | TemplateItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTagInput | TemplateItemCreateOrConnectWithoutTagInput[]
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
  }

  export type TemplateItemTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<TemplateItemTagCreateWithoutTagInput, TemplateItemTagUncheckedCreateWithoutTagInput> | TemplateItemTagCreateWithoutTagInput[] | TemplateItemTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTagInput | TemplateItemTagCreateOrConnectWithoutTagInput[]
    upsert?: TemplateItemTagUpsertWithWhereUniqueWithoutTagInput | TemplateItemTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TemplateItemTagCreateManyTagInputEnvelope
    set?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    disconnect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    delete?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    update?: TemplateItemTagUpdateWithWhereUniqueWithoutTagInput | TemplateItemTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TemplateItemTagUpdateManyWithWhereWithoutTagInput | TemplateItemTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TemplateItemTagScalarWhereInput | TemplateItemTagScalarWhereInput[]
  }

  export type TemplateItemUpdateManyWithoutTagNestedInput = {
    create?: XOR<TemplateItemCreateWithoutTagInput, TemplateItemUncheckedCreateWithoutTagInput> | TemplateItemCreateWithoutTagInput[] | TemplateItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTagInput | TemplateItemCreateOrConnectWithoutTagInput[]
    upsert?: TemplateItemUpsertWithWhereUniqueWithoutTagInput | TemplateItemUpsertWithWhereUniqueWithoutTagInput[]
    set?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    disconnect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    delete?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    update?: TemplateItemUpdateWithWhereUniqueWithoutTagInput | TemplateItemUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TemplateItemUpdateManyWithWhereWithoutTagInput | TemplateItemUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TemplateItemScalarWhereInput | TemplateItemScalarWhereInput[]
  }

  export type TemplateItemTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TemplateItemTagCreateWithoutTagInput, TemplateItemTagUncheckedCreateWithoutTagInput> | TemplateItemTagCreateWithoutTagInput[] | TemplateItemTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemTagCreateOrConnectWithoutTagInput | TemplateItemTagCreateOrConnectWithoutTagInput[]
    upsert?: TemplateItemTagUpsertWithWhereUniqueWithoutTagInput | TemplateItemTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TemplateItemTagCreateManyTagInputEnvelope
    set?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    disconnect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    delete?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    connect?: TemplateItemTagWhereUniqueInput | TemplateItemTagWhereUniqueInput[]
    update?: TemplateItemTagUpdateWithWhereUniqueWithoutTagInput | TemplateItemTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TemplateItemTagUpdateManyWithWhereWithoutTagInput | TemplateItemTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TemplateItemTagScalarWhereInput | TemplateItemTagScalarWhereInput[]
  }

  export type TemplateItemUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TemplateItemCreateWithoutTagInput, TemplateItemUncheckedCreateWithoutTagInput> | TemplateItemCreateWithoutTagInput[] | TemplateItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTagInput | TemplateItemCreateOrConnectWithoutTagInput[]
    upsert?: TemplateItemUpsertWithWhereUniqueWithoutTagInput | TemplateItemUpsertWithWhereUniqueWithoutTagInput[]
    set?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    disconnect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    delete?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    connect?: TemplateItemWhereUniqueInput | TemplateItemWhereUniqueInput[]
    update?: TemplateItemUpdateWithWhereUniqueWithoutTagInput | TemplateItemUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TemplateItemUpdateManyWithWhereWithoutTagInput | TemplateItemUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TemplateItemScalarWhereInput | TemplateItemScalarWhereInput[]
  }

  export type TemplateItemCreateNestedOneWithoutTemplateItemTagInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateItemTagInput, TemplateItemUncheckedCreateWithoutTemplateItemTagInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateItemTagInput
    connect?: TemplateItemWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutItemsInput = {
    create?: XOR<TagCreateWithoutItemsInput, TagUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TagCreateOrConnectWithoutItemsInput
    connect?: TagWhereUniqueInput
  }

  export type TemplateItemUpdateOneRequiredWithoutTemplateItemTagNestedInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateItemTagInput, TemplateItemUncheckedCreateWithoutTemplateItemTagInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateItemTagInput
    upsert?: TemplateItemUpsertWithoutTemplateItemTagInput
    connect?: TemplateItemWhereUniqueInput
    update?: XOR<XOR<TemplateItemUpdateToOneWithWhereWithoutTemplateItemTagInput, TemplateItemUpdateWithoutTemplateItemTagInput>, TemplateItemUncheckedUpdateWithoutTemplateItemTagInput>
  }

  export type TagUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TagCreateWithoutItemsInput, TagUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TagCreateOrConnectWithoutItemsInput
    upsert?: TagUpsertWithoutItemsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutItemsInput, TagUpdateWithoutItemsInput>, TagUncheckedUpdateWithoutItemsInput>
  }

  export type AddonCategoryCreateNestedOneWithoutAddonsInput = {
    create?: XOR<AddonCategoryCreateWithoutAddonsInput, AddonCategoryUncheckedCreateWithoutAddonsInput>
    connectOrCreate?: AddonCategoryCreateOrConnectWithoutAddonsInput
    connect?: AddonCategoryWhereUniqueInput
  }

  export type MenuTemplateCreateNestedOneWithoutAddonInput = {
    create?: XOR<MenuTemplateCreateWithoutAddonInput, MenuTemplateUncheckedCreateWithoutAddonInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutAddonInput
    connect?: MenuTemplateWhereUniqueInput
  }

  export type TemplateItemAddonCreateNestedManyWithoutAddonInput = {
    create?: XOR<TemplateItemAddonCreateWithoutAddonInput, TemplateItemAddonUncheckedCreateWithoutAddonInput> | TemplateItemAddonCreateWithoutAddonInput[] | TemplateItemAddonUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutAddonInput | TemplateItemAddonCreateOrConnectWithoutAddonInput[]
    createMany?: TemplateItemAddonCreateManyAddonInputEnvelope
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
  }

  export type TemplateItemAddonUncheckedCreateNestedManyWithoutAddonInput = {
    create?: XOR<TemplateItemAddonCreateWithoutAddonInput, TemplateItemAddonUncheckedCreateWithoutAddonInput> | TemplateItemAddonCreateWithoutAddonInput[] | TemplateItemAddonUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutAddonInput | TemplateItemAddonCreateOrConnectWithoutAddonInput[]
    createMany?: TemplateItemAddonCreateManyAddonInputEnvelope
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
  }

  export type AddonCategoryUpdateOneRequiredWithoutAddonsNestedInput = {
    create?: XOR<AddonCategoryCreateWithoutAddonsInput, AddonCategoryUncheckedCreateWithoutAddonsInput>
    connectOrCreate?: AddonCategoryCreateOrConnectWithoutAddonsInput
    upsert?: AddonCategoryUpsertWithoutAddonsInput
    connect?: AddonCategoryWhereUniqueInput
    update?: XOR<XOR<AddonCategoryUpdateToOneWithWhereWithoutAddonsInput, AddonCategoryUpdateWithoutAddonsInput>, AddonCategoryUncheckedUpdateWithoutAddonsInput>
  }

  export type MenuTemplateUpdateOneRequiredWithoutAddonNestedInput = {
    create?: XOR<MenuTemplateCreateWithoutAddonInput, MenuTemplateUncheckedCreateWithoutAddonInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutAddonInput
    upsert?: MenuTemplateUpsertWithoutAddonInput
    connect?: MenuTemplateWhereUniqueInput
    update?: XOR<XOR<MenuTemplateUpdateToOneWithWhereWithoutAddonInput, MenuTemplateUpdateWithoutAddonInput>, MenuTemplateUncheckedUpdateWithoutAddonInput>
  }

  export type TemplateItemAddonUpdateManyWithoutAddonNestedInput = {
    create?: XOR<TemplateItemAddonCreateWithoutAddonInput, TemplateItemAddonUncheckedCreateWithoutAddonInput> | TemplateItemAddonCreateWithoutAddonInput[] | TemplateItemAddonUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutAddonInput | TemplateItemAddonCreateOrConnectWithoutAddonInput[]
    upsert?: TemplateItemAddonUpsertWithWhereUniqueWithoutAddonInput | TemplateItemAddonUpsertWithWhereUniqueWithoutAddonInput[]
    createMany?: TemplateItemAddonCreateManyAddonInputEnvelope
    set?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    disconnect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    delete?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    update?: TemplateItemAddonUpdateWithWhereUniqueWithoutAddonInput | TemplateItemAddonUpdateWithWhereUniqueWithoutAddonInput[]
    updateMany?: TemplateItemAddonUpdateManyWithWhereWithoutAddonInput | TemplateItemAddonUpdateManyWithWhereWithoutAddonInput[]
    deleteMany?: TemplateItemAddonScalarWhereInput | TemplateItemAddonScalarWhereInput[]
  }

  export type TemplateItemAddonUncheckedUpdateManyWithoutAddonNestedInput = {
    create?: XOR<TemplateItemAddonCreateWithoutAddonInput, TemplateItemAddonUncheckedCreateWithoutAddonInput> | TemplateItemAddonCreateWithoutAddonInput[] | TemplateItemAddonUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TemplateItemAddonCreateOrConnectWithoutAddonInput | TemplateItemAddonCreateOrConnectWithoutAddonInput[]
    upsert?: TemplateItemAddonUpsertWithWhereUniqueWithoutAddonInput | TemplateItemAddonUpsertWithWhereUniqueWithoutAddonInput[]
    createMany?: TemplateItemAddonCreateManyAddonInputEnvelope
    set?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    disconnect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    delete?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    connect?: TemplateItemAddonWhereUniqueInput | TemplateItemAddonWhereUniqueInput[]
    update?: TemplateItemAddonUpdateWithWhereUniqueWithoutAddonInput | TemplateItemAddonUpdateWithWhereUniqueWithoutAddonInput[]
    updateMany?: TemplateItemAddonUpdateManyWithWhereWithoutAddonInput | TemplateItemAddonUpdateManyWithWhereWithoutAddonInput[]
    deleteMany?: TemplateItemAddonScalarWhereInput | TemplateItemAddonScalarWhereInput[]
  }

  export type TemplateItemCreateNestedOneWithoutTemplateItemAddonInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateItemAddonInput, TemplateItemUncheckedCreateWithoutTemplateItemAddonInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateItemAddonInput
    connect?: TemplateItemWhereUniqueInput
  }

  export type AddonCreateNestedOneWithoutItemsInput = {
    create?: XOR<AddonCreateWithoutItemsInput, AddonUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AddonCreateOrConnectWithoutItemsInput
    connect?: AddonWhereUniqueInput
  }

  export type TemplateItemUpdateOneRequiredWithoutTemplateItemAddonNestedInput = {
    create?: XOR<TemplateItemCreateWithoutTemplateItemAddonInput, TemplateItemUncheckedCreateWithoutTemplateItemAddonInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutTemplateItemAddonInput
    upsert?: TemplateItemUpsertWithoutTemplateItemAddonInput
    connect?: TemplateItemWhereUniqueInput
    update?: XOR<XOR<TemplateItemUpdateToOneWithWhereWithoutTemplateItemAddonInput, TemplateItemUpdateWithoutTemplateItemAddonInput>, TemplateItemUncheckedUpdateWithoutTemplateItemAddonInput>
  }

  export type AddonUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AddonCreateWithoutItemsInput, AddonUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AddonCreateOrConnectWithoutItemsInput
    upsert?: AddonUpsertWithoutItemsInput
    connect?: AddonWhereUniqueInput
    update?: XOR<XOR<AddonUpdateToOneWithWhereWithoutItemsInput, AddonUpdateWithoutItemsInput>, AddonUncheckedUpdateWithoutItemsInput>
  }

  export type MenuTemplateCreateNestedOneWithoutAddonCategoryInput = {
    create?: XOR<MenuTemplateCreateWithoutAddonCategoryInput, MenuTemplateUncheckedCreateWithoutAddonCategoryInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutAddonCategoryInput
    connect?: MenuTemplateWhereUniqueInput
  }

  export type AddonCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
  }

  export type AddonUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MenuTemplateUpdateOneRequiredWithoutAddonCategoryNestedInput = {
    create?: XOR<MenuTemplateCreateWithoutAddonCategoryInput, MenuTemplateUncheckedCreateWithoutAddonCategoryInput>
    connectOrCreate?: MenuTemplateCreateOrConnectWithoutAddonCategoryInput
    upsert?: MenuTemplateUpsertWithoutAddonCategoryInput
    connect?: MenuTemplateWhereUniqueInput
    update?: XOR<XOR<MenuTemplateUpdateToOneWithWhereWithoutAddonCategoryInput, MenuTemplateUpdateWithoutAddonCategoryInput>, MenuTemplateUncheckedUpdateWithoutAddonCategoryInput>
  }

  export type AddonUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    upsert?: AddonUpsertWithWhereUniqueWithoutCategoryInput | AddonUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    set?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    disconnect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    delete?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    update?: AddonUpdateWithWhereUniqueWithoutCategoryInput | AddonUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AddonUpdateManyWithWhereWithoutCategoryInput | AddonUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AddonScalarWhereInput | AddonScalarWhereInput[]
  }

  export type AddonUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    upsert?: AddonUpsertWithWhereUniqueWithoutCategoryInput | AddonUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    set?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    disconnect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    delete?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    update?: AddonUpdateWithWhereUniqueWithoutCategoryInput | AddonUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AddonUpdateManyWithWhereWithoutCategoryInput | AddonUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AddonScalarWhereInput | AddonScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutOrderInput = {
    create?: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrderInput
    connect?: LocationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type LocationUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrderInput
    upsert?: LocationUpsertWithoutOrderInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutOrderInput, LocationUpdateWithoutOrderInput>, LocationUncheckedUpdateWithoutOrderInput>
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type TemplateItemCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<TemplateItemCreateWithoutOrderItemInput, TemplateItemUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutOrderItemInput
    connect?: TemplateItemWhereUniqueInput
  }

  export type TemplateItemVariantCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<TemplateItemVariantCreateWithoutOrderItemInput, TemplateItemVariantUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: TemplateItemVariantCreateOrConnectWithoutOrderItemInput
    connect?: TemplateItemVariantWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type TemplateItemUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<TemplateItemCreateWithoutOrderItemInput, TemplateItemUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: TemplateItemCreateOrConnectWithoutOrderItemInput
    upsert?: TemplateItemUpsertWithoutOrderItemInput
    connect?: TemplateItemWhereUniqueInput
    update?: XOR<XOR<TemplateItemUpdateToOneWithWhereWithoutOrderItemInput, TemplateItemUpdateWithoutOrderItemInput>, TemplateItemUncheckedUpdateWithoutOrderItemInput>
  }

  export type TemplateItemVariantUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<TemplateItemVariantCreateWithoutOrderItemInput, TemplateItemVariantUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: TemplateItemVariantCreateOrConnectWithoutOrderItemInput
    upsert?: TemplateItemVariantUpsertWithoutOrderItemInput
    disconnect?: TemplateItemVariantWhereInput | boolean
    delete?: TemplateItemVariantWhereInput | boolean
    connect?: TemplateItemVariantWhereUniqueInput
    update?: XOR<XOR<TemplateItemVariantUpdateToOneWithWhereWithoutOrderItemInput, TemplateItemVariantUpdateWithoutOrderItemInput>, TemplateItemVariantUncheckedUpdateWithoutOrderItemInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BrandCreateWithoutOwnerInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationCreateNestedManyWithoutBrandInput
    MenuTemplate?: MenuTemplateCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationUncheckedCreateNestedManyWithoutBrandInput
    MenuTemplate?: MenuTemplateUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutOwnerInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutOwnerInput, BrandUncheckedCreateWithoutOwnerInput>
  }

  export type BrandCreateManyOwnerInputEnvelope = {
    data: BrandCreateManyOwnerInput | BrandCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutManagerInput = {
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand: BrandCreateNestedOneWithoutLocationInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutLocationInput
    Menu?: MenuCreateNestedManyWithoutLocationInput
    Order?: OrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutManagerInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutLocationInput
    Menu?: MenuUncheckedCreateNestedManyWithoutLocationInput
    Order?: OrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutManagerInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutManagerInput, LocationUncheckedCreateWithoutManagerInput>
  }

  export type LocationCreateManyManagerInputEnvelope = {
    data: LocationCreateManyManagerInput | LocationCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type LocationStaffCreateWithoutStaffInput = {
    location: LocationCreateNestedOneWithoutLocationStaffInput
  }

  export type LocationStaffUncheckedCreateWithoutStaffInput = {
    id?: number
    locationId: number
  }

  export type LocationStaffCreateOrConnectWithoutStaffInput = {
    where: LocationStaffWhereUniqueInput
    create: XOR<LocationStaffCreateWithoutStaffInput, LocationStaffUncheckedCreateWithoutStaffInput>
  }

  export type LocationStaffCreateManyStaffInputEnvelope = {
    data: LocationStaffCreateManyStaffInput | LocationStaffCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    firstName: string
    lastName: string
    phoneNumber?: string | null
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: number
    firstName: string
    lastName: string
    phoneNumber?: string | null
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type BrandUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BrandWhereUniqueInput
    update: XOR<BrandUpdateWithoutOwnerInput, BrandUncheckedUpdateWithoutOwnerInput>
    create: XOR<BrandCreateWithoutOwnerInput, BrandUncheckedCreateWithoutOwnerInput>
  }

  export type BrandUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BrandWhereUniqueInput
    data: XOR<BrandUpdateWithoutOwnerInput, BrandUncheckedUpdateWithoutOwnerInput>
  }

  export type BrandUpdateManyWithWhereWithoutOwnerInput = {
    where: BrandScalarWhereInput
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BrandScalarWhereInput = {
    AND?: BrandScalarWhereInput | BrandScalarWhereInput[]
    OR?: BrandScalarWhereInput[]
    NOT?: BrandScalarWhereInput | BrandScalarWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringFilter<"Brand"> | string
    ownerId?: IntFilter<"Brand"> | number
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutManagerInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutManagerInput, LocationUncheckedUpdateWithoutManagerInput>
    create: XOR<LocationCreateWithoutManagerInput, LocationUncheckedCreateWithoutManagerInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutManagerInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutManagerInput, LocationUncheckedUpdateWithoutManagerInput>
  }

  export type LocationUpdateManyWithWhereWithoutManagerInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutManagerInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: IntFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    placeId?: StringNullableFilter<"Location"> | string | null
    name?: StringNullableFilter<"Location"> | string | null
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    postalCode?: StringNullableFilter<"Location"> | string | null
    geohash?: StringNullableFilter<"Location"> | string | null
    timezone?: StringNullableFilter<"Location"> | string | null
    accuracy?: FloatNullableFilter<"Location"> | number | null
    managerId?: IntNullableFilter<"Location"> | number | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    BrandId?: IntFilter<"Location"> | number
  }

  export type LocationStaffUpsertWithWhereUniqueWithoutStaffInput = {
    where: LocationStaffWhereUniqueInput
    update: XOR<LocationStaffUpdateWithoutStaffInput, LocationStaffUncheckedUpdateWithoutStaffInput>
    create: XOR<LocationStaffCreateWithoutStaffInput, LocationStaffUncheckedCreateWithoutStaffInput>
  }

  export type LocationStaffUpdateWithWhereUniqueWithoutStaffInput = {
    where: LocationStaffWhereUniqueInput
    data: XOR<LocationStaffUpdateWithoutStaffInput, LocationStaffUncheckedUpdateWithoutStaffInput>
  }

  export type LocationStaffUpdateManyWithWhereWithoutStaffInput = {
    where: LocationStaffScalarWhereInput
    data: XOR<LocationStaffUpdateManyMutationInput, LocationStaffUncheckedUpdateManyWithoutStaffInput>
  }

  export type LocationStaffScalarWhereInput = {
    AND?: LocationStaffScalarWhereInput | LocationStaffScalarWhereInput[]
    OR?: LocationStaffScalarWhereInput[]
    NOT?: LocationStaffScalarWhereInput | LocationStaffScalarWhereInput[]
    id?: IntFilter<"LocationStaff"> | number
    locationId?: IntFilter<"LocationStaff"> | number
    staffId?: IntFilter<"LocationStaff"> | number
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutUserProfileInput = {
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandCreateNestedManyWithoutOwnerInput
    Location?: LocationCreateNestedManyWithoutManagerInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutUserProfileInput = {
    id?: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandUncheckedCreateNestedManyWithoutOwnerInput
    Location?: LocationUncheckedCreateNestedManyWithoutManagerInput
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutUserProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpsertWithoutUserProfileInput = {
    update: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserUpdateWithoutUserProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUpdateManyWithoutOwnerNestedInput
    Location?: LocationUpdateManyWithoutManagerNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUncheckedUpdateManyWithoutOwnerNestedInput
    Location?: LocationUncheckedUpdateManyWithoutManagerNestedInput
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateWithoutBrandInput = {
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationCreateNestedManyWithoutManagerInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutStaffInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBrandInput = {
    id?: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationUncheckedCreateNestedManyWithoutManagerInput
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutStaffInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBrandInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBrandInput, UserUncheckedCreateWithoutBrandInput>
  }

  export type LocationCreateWithoutBrandInput = {
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutLocationInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutLocationInput
    Menu?: MenuCreateNestedManyWithoutLocationInput
    Order?: OrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutBrandInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutLocationInput
    Menu?: MenuUncheckedCreateNestedManyWithoutLocationInput
    Order?: OrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutBrandInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutBrandInput, LocationUncheckedCreateWithoutBrandInput>
  }

  export type LocationCreateManyBrandInputEnvelope = {
    data: LocationCreateManyBrandInput | LocationCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type MenuTemplateCreateWithoutBrandInput = {
    name: string
    createdAt?: Date | string
    items?: TemplateItemCreateNestedManyWithoutTemplateInput
    Menu?: MenuCreateNestedManyWithoutTemplateInput
    Addon?: AddonCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUncheckedCreateWithoutBrandInput = {
    id?: number
    name: string
    createdAt?: Date | string
    items?: TemplateItemUncheckedCreateNestedManyWithoutTemplateInput
    Menu?: MenuUncheckedCreateNestedManyWithoutTemplateInput
    Addon?: AddonUncheckedCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateCreateOrConnectWithoutBrandInput = {
    where: MenuTemplateWhereUniqueInput
    create: XOR<MenuTemplateCreateWithoutBrandInput, MenuTemplateUncheckedCreateWithoutBrandInput>
  }

  export type MenuTemplateCreateManyBrandInputEnvelope = {
    data: MenuTemplateCreateManyBrandInput | MenuTemplateCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBrandInput = {
    update: XOR<UserUpdateWithoutBrandInput, UserUncheckedUpdateWithoutBrandInput>
    create: XOR<UserCreateWithoutBrandInput, UserUncheckedCreateWithoutBrandInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBrandInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBrandInput, UserUncheckedUpdateWithoutBrandInput>
  }

  export type UserUpdateWithoutBrandInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUpdateManyWithoutManagerNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutStaffNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUncheckedUpdateManyWithoutManagerNestedInput
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutStaffNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LocationUpsertWithWhereUniqueWithoutBrandInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutBrandInput, LocationUncheckedUpdateWithoutBrandInput>
    create: XOR<LocationCreateWithoutBrandInput, LocationUncheckedCreateWithoutBrandInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutBrandInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutBrandInput, LocationUncheckedUpdateWithoutBrandInput>
  }

  export type LocationUpdateManyWithWhereWithoutBrandInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutBrandInput>
  }

  export type MenuTemplateUpsertWithWhereUniqueWithoutBrandInput = {
    where: MenuTemplateWhereUniqueInput
    update: XOR<MenuTemplateUpdateWithoutBrandInput, MenuTemplateUncheckedUpdateWithoutBrandInput>
    create: XOR<MenuTemplateCreateWithoutBrandInput, MenuTemplateUncheckedCreateWithoutBrandInput>
  }

  export type MenuTemplateUpdateWithWhereUniqueWithoutBrandInput = {
    where: MenuTemplateWhereUniqueInput
    data: XOR<MenuTemplateUpdateWithoutBrandInput, MenuTemplateUncheckedUpdateWithoutBrandInput>
  }

  export type MenuTemplateUpdateManyWithWhereWithoutBrandInput = {
    where: MenuTemplateScalarWhereInput
    data: XOR<MenuTemplateUpdateManyMutationInput, MenuTemplateUncheckedUpdateManyWithoutBrandInput>
  }

  export type MenuTemplateScalarWhereInput = {
    AND?: MenuTemplateScalarWhereInput | MenuTemplateScalarWhereInput[]
    OR?: MenuTemplateScalarWhereInput[]
    NOT?: MenuTemplateScalarWhereInput | MenuTemplateScalarWhereInput[]
    id?: IntFilter<"MenuTemplate"> | number
    name?: StringFilter<"MenuTemplate"> | string
    brandId?: IntFilter<"MenuTemplate"> | number
    createdAt?: DateTimeFilter<"MenuTemplate"> | Date | string
  }

  export type UserCreateWithoutLocationInput = {
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandCreateNestedManyWithoutOwnerInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutStaffInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLocationInput = {
    id?: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandUncheckedCreateNestedManyWithoutOwnerInput
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutStaffInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type BrandCreateWithoutLocationInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBrandInput
    MenuTemplate?: MenuTemplateCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutLocationInput = {
    id?: number
    name: string
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MenuTemplate?: MenuTemplateUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutLocationInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutLocationInput, BrandUncheckedCreateWithoutLocationInput>
  }

  export type LocationStaffCreateWithoutLocationInput = {
    staff: UserCreateNestedOneWithoutLocationStaffInput
  }

  export type LocationStaffUncheckedCreateWithoutLocationInput = {
    id?: number
    staffId: number
  }

  export type LocationStaffCreateOrConnectWithoutLocationInput = {
    where: LocationStaffWhereUniqueInput
    create: XOR<LocationStaffCreateWithoutLocationInput, LocationStaffUncheckedCreateWithoutLocationInput>
  }

  export type LocationStaffCreateManyLocationInputEnvelope = {
    data: LocationStaffCreateManyLocationInput | LocationStaffCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type MenuCreateWithoutLocationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    template: MenuTemplateCreateNestedOneWithoutMenuInput
    overrides?: MenuItemOverrideCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutLocationInput = {
    id?: number
    templateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: MenuItemOverrideUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutLocationInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput>
  }

  export type MenuCreateManyLocationInputEnvelope = {
    data: MenuCreateManyLocationInput | MenuCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutLocationInput = {
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    Customer: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutLocationInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerId: number
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutLocationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderCreateManyLocationInputEnvelope = {
    data: OrderCreateManyLocationInput | OrderCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLocationInput = {
    update: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLocationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
  }

  export type UserUpdateWithoutLocationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUpdateManyWithoutOwnerNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutStaffNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUncheckedUpdateManyWithoutOwnerNestedInput
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutStaffNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BrandUpsertWithoutLocationInput = {
    update: XOR<BrandUpdateWithoutLocationInput, BrandUncheckedUpdateWithoutLocationInput>
    create: XOR<BrandCreateWithoutLocationInput, BrandUncheckedCreateWithoutLocationInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutLocationInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutLocationInput, BrandUncheckedUpdateWithoutLocationInput>
  }

  export type BrandUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBrandNestedInput
    MenuTemplate?: MenuTemplateUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MenuTemplate?: MenuTemplateUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type LocationStaffUpsertWithWhereUniqueWithoutLocationInput = {
    where: LocationStaffWhereUniqueInput
    update: XOR<LocationStaffUpdateWithoutLocationInput, LocationStaffUncheckedUpdateWithoutLocationInput>
    create: XOR<LocationStaffCreateWithoutLocationInput, LocationStaffUncheckedCreateWithoutLocationInput>
  }

  export type LocationStaffUpdateWithWhereUniqueWithoutLocationInput = {
    where: LocationStaffWhereUniqueInput
    data: XOR<LocationStaffUpdateWithoutLocationInput, LocationStaffUncheckedUpdateWithoutLocationInput>
  }

  export type LocationStaffUpdateManyWithWhereWithoutLocationInput = {
    where: LocationStaffScalarWhereInput
    data: XOR<LocationStaffUpdateManyMutationInput, LocationStaffUncheckedUpdateManyWithoutLocationInput>
  }

  export type MenuUpsertWithWhereUniqueWithoutLocationInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutLocationInput, MenuUncheckedUpdateWithoutLocationInput>
    create: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutLocationInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutLocationInput, MenuUncheckedUpdateWithoutLocationInput>
  }

  export type MenuUpdateManyWithWhereWithoutLocationInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutLocationInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: IntFilter<"Menu"> | number
    locationId?: IntFilter<"Menu"> | number
    templateId?: IntFilter<"Menu"> | number
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
  }

  export type OrderUpdateManyWithWhereWithoutLocationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    locationId?: IntFilter<"Order"> | number
    CustomerId?: IntFilter<"Order"> | number
  }

  export type LocationCreateWithoutLocationStaffInput = {
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutLocationInput
    Brand: BrandCreateNestedOneWithoutLocationInput
    Menu?: MenuCreateNestedManyWithoutLocationInput
    Order?: OrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutLocationStaffInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
    Menu?: MenuUncheckedCreateNestedManyWithoutLocationInput
    Order?: OrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutLocationStaffInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutLocationStaffInput, LocationUncheckedCreateWithoutLocationStaffInput>
  }

  export type UserCreateWithoutLocationStaffInput = {
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandCreateNestedManyWithoutOwnerInput
    Location?: LocationCreateNestedManyWithoutManagerInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLocationStaffInput = {
    id?: number
    email: string
    password: string
    role: $Enums.UserRole
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brand?: BrandUncheckedCreateNestedManyWithoutOwnerInput
    Location?: LocationUncheckedCreateNestedManyWithoutManagerInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLocationStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationStaffInput, UserUncheckedCreateWithoutLocationStaffInput>
  }

  export type LocationUpsertWithoutLocationStaffInput = {
    update: XOR<LocationUpdateWithoutLocationStaffInput, LocationUncheckedUpdateWithoutLocationStaffInput>
    create: XOR<LocationCreateWithoutLocationStaffInput, LocationUncheckedCreateWithoutLocationStaffInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutLocationStaffInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutLocationStaffInput, LocationUncheckedUpdateWithoutLocationStaffInput>
  }

  export type LocationUpdateWithoutLocationStaffInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutLocationNestedInput
    Brand?: BrandUpdateOneRequiredWithoutLocationNestedInput
    Menu?: MenuUpdateManyWithoutLocationNestedInput
    Order?: OrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutLocationStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
    Menu?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    Order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserUpsertWithoutLocationStaffInput = {
    update: XOR<UserUpdateWithoutLocationStaffInput, UserUncheckedUpdateWithoutLocationStaffInput>
    create: XOR<UserCreateWithoutLocationStaffInput, UserUncheckedCreateWithoutLocationStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLocationStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLocationStaffInput, UserUncheckedUpdateWithoutLocationStaffInput>
  }

  export type UserUpdateWithoutLocationStaffInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUpdateManyWithoutOwnerNestedInput
    Location?: LocationUpdateManyWithoutManagerNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUncheckedUpdateManyWithoutOwnerNestedInput
    Location?: LocationUncheckedUpdateManyWithoutManagerNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BrandCreateWithoutMenuTemplateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBrandInput
    Location?: LocationCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutMenuTemplateInput = {
    id?: number
    name: string
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutMenuTemplateInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutMenuTemplateInput, BrandUncheckedCreateWithoutMenuTemplateInput>
  }

  export type TemplateItemCreateWithoutTemplateInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutTemplateInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutTemplateInput, TemplateItemUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateItemCreateManyTemplateInputEnvelope = {
    data: TemplateItemCreateManyTemplateInput | TemplateItemCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type MenuCreateWithoutTemplateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutMenuInput
    overrides?: MenuItemOverrideCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutTemplateInput = {
    id?: number
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: MenuItemOverrideUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutTemplateInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutTemplateInput, MenuUncheckedCreateWithoutTemplateInput>
  }

  export type MenuCreateManyTemplateInputEnvelope = {
    data: MenuCreateManyTemplateInput | MenuCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type AddonCreateWithoutTemplateInput = {
    name: string
    price: number
    category: AddonCategoryCreateNestedOneWithoutAddonsInput
    items?: TemplateItemAddonCreateNestedManyWithoutAddonInput
  }

  export type AddonUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    price: number
    categoryId: number
    items?: TemplateItemAddonUncheckedCreateNestedManyWithoutAddonInput
  }

  export type AddonCreateOrConnectWithoutTemplateInput = {
    where: AddonWhereUniqueInput
    create: XOR<AddonCreateWithoutTemplateInput, AddonUncheckedCreateWithoutTemplateInput>
  }

  export type AddonCreateManyTemplateInputEnvelope = {
    data: AddonCreateManyTemplateInput | AddonCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type AddonCategoryCreateWithoutTemplateInput = {
    name: string
    maxSelectable?: number
    isRequired?: boolean
    addons?: AddonCreateNestedManyWithoutCategoryInput
  }

  export type AddonCategoryUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    maxSelectable?: number
    isRequired?: boolean
    addons?: AddonUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AddonCategoryCreateOrConnectWithoutTemplateInput = {
    where: AddonCategoryWhereUniqueInput
    create: XOR<AddonCategoryCreateWithoutTemplateInput, AddonCategoryUncheckedCreateWithoutTemplateInput>
  }

  export type AddonCategoryCreateManyTemplateInputEnvelope = {
    data: AddonCategoryCreateManyTemplateInput | AddonCategoryCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutMenuTemplateInput = {
    update: XOR<BrandUpdateWithoutMenuTemplateInput, BrandUncheckedUpdateWithoutMenuTemplateInput>
    create: XOR<BrandCreateWithoutMenuTemplateInput, BrandUncheckedCreateWithoutMenuTemplateInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutMenuTemplateInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutMenuTemplateInput, BrandUncheckedUpdateWithoutMenuTemplateInput>
  }

  export type BrandUpdateWithoutMenuTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBrandNestedInput
    Location?: LocationUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutMenuTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type TemplateItemUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplateItemWhereUniqueInput
    update: XOR<TemplateItemUpdateWithoutTemplateInput, TemplateItemUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplateItemCreateWithoutTemplateInput, TemplateItemUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateItemUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplateItemWhereUniqueInput
    data: XOR<TemplateItemUpdateWithoutTemplateInput, TemplateItemUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateItemUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplateItemScalarWhereInput
    data: XOR<TemplateItemUpdateManyMutationInput, TemplateItemUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateItemScalarWhereInput = {
    AND?: TemplateItemScalarWhereInput | TemplateItemScalarWhereInput[]
    OR?: TemplateItemScalarWhereInput[]
    NOT?: TemplateItemScalarWhereInput | TemplateItemScalarWhereInput[]
    id?: IntFilter<"TemplateItem"> | number
    name?: StringFilter<"TemplateItem"> | string
    description?: StringNullableFilter<"TemplateItem"> | string | null
    imageUrl?: StringNullableFilter<"TemplateItem"> | string | null
    category?: StringNullableFilter<"TemplateItem"> | string | null
    templateId?: IntFilter<"TemplateItem"> | number
  }

  export type MenuUpsertWithWhereUniqueWithoutTemplateInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutTemplateInput, MenuUncheckedUpdateWithoutTemplateInput>
    create: XOR<MenuCreateWithoutTemplateInput, MenuUncheckedCreateWithoutTemplateInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutTemplateInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutTemplateInput, MenuUncheckedUpdateWithoutTemplateInput>
  }

  export type MenuUpdateManyWithWhereWithoutTemplateInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AddonUpsertWithWhereUniqueWithoutTemplateInput = {
    where: AddonWhereUniqueInput
    update: XOR<AddonUpdateWithoutTemplateInput, AddonUncheckedUpdateWithoutTemplateInput>
    create: XOR<AddonCreateWithoutTemplateInput, AddonUncheckedCreateWithoutTemplateInput>
  }

  export type AddonUpdateWithWhereUniqueWithoutTemplateInput = {
    where: AddonWhereUniqueInput
    data: XOR<AddonUpdateWithoutTemplateInput, AddonUncheckedUpdateWithoutTemplateInput>
  }

  export type AddonUpdateManyWithWhereWithoutTemplateInput = {
    where: AddonScalarWhereInput
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AddonScalarWhereInput = {
    AND?: AddonScalarWhereInput | AddonScalarWhereInput[]
    OR?: AddonScalarWhereInput[]
    NOT?: AddonScalarWhereInput | AddonScalarWhereInput[]
    id?: IntFilter<"Addon"> | number
    name?: StringFilter<"Addon"> | string
    price?: FloatFilter<"Addon"> | number
    categoryId?: IntFilter<"Addon"> | number
    templateId?: IntFilter<"Addon"> | number
  }

  export type AddonCategoryUpsertWithWhereUniqueWithoutTemplateInput = {
    where: AddonCategoryWhereUniqueInput
    update: XOR<AddonCategoryUpdateWithoutTemplateInput, AddonCategoryUncheckedUpdateWithoutTemplateInput>
    create: XOR<AddonCategoryCreateWithoutTemplateInput, AddonCategoryUncheckedCreateWithoutTemplateInput>
  }

  export type AddonCategoryUpdateWithWhereUniqueWithoutTemplateInput = {
    where: AddonCategoryWhereUniqueInput
    data: XOR<AddonCategoryUpdateWithoutTemplateInput, AddonCategoryUncheckedUpdateWithoutTemplateInput>
  }

  export type AddonCategoryUpdateManyWithWhereWithoutTemplateInput = {
    where: AddonCategoryScalarWhereInput
    data: XOR<AddonCategoryUpdateManyMutationInput, AddonCategoryUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AddonCategoryScalarWhereInput = {
    AND?: AddonCategoryScalarWhereInput | AddonCategoryScalarWhereInput[]
    OR?: AddonCategoryScalarWhereInput[]
    NOT?: AddonCategoryScalarWhereInput | AddonCategoryScalarWhereInput[]
    id?: IntFilter<"AddonCategory"> | number
    name?: StringFilter<"AddonCategory"> | string
    maxSelectable?: IntFilter<"AddonCategory"> | number
    isRequired?: BoolFilter<"AddonCategory"> | boolean
    templateId?: IntFilter<"AddonCategory"> | number
  }

  export type MenuTemplateCreateWithoutItemsInput = {
    name: string
    createdAt?: Date | string
    brand: BrandCreateNestedOneWithoutMenuTemplateInput
    Menu?: MenuCreateNestedManyWithoutTemplateInput
    Addon?: AddonCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    brandId: number
    createdAt?: Date | string
    Menu?: MenuUncheckedCreateNestedManyWithoutTemplateInput
    Addon?: AddonUncheckedCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateCreateOrConnectWithoutItemsInput = {
    where: MenuTemplateWhereUniqueInput
    create: XOR<MenuTemplateCreateWithoutItemsInput, MenuTemplateUncheckedCreateWithoutItemsInput>
  }

  export type TemplateItemVariantCreateWithoutTemplateItemInput = {
    label: string
    price: number
    OrderItem?: OrderItemCreateNestedManyWithoutVariantInput
  }

  export type TemplateItemVariantUncheckedCreateWithoutTemplateItemInput = {
    id?: number
    label: string
    price: number
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type TemplateItemVariantCreateOrConnectWithoutTemplateItemInput = {
    where: TemplateItemVariantWhereUniqueInput
    create: XOR<TemplateItemVariantCreateWithoutTemplateItemInput, TemplateItemVariantUncheckedCreateWithoutTemplateItemInput>
  }

  export type TemplateItemVariantCreateManyTemplateItemInputEnvelope = {
    data: TemplateItemVariantCreateManyTemplateItemInput | TemplateItemVariantCreateManyTemplateItemInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemOverrideCreateWithoutTemplateItemInput = {
    isAvailable?: boolean | null
    priceOverride?: number | null
    menu: MenuCreateNestedOneWithoutOverridesInput
  }

  export type MenuItemOverrideUncheckedCreateWithoutTemplateItemInput = {
    id?: number
    menuId: number
    isAvailable?: boolean | null
    priceOverride?: number | null
  }

  export type MenuItemOverrideCreateOrConnectWithoutTemplateItemInput = {
    where: MenuItemOverrideWhereUniqueInput
    create: XOR<MenuItemOverrideCreateWithoutTemplateItemInput, MenuItemOverrideUncheckedCreateWithoutTemplateItemInput>
  }

  export type MenuItemOverrideCreateManyTemplateItemInputEnvelope = {
    data: MenuItemOverrideCreateManyTemplateItemInput | MenuItemOverrideCreateManyTemplateItemInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutTemplateItemInput = {
    name: string
    items?: TemplateItemTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTemplateItemInput = {
    id?: number
    name: string
    items?: TemplateItemTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTemplateItemInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTemplateItemInput, TagUncheckedCreateWithoutTemplateItemInput>
  }

  export type OrderItemCreateWithoutTemplateItemInput = {
    quantity: number
    unitPrice: number
    order: OrderCreateNestedOneWithoutItemsInput
    variant?: TemplateItemVariantCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutTemplateItemInput = {
    id?: number
    orderId: number
    variantId?: number | null
    quantity: number
    unitPrice: number
  }

  export type OrderItemCreateOrConnectWithoutTemplateItemInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutTemplateItemInput, OrderItemUncheckedCreateWithoutTemplateItemInput>
  }

  export type OrderItemCreateManyTemplateItemInputEnvelope = {
    data: OrderItemCreateManyTemplateItemInput | OrderItemCreateManyTemplateItemInput[]
    skipDuplicates?: boolean
  }

  export type TemplateItemTagCreateWithoutTemplateItemInput = {
    tag: TagCreateNestedOneWithoutItemsInput
  }

  export type TemplateItemTagUncheckedCreateWithoutTemplateItemInput = {
    id?: number
    tagId: number
  }

  export type TemplateItemTagCreateOrConnectWithoutTemplateItemInput = {
    where: TemplateItemTagWhereUniqueInput
    create: XOR<TemplateItemTagCreateWithoutTemplateItemInput, TemplateItemTagUncheckedCreateWithoutTemplateItemInput>
  }

  export type TemplateItemTagCreateManyTemplateItemInputEnvelope = {
    data: TemplateItemTagCreateManyTemplateItemInput | TemplateItemTagCreateManyTemplateItemInput[]
    skipDuplicates?: boolean
  }

  export type TemplateItemAddonCreateWithoutTemplateItemInput = {
    addon: AddonCreateNestedOneWithoutItemsInput
  }

  export type TemplateItemAddonUncheckedCreateWithoutTemplateItemInput = {
    id?: number
    addonId: number
  }

  export type TemplateItemAddonCreateOrConnectWithoutTemplateItemInput = {
    where: TemplateItemAddonWhereUniqueInput
    create: XOR<TemplateItemAddonCreateWithoutTemplateItemInput, TemplateItemAddonUncheckedCreateWithoutTemplateItemInput>
  }

  export type TemplateItemAddonCreateManyTemplateItemInputEnvelope = {
    data: TemplateItemAddonCreateManyTemplateItemInput | TemplateItemAddonCreateManyTemplateItemInput[]
    skipDuplicates?: boolean
  }

  export type MenuTemplateUpsertWithoutItemsInput = {
    update: XOR<MenuTemplateUpdateWithoutItemsInput, MenuTemplateUncheckedUpdateWithoutItemsInput>
    create: XOR<MenuTemplateCreateWithoutItemsInput, MenuTemplateUncheckedCreateWithoutItemsInput>
    where?: MenuTemplateWhereInput
  }

  export type MenuTemplateUpdateToOneWithWhereWithoutItemsInput = {
    where?: MenuTemplateWhereInput
    data: XOR<MenuTemplateUpdateWithoutItemsInput, MenuTemplateUncheckedUpdateWithoutItemsInput>
  }

  export type MenuTemplateUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutMenuTemplateNestedInput
    Menu?: MenuUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Menu?: MenuUncheckedUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUncheckedUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateItemVariantUpsertWithWhereUniqueWithoutTemplateItemInput = {
    where: TemplateItemVariantWhereUniqueInput
    update: XOR<TemplateItemVariantUpdateWithoutTemplateItemInput, TemplateItemVariantUncheckedUpdateWithoutTemplateItemInput>
    create: XOR<TemplateItemVariantCreateWithoutTemplateItemInput, TemplateItemVariantUncheckedCreateWithoutTemplateItemInput>
  }

  export type TemplateItemVariantUpdateWithWhereUniqueWithoutTemplateItemInput = {
    where: TemplateItemVariantWhereUniqueInput
    data: XOR<TemplateItemVariantUpdateWithoutTemplateItemInput, TemplateItemVariantUncheckedUpdateWithoutTemplateItemInput>
  }

  export type TemplateItemVariantUpdateManyWithWhereWithoutTemplateItemInput = {
    where: TemplateItemVariantScalarWhereInput
    data: XOR<TemplateItemVariantUpdateManyMutationInput, TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemInput>
  }

  export type TemplateItemVariantScalarWhereInput = {
    AND?: TemplateItemVariantScalarWhereInput | TemplateItemVariantScalarWhereInput[]
    OR?: TemplateItemVariantScalarWhereInput[]
    NOT?: TemplateItemVariantScalarWhereInput | TemplateItemVariantScalarWhereInput[]
    id?: IntFilter<"TemplateItemVariant"> | number
    label?: StringFilter<"TemplateItemVariant"> | string
    price?: FloatFilter<"TemplateItemVariant"> | number
    itemId?: IntFilter<"TemplateItemVariant"> | number
  }

  export type MenuItemOverrideUpsertWithWhereUniqueWithoutTemplateItemInput = {
    where: MenuItemOverrideWhereUniqueInput
    update: XOR<MenuItemOverrideUpdateWithoutTemplateItemInput, MenuItemOverrideUncheckedUpdateWithoutTemplateItemInput>
    create: XOR<MenuItemOverrideCreateWithoutTemplateItemInput, MenuItemOverrideUncheckedCreateWithoutTemplateItemInput>
  }

  export type MenuItemOverrideUpdateWithWhereUniqueWithoutTemplateItemInput = {
    where: MenuItemOverrideWhereUniqueInput
    data: XOR<MenuItemOverrideUpdateWithoutTemplateItemInput, MenuItemOverrideUncheckedUpdateWithoutTemplateItemInput>
  }

  export type MenuItemOverrideUpdateManyWithWhereWithoutTemplateItemInput = {
    where: MenuItemOverrideScalarWhereInput
    data: XOR<MenuItemOverrideUpdateManyMutationInput, MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemInput>
  }

  export type MenuItemOverrideScalarWhereInput = {
    AND?: MenuItemOverrideScalarWhereInput | MenuItemOverrideScalarWhereInput[]
    OR?: MenuItemOverrideScalarWhereInput[]
    NOT?: MenuItemOverrideScalarWhereInput | MenuItemOverrideScalarWhereInput[]
    id?: IntFilter<"MenuItemOverride"> | number
    menuId?: IntFilter<"MenuItemOverride"> | number
    templateItemId?: IntFilter<"MenuItemOverride"> | number
    isAvailable?: BoolNullableFilter<"MenuItemOverride"> | boolean | null
    priceOverride?: FloatNullableFilter<"MenuItemOverride"> | number | null
  }

  export type TagUpsertWithWhereUniqueWithoutTemplateItemInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTemplateItemInput, TagUncheckedUpdateWithoutTemplateItemInput>
    create: XOR<TagCreateWithoutTemplateItemInput, TagUncheckedCreateWithoutTemplateItemInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTemplateItemInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTemplateItemInput, TagUncheckedUpdateWithoutTemplateItemInput>
  }

  export type TagUpdateManyWithWhereWithoutTemplateItemInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTemplateItemInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutTemplateItemInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutTemplateItemInput, OrderItemUncheckedUpdateWithoutTemplateItemInput>
    create: XOR<OrderItemCreateWithoutTemplateItemInput, OrderItemUncheckedCreateWithoutTemplateItemInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutTemplateItemInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutTemplateItemInput, OrderItemUncheckedUpdateWithoutTemplateItemInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutTemplateItemInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutTemplateItemInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    templateItemId?: IntFilter<"OrderItem"> | number
    variantId?: IntNullableFilter<"OrderItem"> | number | null
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
  }

  export type TemplateItemTagUpsertWithWhereUniqueWithoutTemplateItemInput = {
    where: TemplateItemTagWhereUniqueInput
    update: XOR<TemplateItemTagUpdateWithoutTemplateItemInput, TemplateItemTagUncheckedUpdateWithoutTemplateItemInput>
    create: XOR<TemplateItemTagCreateWithoutTemplateItemInput, TemplateItemTagUncheckedCreateWithoutTemplateItemInput>
  }

  export type TemplateItemTagUpdateWithWhereUniqueWithoutTemplateItemInput = {
    where: TemplateItemTagWhereUniqueInput
    data: XOR<TemplateItemTagUpdateWithoutTemplateItemInput, TemplateItemTagUncheckedUpdateWithoutTemplateItemInput>
  }

  export type TemplateItemTagUpdateManyWithWhereWithoutTemplateItemInput = {
    where: TemplateItemTagScalarWhereInput
    data: XOR<TemplateItemTagUpdateManyMutationInput, TemplateItemTagUncheckedUpdateManyWithoutTemplateItemInput>
  }

  export type TemplateItemTagScalarWhereInput = {
    AND?: TemplateItemTagScalarWhereInput | TemplateItemTagScalarWhereInput[]
    OR?: TemplateItemTagScalarWhereInput[]
    NOT?: TemplateItemTagScalarWhereInput | TemplateItemTagScalarWhereInput[]
    id?: IntFilter<"TemplateItemTag"> | number
    itemId?: IntFilter<"TemplateItemTag"> | number
    tagId?: IntFilter<"TemplateItemTag"> | number
  }

  export type TemplateItemAddonUpsertWithWhereUniqueWithoutTemplateItemInput = {
    where: TemplateItemAddonWhereUniqueInput
    update: XOR<TemplateItemAddonUpdateWithoutTemplateItemInput, TemplateItemAddonUncheckedUpdateWithoutTemplateItemInput>
    create: XOR<TemplateItemAddonCreateWithoutTemplateItemInput, TemplateItemAddonUncheckedCreateWithoutTemplateItemInput>
  }

  export type TemplateItemAddonUpdateWithWhereUniqueWithoutTemplateItemInput = {
    where: TemplateItemAddonWhereUniqueInput
    data: XOR<TemplateItemAddonUpdateWithoutTemplateItemInput, TemplateItemAddonUncheckedUpdateWithoutTemplateItemInput>
  }

  export type TemplateItemAddonUpdateManyWithWhereWithoutTemplateItemInput = {
    where: TemplateItemAddonScalarWhereInput
    data: XOR<TemplateItemAddonUpdateManyMutationInput, TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemInput>
  }

  export type TemplateItemAddonScalarWhereInput = {
    AND?: TemplateItemAddonScalarWhereInput | TemplateItemAddonScalarWhereInput[]
    OR?: TemplateItemAddonScalarWhereInput[]
    NOT?: TemplateItemAddonScalarWhereInput | TemplateItemAddonScalarWhereInput[]
    id?: IntFilter<"TemplateItemAddon"> | number
    itemId?: IntFilter<"TemplateItemAddon"> | number
    addonId?: IntFilter<"TemplateItemAddon"> | number
  }

  export type TemplateItemCreateWithoutVariantsInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutVariantsInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutVariantsInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutVariantsInput, TemplateItemUncheckedCreateWithoutVariantsInput>
  }

  export type OrderItemCreateWithoutVariantInput = {
    quantity: number
    unitPrice: number
    order: OrderCreateNestedOneWithoutItemsInput
    templateItem: TemplateItemCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutVariantInput = {
    id?: number
    orderId: number
    templateItemId: number
    quantity: number
    unitPrice: number
  }

  export type OrderItemCreateOrConnectWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
  }

  export type OrderItemCreateManyVariantInputEnvelope = {
    data: OrderItemCreateManyVariantInput | OrderItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type TemplateItemUpsertWithoutVariantsInput = {
    update: XOR<TemplateItemUpdateWithoutVariantsInput, TemplateItemUncheckedUpdateWithoutVariantsInput>
    create: XOR<TemplateItemCreateWithoutVariantsInput, TemplateItemUncheckedCreateWithoutVariantsInput>
    where?: TemplateItemWhereInput
  }

  export type TemplateItemUpdateToOneWithWhereWithoutVariantsInput = {
    where?: TemplateItemWhereInput
    data: XOR<TemplateItemUpdateWithoutVariantsInput, TemplateItemUncheckedUpdateWithoutVariantsInput>
  }

  export type TemplateItemUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutVariantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutVariantInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type LocationCreateWithoutMenuInput = {
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutLocationInput
    Brand: BrandCreateNestedOneWithoutLocationInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutLocationInput
    Order?: OrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutMenuInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutLocationInput
    Order?: OrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutMenuInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutMenuInput, LocationUncheckedCreateWithoutMenuInput>
  }

  export type MenuTemplateCreateWithoutMenuInput = {
    name: string
    createdAt?: Date | string
    brand: BrandCreateNestedOneWithoutMenuTemplateInput
    items?: TemplateItemCreateNestedManyWithoutTemplateInput
    Addon?: AddonCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
    brandId: number
    createdAt?: Date | string
    items?: TemplateItemUncheckedCreateNestedManyWithoutTemplateInput
    Addon?: AddonUncheckedCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateCreateOrConnectWithoutMenuInput = {
    where: MenuTemplateWhereUniqueInput
    create: XOR<MenuTemplateCreateWithoutMenuInput, MenuTemplateUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemOverrideCreateWithoutMenuInput = {
    isAvailable?: boolean | null
    priceOverride?: number | null
    templateItem: TemplateItemCreateNestedOneWithoutMenuItemOverrideInput
  }

  export type MenuItemOverrideUncheckedCreateWithoutMenuInput = {
    id?: number
    templateItemId: number
    isAvailable?: boolean | null
    priceOverride?: number | null
  }

  export type MenuItemOverrideCreateOrConnectWithoutMenuInput = {
    where: MenuItemOverrideWhereUniqueInput
    create: XOR<MenuItemOverrideCreateWithoutMenuInput, MenuItemOverrideUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemOverrideCreateManyMenuInputEnvelope = {
    data: MenuItemOverrideCreateManyMenuInput | MenuItemOverrideCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutMenuInput = {
    update: XOR<LocationUpdateWithoutMenuInput, LocationUncheckedUpdateWithoutMenuInput>
    create: XOR<LocationCreateWithoutMenuInput, LocationUncheckedCreateWithoutMenuInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutMenuInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutMenuInput, LocationUncheckedUpdateWithoutMenuInput>
  }

  export type LocationUpdateWithoutMenuInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutLocationNestedInput
    Brand?: BrandUpdateOneRequiredWithoutLocationNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutLocationNestedInput
    Order?: OrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutLocationNestedInput
    Order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MenuTemplateUpsertWithoutMenuInput = {
    update: XOR<MenuTemplateUpdateWithoutMenuInput, MenuTemplateUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuTemplateCreateWithoutMenuInput, MenuTemplateUncheckedCreateWithoutMenuInput>
    where?: MenuTemplateWhereInput
  }

  export type MenuTemplateUpdateToOneWithWhereWithoutMenuInput = {
    where?: MenuTemplateWhereInput
    data: XOR<MenuTemplateUpdateWithoutMenuInput, MenuTemplateUncheckedUpdateWithoutMenuInput>
  }

  export type MenuTemplateUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutMenuTemplateNestedInput
    items?: TemplateItemUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateItemUncheckedUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUncheckedUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MenuItemOverrideUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuItemOverrideWhereUniqueInput
    update: XOR<MenuItemOverrideUpdateWithoutMenuInput, MenuItemOverrideUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuItemOverrideCreateWithoutMenuInput, MenuItemOverrideUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemOverrideUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuItemOverrideWhereUniqueInput
    data: XOR<MenuItemOverrideUpdateWithoutMenuInput, MenuItemOverrideUncheckedUpdateWithoutMenuInput>
  }

  export type MenuItemOverrideUpdateManyWithWhereWithoutMenuInput = {
    where: MenuItemOverrideScalarWhereInput
    data: XOR<MenuItemOverrideUpdateManyMutationInput, MenuItemOverrideUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuCreateWithoutOverridesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutMenuInput
    template: MenuTemplateCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutOverridesInput = {
    id?: number
    locationId: number
    templateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutOverridesInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutOverridesInput, MenuUncheckedCreateWithoutOverridesInput>
  }

  export type TemplateItemCreateWithoutMenuItemOverrideInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutMenuItemOverrideInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutMenuItemOverrideInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutMenuItemOverrideInput, TemplateItemUncheckedCreateWithoutMenuItemOverrideInput>
  }

  export type MenuUpsertWithoutOverridesInput = {
    update: XOR<MenuUpdateWithoutOverridesInput, MenuUncheckedUpdateWithoutOverridesInput>
    create: XOR<MenuCreateWithoutOverridesInput, MenuUncheckedCreateWithoutOverridesInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutOverridesInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutOverridesInput, MenuUncheckedUpdateWithoutOverridesInput>
  }

  export type MenuUpdateWithoutOverridesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutMenuNestedInput
    template?: MenuTemplateUpdateOneRequiredWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutOverridesInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateItemUpsertWithoutMenuItemOverrideInput = {
    update: XOR<TemplateItemUpdateWithoutMenuItemOverrideInput, TemplateItemUncheckedUpdateWithoutMenuItemOverrideInput>
    create: XOR<TemplateItemCreateWithoutMenuItemOverrideInput, TemplateItemUncheckedCreateWithoutMenuItemOverrideInput>
    where?: TemplateItemWhereInput
  }

  export type TemplateItemUpdateToOneWithWhereWithoutMenuItemOverrideInput = {
    where?: TemplateItemWhereInput
    data: XOR<TemplateItemUpdateWithoutMenuItemOverrideInput, TemplateItemUncheckedUpdateWithoutMenuItemOverrideInput>
  }

  export type TemplateItemUpdateWithoutMenuItemOverrideInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutMenuItemOverrideInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemTagCreateWithoutTagInput = {
    templateItem: TemplateItemCreateNestedOneWithoutTemplateItemTagInput
  }

  export type TemplateItemTagUncheckedCreateWithoutTagInput = {
    id?: number
    itemId: number
  }

  export type TemplateItemTagCreateOrConnectWithoutTagInput = {
    where: TemplateItemTagWhereUniqueInput
    create: XOR<TemplateItemTagCreateWithoutTagInput, TemplateItemTagUncheckedCreateWithoutTagInput>
  }

  export type TemplateItemTagCreateManyTagInputEnvelope = {
    data: TemplateItemTagCreateManyTagInput | TemplateItemTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TemplateItemCreateWithoutTagInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutTagInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutTagInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutTagInput, TemplateItemUncheckedCreateWithoutTagInput>
  }

  export type TemplateItemTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TemplateItemTagWhereUniqueInput
    update: XOR<TemplateItemTagUpdateWithoutTagInput, TemplateItemTagUncheckedUpdateWithoutTagInput>
    create: XOR<TemplateItemTagCreateWithoutTagInput, TemplateItemTagUncheckedCreateWithoutTagInput>
  }

  export type TemplateItemTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TemplateItemTagWhereUniqueInput
    data: XOR<TemplateItemTagUpdateWithoutTagInput, TemplateItemTagUncheckedUpdateWithoutTagInput>
  }

  export type TemplateItemTagUpdateManyWithWhereWithoutTagInput = {
    where: TemplateItemTagScalarWhereInput
    data: XOR<TemplateItemTagUpdateManyMutationInput, TemplateItemTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TemplateItemUpsertWithWhereUniqueWithoutTagInput = {
    where: TemplateItemWhereUniqueInput
    update: XOR<TemplateItemUpdateWithoutTagInput, TemplateItemUncheckedUpdateWithoutTagInput>
    create: XOR<TemplateItemCreateWithoutTagInput, TemplateItemUncheckedCreateWithoutTagInput>
  }

  export type TemplateItemUpdateWithWhereUniqueWithoutTagInput = {
    where: TemplateItemWhereUniqueInput
    data: XOR<TemplateItemUpdateWithoutTagInput, TemplateItemUncheckedUpdateWithoutTagInput>
  }

  export type TemplateItemUpdateManyWithWhereWithoutTagInput = {
    where: TemplateItemScalarWhereInput
    data: XOR<TemplateItemUpdateManyMutationInput, TemplateItemUncheckedUpdateManyWithoutTagInput>
  }

  export type TemplateItemCreateWithoutTemplateItemTagInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutTemplateItemTagInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutTemplateItemTagInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutTemplateItemTagInput, TemplateItemUncheckedCreateWithoutTemplateItemTagInput>
  }

  export type TagCreateWithoutItemsInput = {
    name: string
    TemplateItem?: TemplateItemCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    TemplateItem?: TemplateItemUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutItemsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutItemsInput, TagUncheckedCreateWithoutItemsInput>
  }

  export type TemplateItemUpsertWithoutTemplateItemTagInput = {
    update: XOR<TemplateItemUpdateWithoutTemplateItemTagInput, TemplateItemUncheckedUpdateWithoutTemplateItemTagInput>
    create: XOR<TemplateItemCreateWithoutTemplateItemTagInput, TemplateItemUncheckedCreateWithoutTemplateItemTagInput>
    where?: TemplateItemWhereInput
  }

  export type TemplateItemUpdateToOneWithWhereWithoutTemplateItemTagInput = {
    where?: TemplateItemWhereInput
    data: XOR<TemplateItemUpdateWithoutTemplateItemTagInput, TemplateItemUncheckedUpdateWithoutTemplateItemTagInput>
  }

  export type TemplateItemUpdateWithoutTemplateItemTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutTemplateItemTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type TagUpsertWithoutItemsInput = {
    update: XOR<TagUpdateWithoutItemsInput, TagUncheckedUpdateWithoutItemsInput>
    create: XOR<TagCreateWithoutItemsInput, TagUncheckedCreateWithoutItemsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutItemsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutItemsInput, TagUncheckedUpdateWithoutItemsInput>
  }

  export type TagUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    TemplateItem?: TemplateItemUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    TemplateItem?: TemplateItemUncheckedUpdateManyWithoutTagNestedInput
  }

  export type AddonCategoryCreateWithoutAddonsInput = {
    name: string
    maxSelectable?: number
    isRequired?: boolean
    template: MenuTemplateCreateNestedOneWithoutAddonCategoryInput
  }

  export type AddonCategoryUncheckedCreateWithoutAddonsInput = {
    id?: number
    name: string
    maxSelectable?: number
    isRequired?: boolean
    templateId: number
  }

  export type AddonCategoryCreateOrConnectWithoutAddonsInput = {
    where: AddonCategoryWhereUniqueInput
    create: XOR<AddonCategoryCreateWithoutAddonsInput, AddonCategoryUncheckedCreateWithoutAddonsInput>
  }

  export type MenuTemplateCreateWithoutAddonInput = {
    name: string
    createdAt?: Date | string
    brand: BrandCreateNestedOneWithoutMenuTemplateInput
    items?: TemplateItemCreateNestedManyWithoutTemplateInput
    Menu?: MenuCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUncheckedCreateWithoutAddonInput = {
    id?: number
    name: string
    brandId: number
    createdAt?: Date | string
    items?: TemplateItemUncheckedCreateNestedManyWithoutTemplateInput
    Menu?: MenuUncheckedCreateNestedManyWithoutTemplateInput
    AddonCategory?: AddonCategoryUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateCreateOrConnectWithoutAddonInput = {
    where: MenuTemplateWhereUniqueInput
    create: XOR<MenuTemplateCreateWithoutAddonInput, MenuTemplateUncheckedCreateWithoutAddonInput>
  }

  export type TemplateItemAddonCreateWithoutAddonInput = {
    templateItem: TemplateItemCreateNestedOneWithoutTemplateItemAddonInput
  }

  export type TemplateItemAddonUncheckedCreateWithoutAddonInput = {
    id?: number
    itemId: number
  }

  export type TemplateItemAddonCreateOrConnectWithoutAddonInput = {
    where: TemplateItemAddonWhereUniqueInput
    create: XOR<TemplateItemAddonCreateWithoutAddonInput, TemplateItemAddonUncheckedCreateWithoutAddonInput>
  }

  export type TemplateItemAddonCreateManyAddonInputEnvelope = {
    data: TemplateItemAddonCreateManyAddonInput | TemplateItemAddonCreateManyAddonInput[]
    skipDuplicates?: boolean
  }

  export type AddonCategoryUpsertWithoutAddonsInput = {
    update: XOR<AddonCategoryUpdateWithoutAddonsInput, AddonCategoryUncheckedUpdateWithoutAddonsInput>
    create: XOR<AddonCategoryCreateWithoutAddonsInput, AddonCategoryUncheckedCreateWithoutAddonsInput>
    where?: AddonCategoryWhereInput
  }

  export type AddonCategoryUpdateToOneWithWhereWithoutAddonsInput = {
    where?: AddonCategoryWhereInput
    data: XOR<AddonCategoryUpdateWithoutAddonsInput, AddonCategoryUncheckedUpdateWithoutAddonsInput>
  }

  export type AddonCategoryUpdateWithoutAddonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    template?: MenuTemplateUpdateOneRequiredWithoutAddonCategoryNestedInput
  }

  export type AddonCategoryUncheckedUpdateWithoutAddonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuTemplateUpsertWithoutAddonInput = {
    update: XOR<MenuTemplateUpdateWithoutAddonInput, MenuTemplateUncheckedUpdateWithoutAddonInput>
    create: XOR<MenuTemplateCreateWithoutAddonInput, MenuTemplateUncheckedCreateWithoutAddonInput>
    where?: MenuTemplateWhereInput
  }

  export type MenuTemplateUpdateToOneWithWhereWithoutAddonInput = {
    where?: MenuTemplateWhereInput
    data: XOR<MenuTemplateUpdateWithoutAddonInput, MenuTemplateUncheckedUpdateWithoutAddonInput>
  }

  export type MenuTemplateUpdateWithoutAddonInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutMenuTemplateNestedInput
    items?: TemplateItemUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateWithoutAddonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateItemUncheckedUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateItemAddonUpsertWithWhereUniqueWithoutAddonInput = {
    where: TemplateItemAddonWhereUniqueInput
    update: XOR<TemplateItemAddonUpdateWithoutAddonInput, TemplateItemAddonUncheckedUpdateWithoutAddonInput>
    create: XOR<TemplateItemAddonCreateWithoutAddonInput, TemplateItemAddonUncheckedCreateWithoutAddonInput>
  }

  export type TemplateItemAddonUpdateWithWhereUniqueWithoutAddonInput = {
    where: TemplateItemAddonWhereUniqueInput
    data: XOR<TemplateItemAddonUpdateWithoutAddonInput, TemplateItemAddonUncheckedUpdateWithoutAddonInput>
  }

  export type TemplateItemAddonUpdateManyWithWhereWithoutAddonInput = {
    where: TemplateItemAddonScalarWhereInput
    data: XOR<TemplateItemAddonUpdateManyMutationInput, TemplateItemAddonUncheckedUpdateManyWithoutAddonInput>
  }

  export type TemplateItemCreateWithoutTemplateItemAddonInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutTemplateItemAddonInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutTemplateItemAddonInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutTemplateItemAddonInput, TemplateItemUncheckedCreateWithoutTemplateItemAddonInput>
  }

  export type AddonCreateWithoutItemsInput = {
    name: string
    price: number
    category: AddonCategoryCreateNestedOneWithoutAddonsInput
    template: MenuTemplateCreateNestedOneWithoutAddonInput
  }

  export type AddonUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    price: number
    categoryId: number
    templateId: number
  }

  export type AddonCreateOrConnectWithoutItemsInput = {
    where: AddonWhereUniqueInput
    create: XOR<AddonCreateWithoutItemsInput, AddonUncheckedCreateWithoutItemsInput>
  }

  export type TemplateItemUpsertWithoutTemplateItemAddonInput = {
    update: XOR<TemplateItemUpdateWithoutTemplateItemAddonInput, TemplateItemUncheckedUpdateWithoutTemplateItemAddonInput>
    create: XOR<TemplateItemCreateWithoutTemplateItemAddonInput, TemplateItemUncheckedCreateWithoutTemplateItemAddonInput>
    where?: TemplateItemWhereInput
  }

  export type TemplateItemUpdateToOneWithWhereWithoutTemplateItemAddonInput = {
    where?: TemplateItemWhereInput
    data: XOR<TemplateItemUpdateWithoutTemplateItemAddonInput, TemplateItemUncheckedUpdateWithoutTemplateItemAddonInput>
  }

  export type TemplateItemUpdateWithoutTemplateItemAddonInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutTemplateItemAddonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type AddonUpsertWithoutItemsInput = {
    update: XOR<AddonUpdateWithoutItemsInput, AddonUncheckedUpdateWithoutItemsInput>
    create: XOR<AddonCreateWithoutItemsInput, AddonUncheckedCreateWithoutItemsInput>
    where?: AddonWhereInput
  }

  export type AddonUpdateToOneWithWhereWithoutItemsInput = {
    where?: AddonWhereInput
    data: XOR<AddonUpdateWithoutItemsInput, AddonUncheckedUpdateWithoutItemsInput>
  }

  export type AddonUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: AddonCategoryUpdateOneRequiredWithoutAddonsNestedInput
    template?: MenuTemplateUpdateOneRequiredWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuTemplateCreateWithoutAddonCategoryInput = {
    name: string
    createdAt?: Date | string
    brand: BrandCreateNestedOneWithoutMenuTemplateInput
    items?: TemplateItemCreateNestedManyWithoutTemplateInput
    Menu?: MenuCreateNestedManyWithoutTemplateInput
    Addon?: AddonCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateUncheckedCreateWithoutAddonCategoryInput = {
    id?: number
    name: string
    brandId: number
    createdAt?: Date | string
    items?: TemplateItemUncheckedCreateNestedManyWithoutTemplateInput
    Menu?: MenuUncheckedCreateNestedManyWithoutTemplateInput
    Addon?: AddonUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MenuTemplateCreateOrConnectWithoutAddonCategoryInput = {
    where: MenuTemplateWhereUniqueInput
    create: XOR<MenuTemplateCreateWithoutAddonCategoryInput, MenuTemplateUncheckedCreateWithoutAddonCategoryInput>
  }

  export type AddonCreateWithoutCategoryInput = {
    name: string
    price: number
    template: MenuTemplateCreateNestedOneWithoutAddonInput
    items?: TemplateItemAddonCreateNestedManyWithoutAddonInput
  }

  export type AddonUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    price: number
    templateId: number
    items?: TemplateItemAddonUncheckedCreateNestedManyWithoutAddonInput
  }

  export type AddonCreateOrConnectWithoutCategoryInput = {
    where: AddonWhereUniqueInput
    create: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput>
  }

  export type AddonCreateManyCategoryInputEnvelope = {
    data: AddonCreateManyCategoryInput | AddonCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MenuTemplateUpsertWithoutAddonCategoryInput = {
    update: XOR<MenuTemplateUpdateWithoutAddonCategoryInput, MenuTemplateUncheckedUpdateWithoutAddonCategoryInput>
    create: XOR<MenuTemplateCreateWithoutAddonCategoryInput, MenuTemplateUncheckedCreateWithoutAddonCategoryInput>
    where?: MenuTemplateWhereInput
  }

  export type MenuTemplateUpdateToOneWithWhereWithoutAddonCategoryInput = {
    where?: MenuTemplateWhereInput
    data: XOR<MenuTemplateUpdateWithoutAddonCategoryInput, MenuTemplateUncheckedUpdateWithoutAddonCategoryInput>
  }

  export type MenuTemplateUpdateWithoutAddonCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutMenuTemplateNestedInput
    items?: TemplateItemUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateWithoutAddonCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateItemUncheckedUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type AddonUpsertWithWhereUniqueWithoutCategoryInput = {
    where: AddonWhereUniqueInput
    update: XOR<AddonUpdateWithoutCategoryInput, AddonUncheckedUpdateWithoutCategoryInput>
    create: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput>
  }

  export type AddonUpdateWithWhereUniqueWithoutCategoryInput = {
    where: AddonWhereUniqueInput
    data: XOR<AddonUpdateWithoutCategoryInput, AddonUncheckedUpdateWithoutCategoryInput>
  }

  export type AddonUpdateManyWithWhereWithoutCategoryInput = {
    where: AddonScalarWhereInput
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyWithoutCategoryInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    unitPrice: number
    templateItem: TemplateItemCreateNestedOneWithoutOrderItemInput
    variant?: TemplateItemVariantCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    templateItemId: number
    variantId?: number | null
    quantity: number
    unitPrice: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutOrderInput = {
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutLocationInput
    Brand: BrandCreateNestedOneWithoutLocationInput
    LocationStaff?: LocationStaffCreateNestedManyWithoutLocationInput
    Menu?: MenuCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrderInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
    LocationStaff?: LocationStaffUncheckedCreateNestedManyWithoutLocationInput
    Menu?: MenuUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrderInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    name: string
    phone: string
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    phone: string
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type LocationUpsertWithoutOrderInput = {
    update: XOR<LocationUpdateWithoutOrderInput, LocationUncheckedUpdateWithoutOrderInput>
    create: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutOrderInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutOrderInput, LocationUncheckedUpdateWithoutOrderInput>
  }

  export type LocationUpdateWithoutOrderInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutLocationNestedInput
    Brand?: BrandUpdateOneRequiredWithoutLocationNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutLocationNestedInput
    Menu?: MenuUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutLocationNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateWithoutCustomerInput = {
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    location: LocationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: number
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderCreateWithoutItemsInput = {
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutOrderInput
    Customer: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: number
    CustomerId: number
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type TemplateItemCreateWithoutOrderItemInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    template: MenuTemplateCreateNestedOneWithoutItemsInput
    variants?: TemplateItemVariantCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideCreateNestedManyWithoutTemplateItemInput
    Tag?: TagCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemUncheckedCreateWithoutOrderItemInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    templateId: number
    variants?: TemplateItemVariantUncheckedCreateNestedManyWithoutTemplateItemInput
    MenuItemOverride?: MenuItemOverrideUncheckedCreateNestedManyWithoutTemplateItemInput
    Tag?: TagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemTag?: TemplateItemTagUncheckedCreateNestedManyWithoutTemplateItemInput
    TemplateItemAddon?: TemplateItemAddonUncheckedCreateNestedManyWithoutTemplateItemInput
  }

  export type TemplateItemCreateOrConnectWithoutOrderItemInput = {
    where: TemplateItemWhereUniqueInput
    create: XOR<TemplateItemCreateWithoutOrderItemInput, TemplateItemUncheckedCreateWithoutOrderItemInput>
  }

  export type TemplateItemVariantCreateWithoutOrderItemInput = {
    label: string
    price: number
    templateItem: TemplateItemCreateNestedOneWithoutVariantsInput
  }

  export type TemplateItemVariantUncheckedCreateWithoutOrderItemInput = {
    id?: number
    label: string
    price: number
    itemId: number
  }

  export type TemplateItemVariantCreateOrConnectWithoutOrderItemInput = {
    where: TemplateItemVariantWhereUniqueInput
    create: XOR<TemplateItemVariantCreateWithoutOrderItemInput, TemplateItemVariantUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutOrderNestedInput
    Customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    CustomerId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemUpsertWithoutOrderItemInput = {
    update: XOR<TemplateItemUpdateWithoutOrderItemInput, TemplateItemUncheckedUpdateWithoutOrderItemInput>
    create: XOR<TemplateItemCreateWithoutOrderItemInput, TemplateItemUncheckedCreateWithoutOrderItemInput>
    where?: TemplateItemWhereInput
  }

  export type TemplateItemUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: TemplateItemWhereInput
    data: XOR<TemplateItemUpdateWithoutOrderItemInput, TemplateItemUncheckedUpdateWithoutOrderItemInput>
  }

  export type TemplateItemUpdateWithoutOrderItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemVariantUpsertWithoutOrderItemInput = {
    update: XOR<TemplateItemVariantUpdateWithoutOrderItemInput, TemplateItemVariantUncheckedUpdateWithoutOrderItemInput>
    create: XOR<TemplateItemVariantCreateWithoutOrderItemInput, TemplateItemVariantUncheckedCreateWithoutOrderItemInput>
    where?: TemplateItemVariantWhereInput
  }

  export type TemplateItemVariantUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: TemplateItemVariantWhereInput
    data: XOR<TemplateItemVariantUpdateWithoutOrderItemInput, TemplateItemVariantUncheckedUpdateWithoutOrderItemInput>
  }

  export type TemplateItemVariantUpdateWithoutOrderItemInput = {
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    templateItem?: TemplateItemUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type TemplateItemVariantUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type BrandCreateManyOwnerInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateManyManagerInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BrandId: number
  }

  export type LocationStaffCreateManyStaffInput = {
    id?: number
    locationId: number
  }

  export type BrandUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUpdateManyWithoutBrandNestedInput
    MenuTemplate?: MenuTemplateUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUncheckedUpdateManyWithoutBrandNestedInput
    MenuTemplate?: MenuTemplateUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutManagerInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brand?: BrandUpdateOneRequiredWithoutLocationNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutLocationNestedInput
    Menu?: MenuUpdateManyWithoutLocationNestedInput
    Order?: OrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutLocationNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    Order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BrandId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationStaffUpdateWithoutStaffInput = {
    location?: LocationUpdateOneRequiredWithoutLocationStaffNestedInput
  }

  export type LocationStaffUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationStaffUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationCreateManyBrandInput = {
    id?: number
    latitude: number
    longitude: number
    placeId?: string | null
    name?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    geohash?: string | null
    timezone?: string | null
    accuracy?: number | null
    managerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuTemplateCreateManyBrandInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type LocationUpdateWithoutBrandInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutLocationNestedInput
    LocationStaff?: LocationStaffUpdateManyWithoutLocationNestedInput
    Menu?: MenuUpdateManyWithoutLocationNestedInput
    Order?: OrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LocationStaff?: LocationStaffUncheckedUpdateManyWithoutLocationNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    Order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    geohash?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuTemplateUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateItemUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateItemUncheckedUpdateManyWithoutTemplateNestedInput
    Menu?: MenuUncheckedUpdateManyWithoutTemplateNestedInput
    Addon?: AddonUncheckedUpdateManyWithoutTemplateNestedInput
    AddonCategory?: AddonCategoryUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MenuTemplateUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationStaffCreateManyLocationInput = {
    id?: number
    staffId: number
  }

  export type MenuCreateManyLocationInput = {
    id?: number
    templateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyLocationInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerId: number
  }

  export type LocationStaffUpdateWithoutLocationInput = {
    staff?: UserUpdateOneRequiredWithoutLocationStaffNestedInput
  }

  export type LocationStaffUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationStaffUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuUpdateWithoutLocationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: MenuTemplateUpdateOneRequiredWithoutMenuNestedInput
    overrides?: MenuItemOverrideUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: MenuItemOverrideUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutLocationInput = {
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    Customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemCreateManyTemplateInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
  }

  export type MenuCreateManyTemplateInput = {
    id?: number
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddonCreateManyTemplateInput = {
    id?: number
    name: string
    price: number
    categoryId: number
  }

  export type AddonCategoryCreateManyTemplateInput = {
    id?: number
    name: string
    maxSelectable?: number
    isRequired?: boolean
  }

  export type TemplateItemUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    Tag?: TagUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MenuUpdateWithoutTemplateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutMenuNestedInput
    overrides?: MenuItemOverrideUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: MenuItemOverrideUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddonUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: AddonCategoryUpdateOneRequiredWithoutAddonsNestedInput
    items?: TemplateItemAddonUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    items?: TemplateItemAddonUncheckedUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type AddonCategoryUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    addons?: AddonUpdateManyWithoutCategoryNestedInput
  }

  export type AddonCategoryUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    addons?: AddonUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AddonCategoryUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxSelectable?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TemplateItemVariantCreateManyTemplateItemInput = {
    id?: number
    label: string
    price: number
  }

  export type MenuItemOverrideCreateManyTemplateItemInput = {
    id?: number
    menuId: number
    isAvailable?: boolean | null
    priceOverride?: number | null
  }

  export type OrderItemCreateManyTemplateItemInput = {
    id?: number
    orderId: number
    variantId?: number | null
    quantity: number
    unitPrice: number
  }

  export type TemplateItemTagCreateManyTemplateItemInput = {
    id?: number
    tagId: number
  }

  export type TemplateItemAddonCreateManyTemplateItemInput = {
    id?: number
    addonId: number
  }

  export type TemplateItemVariantUpdateWithoutTemplateItemInput = {
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    OrderItem?: OrderItemUpdateManyWithoutVariantNestedInput
  }

  export type TemplateItemVariantUncheckedUpdateWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    OrderItem?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MenuItemOverrideUpdateWithoutTemplateItemInput = {
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    menu?: MenuUpdateOneRequiredWithoutOverridesNestedInput
  }

  export type MenuItemOverrideUncheckedUpdateWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TagUpdateWithoutTemplateItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: TemplateItemTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    items?: TemplateItemTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemUpdateWithoutTemplateItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    variant?: TemplateItemVariantUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    variantId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    variantId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TemplateItemTagUpdateWithoutTemplateItemInput = {
    tag?: TagUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateItemTagUncheckedUpdateWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemTagUncheckedUpdateManyWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemAddonUpdateWithoutTemplateItemInput = {
    addon?: AddonUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateItemAddonUncheckedUpdateWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    addonId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    addonId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyVariantInput = {
    id?: number
    orderId: number
    templateItemId: number
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateWithoutVariantInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    templateItem?: TemplateItemUpdateOneRequiredWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type MenuItemOverrideCreateManyMenuInput = {
    id?: number
    templateItemId: number
    isAvailable?: boolean | null
    priceOverride?: number | null
  }

  export type MenuItemOverrideUpdateWithoutMenuInput = {
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    templateItem?: TemplateItemUpdateOneRequiredWithoutMenuItemOverrideNestedInput
  }

  export type MenuItemOverrideUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MenuItemOverrideUncheckedUpdateManyWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    isAvailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TemplateItemTagCreateManyTagInput = {
    id?: number
    itemId: number
  }

  export type TemplateItemTagUpdateWithoutTagInput = {
    templateItem?: TemplateItemUpdateOneRequiredWithoutTemplateItemTagNestedInput
  }

  export type TemplateItemTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemTagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemUpdateWithoutTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    template?: MenuTemplateUpdateOneRequiredWithoutItemsNestedInput
    variants?: TemplateItemVariantUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
    variants?: TemplateItemVariantUncheckedUpdateManyWithoutTemplateItemNestedInput
    MenuItemOverride?: MenuItemOverrideUncheckedUpdateManyWithoutTemplateItemNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemTag?: TemplateItemTagUncheckedUpdateManyWithoutTemplateItemNestedInput
    TemplateItemAddon?: TemplateItemAddonUncheckedUpdateManyWithoutTemplateItemNestedInput
  }

  export type TemplateItemUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemAddonCreateManyAddonInput = {
    id?: number
    itemId: number
  }

  export type TemplateItemAddonUpdateWithoutAddonInput = {
    templateItem?: TemplateItemUpdateOneRequiredWithoutTemplateItemAddonNestedInput
  }

  export type TemplateItemAddonUncheckedUpdateWithoutAddonInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateItemAddonUncheckedUpdateManyWithoutAddonInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type AddonCreateManyCategoryInput = {
    id?: number
    name: string
    price: number
    templateId: number
  }

  export type AddonUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    template?: MenuTemplateUpdateOneRequiredWithoutAddonNestedInput
    items?: TemplateItemAddonUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
    items?: TemplateItemAddonUncheckedUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    templateItemId: number
    variantId?: number | null
    quantity: number
    unitPrice: number
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    templateItem?: TemplateItemUpdateOneRequiredWithoutOrderItemNestedInput
    variant?: TemplateItemVariantUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    variantId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateItemId?: IntFieldUpdateOperationsInput | number
    variantId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    total: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: number
  }

  export type OrderUpdateWithoutCustomerInput = {
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    location?: LocationUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}